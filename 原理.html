<!DOCTYPE html>
<!-- saved from url=(0124)http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html -->
<html lang="en-US" class=" "><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    <title>什么是 Virtual DOM | 面试指南</title>
    
    <link rel="icon" href="./原理_files/logo.png">
    <link rel="manifest" href="http://interview.poetries.top/manifest.json">
    <link rel="apple-touch-icon" href="http://interview.poetries.top/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="http://interview.poetries.top/icons/safari-pinned-tab.svg" color="#3eaf7c">
    
    
    
    
    
    
    
    <link rel="preload" href="./原理_files/0.styles.a3a6df6c.css" as="style"><link rel="preload" href="./原理_files/app.545cb75b.js.下载" as="script"><link rel="preload" href="./原理_files/5.bc663a4c.js.下载" as="script"><link rel="preload" href="./原理_files/4.1aaf03c6.js.下载" as="script"><link rel="preload" href="./原理_files/44.5ebdd233.js.下载" as="script"><link rel="preload" href="./原理_files/11.3e5297f1.js.下载" as="script"><link rel="prefetch" href="./原理_files/1.d83c2af0.js.下载"><link rel="prefetch" href="http://interview.poetries.top/assets/js/10.fdecf69b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/100.df83f687.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/101.3986f029.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/102.1468be32.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/103.bfef2896.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/104.1731bbb1.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/105.710b118c.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/106.b955d37d.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/107.6f79a916.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/108.34ee5a8e.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/109.f6c05e4d.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/110.a375ddec.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/111.bcc5c187.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/112.afcfef56.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/113.2e7c6e37.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/114.9cfdb334.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/115.063815ec.js"><link rel="prefetch" href="./原理_files/116.4e29ee01.js.下载"><link rel="prefetch" href="http://interview.poetries.top/assets/js/117.b106fd0d.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/118.e4e784f7.js"><link rel="prefetch" href="./原理_files/119.94fe014a.js.下载"><link rel="prefetch" href="http://interview.poetries.top/assets/js/12.ac0bc851.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/13.57028e74.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/14.043c3e8a.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/15.a6d0032e.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/16.6094fda8.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/17.f17aa05b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/18.9732bfb3.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/19.2c38a6bb.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/20.92742304.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/21.28c8a661.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/22.3222a772.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/23.8192ecea.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/24.b5156b88.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/25.034d5e81.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/26.c78d8f63.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/27.cd94c89c.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/28.b2c8e24c.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/29.e9a30c2c.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/3.f5ea6e07.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/30.2bd67425.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/31.6333035e.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/32.1a34dfa0.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/33.b5863ac0.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/34.cababd6c.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/35.0b09d4a2.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/36.8f89ed73.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/37.38d590c3.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/38.4799c402.js"><link rel="prefetch" href="./原理_files/39.f28d21e8.js.下载"><link rel="prefetch" href="http://interview.poetries.top/assets/js/40.21e1dcb8.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/41.16e0641a.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/42.9ce6fd83.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/43.8936e729.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/45.ce59a54c.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/46.b6f1380b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/47.5fe8aac4.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/48.a31741eb.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/49.16132e72.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/50.ca74d5c9.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/51.f21f79ee.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/52.6ff2b7c5.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/53.003482ca.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/54.136b1210.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/55.5d00c7ca.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/56.cfa533e2.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/57.9275f210.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/58.dcf3e81b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/59.5cbf4407.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/6.f2ac32df.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/60.ecfb5f55.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/61.8356d65b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/62.8ca03065.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/63.a0c06a04.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/64.406f4c0f.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/65.9d0c9d57.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/66.ca2ccee4.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/67.b01df864.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/68.e99acf6a.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/69.f7dbb3b1.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/7.26b183c1.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/70.b3199540.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/71.d7c346c6.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/72.6afb9cd3.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/73.80370c6b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/74.eec2a38b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/75.fdbda41f.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/76.c8a9acd3.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/77.02560728.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/78.7a518fe7.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/79.01333f71.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/8.b6777e86.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/80.a7dfb481.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/81.29a3aa15.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/82.9039f284.js"><link rel="prefetch" href="./原理_files/83.e29f794c.js.下载"><link rel="prefetch" href="./原理_files/84.9aea4d6e.js.下载"><link rel="prefetch" href="http://interview.poetries.top/assets/js/85.6fa07b30.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/86.b0a530f1.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/87.a2c892ff.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/88.2c0ab353.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/89.0a6986cd.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/9.7231fa75.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/90.80c04201.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/91.19846beb.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/92.09ef3493.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/93.8bad40d8.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/94.f0810e7b.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/95.3a648c4f.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/96.827e7cb2.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/97.cc180b8f.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/98.d2138442.js"><link rel="prefetch" href="http://interview.poetries.top/assets/js/99.7e99e846.js">
    <link rel="stylesheet" href="./原理_files/0.styles.a3a6df6c.css">
  <style type="text/css">.medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}</style><meta name="description" content="前端面试指南，前端面试题整理，按模块分类整理总结，打造最全面的前端面试题"><meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png"><meta name="msapplication-TileColor" content="#000000"></head>
  <body class="">
    <div id="app"><div class="theme-container"><header class="navbar" style="background: rgb(255, 255, 255);"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="http://interview.poetries.top/" class="home-link router-link-active"><img src="./原理_files/logo.png" alt="面试指南" class="logo"> <span class="site-name can-hide">面试指南</span></a> <div class="links" style="background: rgb(255, 255, 255); max-width: 1771px;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value="" class="" placeholder=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div><a href="./index.html" class="nav-link">基础
  </a></div></div><div class="nav-item"><div><a href="./进阶.html" class="nav-link">✨进阶
  </a></div></div><div class="nav-item"><div><a href="./精选.html" class="nav-link">👍精选
  </a></div></div><div class="nav-item"><div><a href="./高频.html" class="nav-link">🔥高频
  </a></div></div><div class="nav-item"><div><a href="./指南.html" class="nav-link">指南
  </a></div></div><div class="nav-item"><div><a href="./性能.html" class="nav-link">性能
  </a></div></div><div class="nav-item"><div><a href="./综合.html" class="nav-link">综合
  </a></div></div><div class="nav-item"><div><a href="./vue.html" class="nav-link">原理
  </a></div></div><div class="nav-item"><div><a href="./手写.html" class="nav-link">手写
  </a></div></div><div class="nav-item"><div><a href="./自检.html" class="nav-link">自检
  </a></div></div><div class="nav-item"><div><a href="./面经.html" class="nav-link">⭐面经
  </a></div></div><div class="nav-item"><div><a href="./每日一题.html" class="nav-link">💥每日一题
  </a></div></div><div class="nav-item"><div><a href="./设计模式.html" class="nav-link">设计模式
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/algorithm-interview/note/01-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89.html" class="nav-link">
  </a></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="拓展阅读" class="dropdown-title"><span class="title">拓展阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display: none;"><li class="dropdown-item"><h4>专题</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-base-docs/compute-docs/Linux.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-mobile-docs/h5-docs/1-%E5%A4%A7%E5%8E%82%20H5%20%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-css-inspiration-docs/css-docs/note/01-%E6%B5%8F%E8%A7%88%E5%99%A8.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-vue-docs/learn-vue-base/base/1-Vue%20CLI%203%20%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-react-docs/react-web-action/01-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-micro-docs/docs/01-%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AF%9E%E7%94%9F.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-engineering-docs/docs/npm-script.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-nodejs-docs/nodejs-docs/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-ts-axios-docs/ts-axios/chapter1/" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-algorithm-docs/algorithm/prepare/01-%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      浏览器原理
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="https://blog.poetries.top/http-protocol/notes/base/01-HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      HTTP基础
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/webpack.html" class="nav-link">webpack
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/npm-script.html" class="nav-link">npm工作流
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/canvas.html" class="nav-link">Canvas
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/Taro.html" class="nav-link">Taro原理
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-nodejs-docs/nodejs-docs/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      Node学习指南
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-vue-docs/vue-analysis/prepare/" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      Vue源码分析
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-blog-docs/blog-docs/javascript/-Ajax%E6%80%BB%E7%BB%93%E7%AF%87.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      日常积累
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="http://blog.poetries.top/archives/" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      博文
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="background: rgb(255, 255, 255);"><nav class="nav-links"><div class="nav-item"><div><a href="http://interview.poetries.top/docs/base.html" class="nav-link">基础
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/simply.html" class="nav-link">✨进阶
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/excellent-docs/1-HTML%E6%A8%A1%E5%9D%97.html" class="nav-link">👍精选
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/excellent.html" class="nav-link">🔥高频
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/guide.html" class="nav-link">指南
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/performance.html" class="nav-link">性能
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/detail-expain.html" class="nav-link">综合
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" class="nav-link">原理
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/handwritten.html" class="nav-link">手写
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/qa/1-%E5%89%8D%E7%AB%AF100%E9%A2%98%E8%87%AA%E6%A3%80.html" class="nav-link">自检
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/interview-exp/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB.html" class="nav-link">⭐面经
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/days/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.html" class="nav-link">💥每日一题
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/docs/design-pattern.html" class="nav-link">设计模式
  </a></div></div><div class="nav-item"><div><a href="http://interview.poetries.top/algorithm-interview/note/01-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89.html" class="nav-link">
  </a></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="拓展阅读" class="dropdown-title"><span class="title">拓展阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display: none;"><li class="dropdown-item"><h4>专题</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-base-docs/compute-docs/Linux.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-mobile-docs/h5-docs/1-%E5%A4%A7%E5%8E%82%20H5%20%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-css-inspiration-docs/css-docs/note/01-%E6%B5%8F%E8%A7%88%E5%99%A8.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-vue-docs/learn-vue-base/base/1-Vue%20CLI%203%20%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-react-docs/react-web-action/01-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-micro-docs/docs/01-%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AF%9E%E7%94%9F.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-engineering-docs/docs/npm-script.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-nodejs-docs/nodejs-docs/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-ts-axios-docs/ts-axios/chapter1/" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-algorithm-docs/algorithm/prepare/01-%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----></a></div></li><li class="dropdown-subitem"><div><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      浏览器原理
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="https://blog.poetries.top/http-protocol/notes/base/01-HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      HTTP基础
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/webpack.html" class="nav-link">webpack
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/npm-script.html" class="nav-link">npm工作流
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/canvas.html" class="nav-link">Canvas
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/docs/Taro.html" class="nav-link">Taro原理
  </a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-nodejs-docs/nodejs-docs/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      Node学习指南
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-vue-docs/vue-analysis/prepare/" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      Vue源码分析
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><div><a href="http://interview.poetries.top/fe-blog-docs/blog-docs/javascript/-Ajax%E6%80%BB%E7%BB%93%E7%AF%87.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      日常积累
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li><li class="dropdown-subitem"><div><a href="http://blog.poetries.top/archives/" target="_blank" rel="noopener noreferrer" class="nav-link external"><div>
      博文
      <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div></a></div></li></ul></li></ul></div></div> <!----></nav> <div style="padding-left:1.5rem;"><div class="qr"><img src="./原理_files/qr.ee193d28.jpg" alt="poetries" width="120" height="120" loading="lazy"> <p class="we-intro">
    关注公众号，获取更多资讯
  </p></div></div> 
  <ul class="sidebar-links"><li><section class="sidebar-group depth-0">
    <p class="sidebar-heading"><span>Vue</span> <!----></p> 
    <ul class="sidebar-links sidebar-group-items"><li>
      <a href="./vue.html" class="sidebar-link">从源码解读Vue生命周期</a></li>
      <li><a href="#block1" class="sidebar-link">组件的本质</a></li>
      <li><a href="#block2" class="sidebar-link">有状态组件的设计</a></li>
      <li><a href="" class="sidebar-link">设计 VNode</a></li>
      <li><a href=".html" class="sidebar-link">辅助创建 VNode 的 h 函数</a></li>
      <li><a href=".html" class="sidebar-link">自定义渲染器和异步渲染</a></li>
      <li><a href=".html" class="sidebar-link">渲染器之挂载</a></li>
      <li><a href="0%E7%AE%97%E6%B3%95.html" class="sidebar-link">渲染器的核心 Diff 算法</a></li>
      <li><a href=".html" class="sidebar-link">渲染器之patch</a></li>
      <li><a href="F%E7%90%86.html" class="sidebar-link">图解 Vue 响应式原理</a></li>
      <li><a href=".html" class="sidebar-link">图解 Vue 异步更新</a></li>
      <li><a href="%E6%9C%BA%E5%88%B6.html" class="sidebar-link">剖析 Vue 内部运行机制</a></li>
      <li><a href="9F.html" class="sidebar-link">vue响应式原理模拟</a></li>
      <li><a href=".html" class="sidebar-link">vue状态管理之vuex</a></li>
    </ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> 
      <ul class="sidebar-links sidebar-group-items">
        <li><a href=".html" class="sidebar-link">React</a></li>
        <li><a href=".html" class="sidebar-link">Dva总结</a></li>
        <li><a href=".html" class="sidebar-link">MobX总结</a></li>
        <li><a href="E5%8F%8A%E7%94%A8%E6%B3%95.html" class="sidebar-link">浅析redux</a></li>
        <li><a href=".html" class="sidebar-link">Redux之浅析中间件</a></li>
        <li><a href=".html" class="sidebar-link">Redux之源码分析</a></li>
        <li><a href="4%BD%9C.html" class="sidebar-link">Redux之异步Action及操作</a></li>
      </ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> 
        <ul class="sidebar-links sidebar-group-items">
          <li><a href="%E7%90%86%E8%A7%A3%E6%9E%90.html" class="sidebar-link">Webpack4打包机制原理解析</a></li>
          <li><a href=".html" class="sidebar-link">webpack中的HMR热更新原理剖析</a></li>
          <li><a href=".html" class="sidebar-link">从源码窥探Webpack4.x原理</a></li>
          <li><a href=".html" class="sidebar-link">实现webpack小型打包工具</a></li>
          <li><a href=".html" class="sidebar-link">Babel原理及其使用</a></li>
        </ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>综合</span> <!----></p>
           <ul class="sidebar-links sidebar-group-items">
             <li><a href=".html" class="active sidebar-link">虚拟DOM原理分析</a>
              <ul class="sidebar-sub-headers"><li class="sidebar-sub-header">
                <a href="" class="sidebar-link">什么是 Virtual DOM</a></li>
                <li class="sidebar-sub-header"><a href=".html" class="sidebar-link">浅析Promise原理</a></li><li>
        <a href=".html" class="sidebar-link">浏览器渲染原理</a></li>
        <li><a href=".html" class="sidebar-link">前端面试之MVVM浅析</a></li>
        <li><a href=".html" class="sidebar-link">前端面试之组件化</a></li>
        <li><a href=".html" class="sidebar-link">虚拟DOM（一）</a></li>
        <li><a href=".html" class="sidebar-link">虚拟DOM（二）</a></li>
        <li><a href=".html" class="sidebar-link">前端性能之Performance</a></li>
      </ul></section></li></ul> </aside> <main class="page"> <div id="container" class="theme-default-content pay-content">
          <!-- 生命周期 -->
          <div class="content__default"><h2 id="基础知识"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" class="header-anchor">#</a> 基础知识</h2> <h3 id="钩子函数"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" class="header-anchor">#</a> 钩子函数</h3> <blockquote><p>其实和回调是一个概念，当系统执行到某处时，检查是否有<code>hook</code>(钩子)，有的话就会执行回调。</p></blockquote> <p>通俗的说，<code>hook</code>就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写</p> <p><img src="./vue_files/77.jpeg" alt="" class="medium-zoom-image"></p> <p><strong>总的来说，Vue的生命周期可以分为以下八个阶段</strong></p> <ul><li><code>beforeCreate</code>  实例创建前</li> <li><code>created</code>       实例创建完成</li> <li><code>beforeMount</code>   挂载前</li> <li><code>mounted</code>       挂载完成</li> <li><code>beforeUpdate</code>  更新前</li> <li><code>updated</code>       更新完成</li> <li><code>beforeDestory</code> 销毁前</li> <li><code>destoryed</code>     销毁完成</li></ul> <h3 id="beforecreate"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforecreate" class="header-anchor">#</a> beforeCreate</h3> <blockquote><p>这个钩子是<code>new Vue()</code>之后触发的第一个钩子，在当前阶段中<code>data</code>、<code>methods</code>、<code>computed</code>以及<code>watch</code>上的数据和方法均不能被访问。</p></blockquote> <h3 id="created"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#created" class="header-anchor">#</a> created</h3> <blockquote><p>这个钩子在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发<code>updated</code>函数。可以做一些初始数据的获取，在当前阶段无法与<code>Dom</code>进行交互，如果你非要想，可以通过<code>vm.$nextTick</code>来访问<code>Dom</code>。</p></blockquote> <h3 id="beforemount"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforemount" class="header-anchor">#</a> beforeMount</h3> <blockquote><p>这个钩子发生在挂载之前，在这之前<code>template</code>模板已导入渲染函数编译。而当前阶段虚拟<code>Dom</code>已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发<code>updated</code></p></blockquote> <h3 id="mounted"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#mounted" class="header-anchor">#</a> mounted</h3> <blockquote><p>这个钩子在挂载完成后发生，在当前阶段，真实的<code>Dom</code>挂载完毕，数据完成双向绑定，可以访问到<code>Dom</code>节点，使用<code>$refs</code>属性对<code>Dom</code>进行操作。也可以向后台发送请求，拿到返回数据</p></blockquote> <h3 id="beforeupdate"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforeupdate" class="header-anchor">#</a> beforeUpdate</h3> <blockquote><p>这个钩子发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染</p></blockquote> <h3 id="updated"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#updated" class="header-anchor">#</a> updated</h3> <blockquote><p>这个钩子发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</p></blockquote> <h3 id="beforedestroy"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforedestroy" class="header-anchor">#</a> beforeDestroy</h3> <blockquote><p>这个钩子发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p></blockquote> <h3 id="destroyed"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#destroyed" class="header-anchor">#</a> destroyed</h3> <blockquote><p>这个钩子发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁</p></blockquote> <p><strong>注意点</strong></p> <blockquote><p>在使用生命周期时有几点注意事项需要我们牢记</p></blockquote> <p>1.除了<code>beforeCreate</code>和<code>created</code>钩子之外，其他钩子均在服务器端渲染期间不被调用。
2.上文曾提到过，在<code>updated</code>的时候千万不要去修改<code>data</code>里面赋值的数据，否则会导致死循环。
3.<code>Vue</code>的所有生命周期函数都是自动绑定到<code>this</code>的上下文上。所以，你这里使用箭头函数的话，就会出现<code>this</code>指向的父级作用域，就会报错。原因下面源码部分会讲解</p> <h2 id="源码解读"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" class="header-anchor">#</a> 源码解读</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/core/instance/lifecycle.js</span>
<span class="token comment">// callhook 函数的功能就是在当前vue组件实例中，调用某个生命周期钩子注册的所有回调函数。</span>
<span class="token comment">// vm:Vue实例</span>
<span class="token comment">// hook:生命周期名字</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">callHook</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span> hook<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> handlers <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">[</span>hook<span class="token punctuation">]</span> 
  <span class="token comment">// 初始化合并 options 的过程 、，将各个生命周期函数合并到 options 里</span>
  <span class="token keyword">const</span> info <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hook<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> hook</span><span class="token template-punctuation string">`</span></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> handlers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">invokeWithErrorHandling</span><span class="token punctuation">(</span>handlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_hasHookEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'hook:'</span> <span class="token operator">+</span> hook<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// src/core/util/error.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">invokeWithErrorHandling</span> <span class="token punctuation">(</span>
  <span class="token parameter">handler<span class="token operator">:</span> Function<span class="token punctuation">,</span>
  context<span class="token operator">:</span> any<span class="token punctuation">,</span>
  args<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  vm<span class="token operator">:</span> any<span class="token punctuation">,</span>
  info<span class="token operator">:</span> string</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> args <span class="token operator">?</span> <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>res<span class="token punctuation">.</span>_isVue <span class="token operator">&amp;&amp;</span> <span class="token function">isPromise</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>res<span class="token punctuation">.</span>_handled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span>_handled <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>我们从上面的代码中可以看到<code>callHook</code>中调用了<code>invokeWithErrorHandling</code>方法，在<code>invokeWithErrorHandling</code>方法中，使用了<code>apply</code>和<code>call</code>改变了<code>this</code>指向，而在箭头函数中<code>this</code>指向是无法改变的，所以我们在编写生命周期函数的时候不能使用箭头函数</p></blockquote> <h3 id="beforecreate和created"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforecreate%E5%92%8Ccreated" class="header-anchor">#</a> beforeCreate和created</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/core/instance/init</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initMixin</span> <span class="token punctuation">(</span><span class="token parameter">Vue<span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token operator">...</span>
    <span class="token comment">// 合并选项部分已省略</span>
    
    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  
    <span class="token comment">// 主要就是给vm对象添加了 $parent、$root、$children 属性，以及一些其它的生命周期相关的标识</span>
    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 初始化事件相关的属性</span>
    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  <span class="token comment">// vm 添加了一些虚拟 dom、slot 等相关的属性和方法</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 beforeCreate 钩子</span>
    <span class="token comment">//下面 initInjections(vm) 和 initProvide(vm) 两个配套使用，用于将父组件 _provided 中定义的值，通过 inject 注入到子组件，且这些属性不会被观察</span>
    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> 
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>   <span class="token comment">// props、methods、data、watch、computed等数据初始化</span>
    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> 
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 created 钩子</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// src/core/instance/state</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>我们可以看到<code>beforeCreate</code>钩子调用是在<code>initState</code>之前的，而从上面的第二段代码我们可以看出<code>initState</code>的作用是对<code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code>、<code>watch</code>等属性做初始化处理。</li> <li>通过阅读源码，我们更加清楚的明白了在beforeCreate钩子的时候我们没有对<code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code>、<code>watch</code>上的数据的访问权限。在<code>created</code>中才可以</li></ul> <h3 id="beforemount和mounted"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforemount%E5%92%8Cmounted" class="header-anchor">#</a> beforeMount和mounted</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// mountComponent 核心就是先实例化一个渲染Watcher</span>
<span class="token comment">// 在它的回调函数中会调用 updateComponent 方法</span>
<span class="token comment">// 两个核心方法 vm._render(生成虚拟Dom) 和 vm._update(映射到真实Dom)</span>
<span class="token comment">// src/core/instance/lifecycle</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span>
  <span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  el<span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render <span class="token operator">=</span> createEmptyVNode
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
  <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeMount'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 beforeMount 钩子</span>

  <span class="token keyword">let</span> updateComponent
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将虚拟 Dom 映射到真实 Dom 的函数。</span>
    <span class="token comment">// vm._update 之前会先调用 vm._render() 函数渲染 VNode</span>
      <span class="token operator">...</span>
      <span class="token keyword">const</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token operator">...</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 先判断是否 mouted 完成 并且没有被 destroyed</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'mounted'</span><span class="token punctuation">)</span>  <span class="token comment">//调用 mounted 钩子</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>通过上面的代码，我们可以看出在执行<code>vm._render()</code>函数渲染<code>VNode</code>之前，执行了 <code>beforeMount</code>钩子函数，在执行完 <code>vm._update()</code> 把<code>VNode patch</code>到真实Dom后，执行 <code>mouted</code>钩子。也就明白了为什么直到<code>mounted</code>阶段才名正言顺的拿到了Dom</p></blockquote> <h3 id="beforeupdate和updated"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforeupdate%E5%92%8Cupdated" class="header-anchor">#</a> beforeUpdate和updated</h3> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// src/core/instance/lifecycle</span>
 <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 先判断是否 mouted 完成 并且没有被 destroyed</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 beforeUpdate 钩子</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
 
 <span class="token comment">// src/core/observer/scheduler </span>
 <span class="token keyword">function</span> <span class="token function">callUpdatedHooks</span> <span class="token punctuation">(</span><span class="token parameter">queue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span>length
   <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token keyword">const</span> vm <span class="token operator">=</span> watcher<span class="token punctuation">.</span>vm
     <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_watcher <span class="token operator">===</span> watcher <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 只有满足当前 watcher 为 vm._watcher（也就是当前的渲染watcher）</span>
       <span class="token comment">// 以及组件已经 mounted 并且没有被 destroyed 才会执行 updated 钩子函数。</span>
       <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'updated'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 updated 钩子</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre></div><ul><li>第一段代码就是在<code>beforeMount</code>和<code>mounted</code>钩子中间出现的，那么<code>watcher</code>中究竟做了些什么呢？</li> <li>第二段代码的<code>callUpdatedHooks</code>函数中什么时候才可以满足条件并执行<code>updated</code>呢？我们来接着往下看。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/instance/observer/watcher.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>
    vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>
    expOrFn<span class="token operator">:</span> string <span class="token operator">|</span> Function<span class="token punctuation">,</span>
    cb<span class="token operator">:</span> Function<span class="token punctuation">,</span>
    options<span class="token operator">?</span><span class="token operator">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
    <span class="token comment">// 在它的构造函数里会判断 isRenderWatcher，</span>
    <span class="token comment">// 接着把当前 watcher 的实例赋值给 vm._watcher</span>
    isRenderWatcher<span class="token operator">?</span><span class="token operator">:</span> boolean
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 还把当前 wathcer 实例 push 到 vm._watchers 中，</span>
    <span class="token comment">// vm._watcher 是专门用来监听 vm 上数据变化然后重新渲染的，</span>
    <span class="token comment">// 所以它是一个渲染相关的 watcher，因此在 callUpdatedHooks 函数中，</span>
    <span class="token comment">// 只有 vm._watcher 的回调执行完毕后，才会执行 updated 钩子函数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isRenderWatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>_watcher <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>看到这里我们明白了<code>Vue</code>是通过<code>watcher</code>来监听实例上的数据变化，进而控制渲染流程</p></blockquote> <h3 id="beforedestroy和destroyed"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#beforedestroy%E5%92%8Cdestroyed" class="header-anchor">#</a> beforeDestroy和destroyed</h3> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// src/core/instance/lifecycle.js</span>
  <span class="token comment">// 在 $destroy 的执行过程中，它会执行 vm.__patch__(vm._vnode, null)</span>
  <span class="token comment">// 触发它子组件的销毁钩子函数，这样一层层的递归调用，</span>
  <span class="token comment">// 所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$destroy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isBeingDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeDestroy'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 beforeDestroy 钩子</span>
    vm<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// 一些销毁工作</span>
    <span class="token keyword">const</span> parent <span class="token operator">=</span> vm<span class="token punctuation">.</span>$parent
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>parent<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">remove</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$children<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 拆卸 watchers</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>_watcher<span class="token punctuation">.</span><span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">.</span>length
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
    vm<span class="token punctuation">.</span>_isDestroyed <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// 调用当前 rendered tree 上的 destroy 钩子</span>
    <span class="token comment">// 发现子组件，会先去销毁子组件</span>
    vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_vnode<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'destroyed'</span><span class="token punctuation">)</span>  <span class="token comment">// 调用 destroyed 钩子</span>
    <span class="token comment">// 关闭所有实例侦听器。</span>
    vm<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 删除 __vue__ 引用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放循环引用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>通过上面的代码，我们了解了组件销毁阶段的拆卸过程，其中会执行一个<code>__patch__</code>函数</li> <li>除了这八种钩子外，我们在官网也可以查阅到另外几种不常用的钩子，这里列举出来</li></ul> <h2 id="几种不常用的钩子"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E9%92%A9%E5%AD%90" class="header-anchor">#</a> 几种不常用的钩子</h2> <h3 id="activated"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#activated" class="header-anchor">#</a> activated</h3> <blockquote><p><code>keep-alive</code> 组件激活时调用，该钩子在服务器端渲染期间不被调用。</p></blockquote> <h3 id="deactivated"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#deactivated" class="header-anchor">#</a> deactivated</h3> <blockquote><p><code>keep-alive</code> 组件停用时调用，该钩子在服务器端渲染期间不被调用。</p></blockquote> <h3 id="errorcaptured"><a href="http://interview.poetries.top/principle-docs/vue/01-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#errorcaptured" class="header-anchor">#</a> errorCaptured</h3> <ul><li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播</li> <li>你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。</li></ul></div>
<!-- 组件的本质 -->
<div class="content__default"><blockquote><p>当我们使用 <code>Vue</code> 或 <code>React</code> 时，往往会将页面拆分为各种组件，通过拼装组件来形成页面和应用，就像搭积木一样。</p></blockquote> <p>那么，大家有没有思考过：<strong>"组件的产出是什么？"</strong></p> <h2 id="block1"><a href="http://interview.poetries.top/principle-docs/vue/02-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8.html#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BA%A7%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88" class="header-anchor">#</a> 组件的产出是什么</h2> <p>在 <code>JQuery</code> 盛行的年代，比起组件，“模板引擎”的概念要更加流行。</p> <p>我们可以使用 <code>lodash.template</code> 函数来回忆一下当年是如何用模板开发一个页面的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> template <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lodash'</span>

  <span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token function">template</span><span class="token punctuation">(</span><span class="token string">'&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">compiler</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'My Component'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> html
  </code></pre></div><p>模板引擎的概念是：<code>字符串 + 数据 =&gt; html</code>。</p> <p><code>lodash.template</code> 函数虽然称不上是“引擎”，但足以说明问题。</p> <p>我们将模板字符串传递给 <code>template</code> 函数，该函数返回一个编译器 <code>compiler</code>，只要把数据传入 <code>compiler</code> 函数，便能得到最终想要渲染的内容。</p> <p>当数据发生变化时，我们需要使用新的数据重新编译模板：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> newHtml <span class="token operator">=</span> <span class="token function">compiler</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'New Component'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  </code></pre></div><p>如果把上面的逻辑封装成一个函数，那么一个组件就诞生了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">MyComponent</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> compiler <span class="token operator">=</span> MyComponent<span class="token punctuation">.</span>cache <span class="token operator">||</span> <span class="token punctuation">(</span>MyComponent<span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token function">template</span><span class="token punctuation">(</span><span class="token string">'&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">compiler</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  MyComponent<span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token keyword">null</span>
  </code></pre></div><p>我们可以这样使用它：</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'MyComponent'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  </code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/m7nqlj8m9j" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/m7nqlj8m9j<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p><code>MyComponent</code> 组件也许会带给你这样的感觉：<strong>一个组件就是一个函数，给我什么样的数据，我就渲染对应的 html 内容</strong>。</p> <p>这个概念，与我们如今谈论的 <code>Vue</code> 或 <code>React</code> 并没有什么不同。所以，这 就是 <strong>组件的本质</strong>。</p> <p>组件的本质虽然没变，但组件的产出却改变了。在模板引擎的年代，组件的产出是 <code>html</code> 字符串：</p> <p><img src="./组件的本质_files/template.d03fa4be.png" alt="template" class="medium-zoom-image"></p> <p>而如今的 <code>Vue</code> 或 <code>React</code>，它们的组件所产出的内容并不是 <code>html</code> 字符串，而是大家所熟知的 <code>Virtual DOM</code>。</p> <p><img src="./组件的本质_files/virtual-dom.6b695177.png" alt="virtual-dom" class="medium-zoom-image"></p> <p>拿 <code>Vue</code> 来说，一个组件最核心的东西是 <code>render</code> 函数，剩余的其他内容，如 <code>data</code>、<code>compouted</code>、<code>props</code> 等都是为 <code>render</code> 函数提供数据来源服务的。<code>render</code> 函数本可以直接产出 <code>html</code> 字符串，但却产出了 <code>Virtual DOM</code>，借助 <code>snabbdom</code> 的 API 我们可以很容易地用代码描述这个公式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>
  
  <span class="token comment">// h 函数用来创建 VNode，组件的产出是 VNode</span>
  <span class="token keyword">const</span> <span class="token function-variable function">MyComponent</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>title<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p><code>Virtual DOM</code> 终究要渲染真实 DOM，这个过程就可以理解为模板引擎年代的完全替换 <code>html</code>，只不过它采用的不是完全替换，我们通常把这个过程叫做 <code>patch</code>，同样可以借助 <code>snabbdom</code> 的 API 轻松地实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> init <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>
  <span class="token comment">// init 方法用来创建 patch 函数</span>
  <span class="token keyword">const</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  
  <span class="token keyword">const</span> <span class="token function-variable function">MyComponent</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>title<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 组件的产出是 VNode</span>
  <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'prev'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 将 VNode 渲染成真实 DOM</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prevVnode<span class="token punctuation">)</span>
  </code></pre></div><p>当数据变更时，组件会产出新的 <code>VNode</code>，我们只需再次调用 <code>patch</code> 函数即可：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 数据变更，产出新的 VNode</span>
  <span class="token keyword">const</span> nextVnode <span class="token operator">=</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'next'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 通过对比新旧 VNode，高效地渲染真实 DOM</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> nextVnode<span class="token punctuation">)</span>
  </code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/mq0q8r50w8" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/mq0q8r50w8<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>以上就是我们要达成的共识：<strong>组件的产出就是 Virtual DOM</strong>。</p> <p>为何组件要从直接产出 <code>html</code> 变成产出 <code>Virtual DOM</code> 呢？其原因是 <code>Virtual DOM</code> 带来了 <strong>分层设计</strong>，它对渲染过程的抽象，使得框架可以渲染到 <code>web</code>(浏览器) 以外的平台，以及能够实现 <code>SSR</code> 等。</p> <p>至于 <code>Virtual DOM</code> 相比原生 DOM 操作的性能，这并非 <code>Virtual DOM</code> 的目标，确切地说，如果要比较二者的性能是要“控制变量”的，例如：页面的大小、数据变化量等。</p> <h2 id="组件的-vnode-如何表示"><a href="http://interview.poetries.top/principle-docs/vue/02-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8.html#%E7%BB%84%E4%BB%B6%E7%9A%84-vnode-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA" class="header-anchor">#</a> 组件的 VNode 如何表示</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在后续行文时，将统一使用 <code>VNode</code> 来简称 <code>Virtual DOM</code> 。</p></div> <p><code>VNode</code> 是真实 DOM 的描述，比如我们可以用如下对象描述一个 <code>div</code> 标签：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>想要把 <code>elementVnode</code> 渲染成真实 DOM，我们还需要一个渲染器(<code>Renderer</code>)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  </code></pre></div><p>渲染器接收两个参数，分别是将要渲染的 <code>vnode</code> 和 元素挂载点(真实 DOM 被渲染的位置)。</p> <p>为了渲染如上的 <code>div</code> 标签，我们可以这样调用 <code>render</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 把 elementVnode 渲染到 id 为 app 的元素下</span>
  <span class="token function">render</span><span class="token punctuation">(</span>elementVnode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  </code></pre></div><p><code>render</code> 函数的实现也很简单：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建元素</span>
    <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
    <span class="token comment">// 将元素添加到容器</span>
    container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，在 <code>render</code> 函数内调用了 <code>mountElement</code>，它的作用是根据 <code>VNode</code> 创建真实 DOM 并将其添加到容器中。</p> <p>这段代码对于标准 <code>html</code> 标签是可以正常工作的(不考虑 SVG)，但并不适用于组件。为了能够渲染组件，我们需要思考：<strong>组件的 <code>VNode</code> 应该如何表示？</strong></p> <p>对于 <code>html</code> 标签的 <code>VNode</code> 来说，其 <code>tag</code> 属性的值就是标签的名字，但如果是组件的话，其 <code>VNode</code> 中 <code>tag</code> 属性的值应该是什么呢？</p> <p>很简单，我们可以将其指向组件自身。假设我们有如下组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// render 函数产出 VNode</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'div'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，我们使用 <code>class</code> 定义了一个类，它是一个组件(有状态组件)，我们可以使用如下 <code>VNode</code> 来描述它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> componentVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> MyComponent
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，直接将 <code>tag</code> 属性的值指向组件自身。但想要正确地渲染该组件，我们还需要修改 <code>render</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> vnode<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// html 标签</span>
      <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 组件</span>
      <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，通过 <strong>判断 <code>vnode.tag</code> 是否是字符串</strong> 来区分：一个 <code>VNode</code> 到底是 <code>html</code> 标签还是组件。如果是组件的话，调用 <code>mountComponent</code> 函数挂载组件，而非 <code>mountElement</code>，如下是 <code>mountComponent</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>道理很简单，由于 <code>vnode.tag</code> 指向组件类，所以我们创建一个组件实例，接着调用其 <code>render</code> 函数产出 <code>VNode</code> 并将其添加到实例属性 <code>instance.$vnode</code>，最后借用 <code>mountElement</code> 函数完成标签的挂载即可。</p> <p>实际上为了便于理解，本节代码的简化程度很大，更加详细严谨的代码会在后续的具体章节中体现。不过这足以说明问题：<strong>可以让 <code>VNode</code> 的 <code>tag</code> 属性指向组件本身，从而使用 <code>VNode</code> 来描述组件</strong>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/8817m3zz5j" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/8817m3zz5j<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="组件的种类"><a href="http://interview.poetries.top/principle-docs/vue/02-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8.html#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB" class="header-anchor">#</a> 组件的种类</h2> <p>大家可能会注意到，在上文中，采用了两种不同的方式来描述组件。</p> <p>第一种方式是使用一个普通的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  </code></pre></div><p>第二种方式是使用一个类：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  </code></pre></div><p>实际上它们分别代表两类组件：<strong>函数式组件(Functional component)</strong> 和 <strong>有状态组件(Stateful component)</strong>。</p> <p>它们的区别如下：</p> <ul><li><p>函数式组件：</p> <ul><li>是一个纯函数</li> <li>没有自身状态，只接收外部数据</li> <li>产出 <code>VNode</code> 的方式：单纯的函数调用</li></ul></li> <li><p>有状态组件：</p> <ul><li>是一个类，可实例化</li> <li>可以有自身状态</li> <li>产出 <code>VNode</code> 的方式：需要实例化，然后调用其 <code>render</code> 函数</li></ul></li></ul> <p>在后续渲染器的相关章节中，会再次讲述 <strong>有状态组件</strong> 与 <strong>函数式组件</strong> 的原理和异同，那时你的理解会更加深刻。</p></div>
  <!-- 组件的设计 -->
  <div id="block2" class="content__default"><p>假设我们有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MyComponent</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>由这段模板可知，我们为 <code>MyComponent</code> 组件提供了一个空的 <code>div</code> 标签作为默认插槽内容，从DOM结构上看 <code>&lt;MyComponent&gt;</code> 标签有一个 <code>div</code> 标签作为子节点，通常我们可以将其编译为如下 <code>VNode</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token string">'div'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>这其实没什么问题，但是我们更倾向于新建一个 <code>slots</code> 属性来存储这些子节点，这在语义上更加贴切，所以我们希望将模板编译为如下 <code>VNode</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    slots<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 默认插槽</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">,</span>
        tag<span class="token operator">:</span> <span class="token string">'div'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>可以看到，如上 <code>VNode</code> 的 <code>children</code> 属性值为 <code>null</code>。当我们使用 <code>mountComponent</code> 函数挂载如上 <code>VNode</code> 时，我们可以在<strong>组件实例化之后</strong>并且在<strong>组件的渲染函数执行之前</strong>将 <code>compVNode.slots</code> 添加到组件实例对象上，这样当组件的渲染函数执行的时候，就可以访问插槽数据：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
    <span class="token comment">// 设置 slots</span>
    instance<span class="token punctuation">.</span>$slots <span class="token operator">=</span> vnode<span class="token punctuation">.</span>slots
  
    <span class="token comment">// 渲染</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>在 <code>MyComponent</code> 组件的 <code>render</code> 函数内，我们就可以通过组件实例访问 <code>slots</code> 数据：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">,</span>
        tag<span class="token operator">:</span> <span class="token string">'h1'</span>
        children<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>default
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>实际上，这就是普通插槽的实现原理，至于作用域插槽(<code>scopedSlots</code>)，与普通插槽并没有什么本质的区别，我们知道作用域插槽可以访问子组件的数据，在实现上来看其实就是函数传参：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">,</span>
        tag<span class="token operator">:</span> <span class="token string">'h1'</span>
        <span class="token comment">// 插槽变成了函数，可以传递参数</span>
        children<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上代码所示，只要 <code>this.$slots.default</code> 是函数即可实现，所以在模板编译时，我们最终需要得到如下 <code>VNode</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    slots<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 作用域插槽，可以接受组件传递过来的数据</span>
      <span class="token function-variable function">default</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> tag <span class="token operator">=</span> arg <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">'div'</span> <span class="token operator">:</span> <span class="token string">'h1'</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
          flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">,</span>
          tag
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>现在你应该明白为什么普通插槽和作用域插槽本质上并没有区别了，因为普通插槽也可以是函数，只是不接收参数罢了。这么看的话其实普通插槽是作用域插槽的子集，那为什么不将它们合并呢？没错从 <code>Vue2.6</code> 起已经将之合并，所有插槽在 <code>VNode</code> 中都是函数，一个返回 <code>VNode</code> 的函数。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>用过 <code>React</code> 的朋友，这让你想起 <code>Render Prop</code> 了吗！</p></div> <h2 id="key-和-ref"><a href="http://interview.poetries.top/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#key-%E5%92%8C-ref" class="header-anchor">#</a> key 和 ref</h2> <p><code>key</code> 就像 <code>VNode</code> 的唯一标识，用于 <code>diff</code> 算法的优化，它可以是数字也可以是字符串：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
    key<span class="token operator">:</span> <span class="token string">'li_0'</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p><code>ref</code> 的设计是为了提供一种能够拿到真实DOM的方式，当然如果将 <code>ref</code> 应用到组件上，那么拿到的就是组件实例，我们通常会把 <code>ref</code> 设计成一个函数，假设我们有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>el =&gt; elRef = el<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>我们可以把这段模板编译为如下 <code>VNode</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">ref</span><span class="token operator">:</span> <span class="token parameter">el</span> <span class="token operator">=&gt;</span> elRef <span class="token operator">=</span> el
  <span class="token punctuation">}</span>
  </code></pre></div><p>在使用 <code>mountElement</code> 函数挂载如上 <code>VNode</code> 时，可以轻松的实现 <code>ref</code> 功能：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
    container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如果挂载的是组件而非普通标签，那么只需要将组件实例传递给 <code>vnode.ref</code> 函数即可：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><h2 id="parentvnode-以及它的作用"><a href="http://interview.poetries.top/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#parentvnode-%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8" class="header-anchor">#</a> parentVNode 以及它的作用</h2> <p>与 <code>VNode</code> 的 <code>slots</code> 属性相同，<code>parentVNode</code> 属性也是给组件的 <code>VNode</code> 准备的，组件的 <code>VNode</code> 为什么需要这两个属性呢？它俩的作用又是什么呢？想弄清楚这些，我们至少要先弄明白：<strong>一个组件所涉及的 <code>VNode</code> 都有哪些</strong>。什么意思呢？看如下模板思考一个问题：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>从这个模板来看 <code>MyComponent</code> 组件至少涉及到两个 <code>VNode</code>，第一个 <code>VNode</code> 是标签 <code>&lt;MyComponent /&gt;</code> 的描述，其次 <code>MyComponent</code> 组件本身也有要渲染的内容，这就是第二个 <code>VNode</code>。</p> <ul><li>第一个 <code>VNode</code> 用来描述 <code>&lt;MyComponent /&gt;</code> 标签：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
    tag<span class="token operator">:</span> MyComponent
  <span class="token punctuation">}</span>
  </code></pre></div><ul><li>第二个 <code>VNode</code> 是组件渲染内容的描述，即组件的 <code>render</code> 函数产出的 <code>VNode</code>：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
    <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token comment">/* .. */</span><span class="token punctuation">}</span> <span class="token comment">// 产出的 VNode</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>组件实例的 <code>$vnode</code> 属性值就是组件 <code>render</code> 函数产出的 <code>VNode</code>，这通过如下代码可以一目了然：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染，$vnode 的值就是组件 render 函数产出的 VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>而 <code>instance.$vnode.parentVNode</code> 的值就是用来描述组件(如：<code>&lt;MyComponent /&gt;</code>)标签的 <code>VNode</code>，我们只需在如上代码中添加一行代码即可实现：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染，$vnode 的值就是组件 render 函数产出的 VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// vnode 就是用来描述组件标签的 VNode</span>
    instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>parentVNode <span class="token operator">=</span> vnode
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>同时我们也可以在组件实例上添加 <code>$parentVNode</code> 属性，让其同样引用组件的标签描述：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染，$vnode 的值就是组件 render 函数产出的 VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// vnode 就是用来描述组件标签的 VNode</span>
    instance<span class="token punctuation">.</span>$parentVNode <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>parentVNode <span class="token operator">=</span> vnode
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>组件的实例为什么需要引用 <code>parentVNode</code> 呢？这是因为组件的事件监听器都在 <code>parentVNode</code> 上，如下模板所示：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handleClick<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  </code></pre></div><p>这段模板可以用如下 <code>VNode</code> 描述：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> parentVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
    tag<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">onclick</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>当你在组件中发射(<code>emit</code>)事件时，就需要去 <code>parentVNode</code> 中找到对应的事件监听器并执行：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 组件实例的 $emit 实现</span>
  <span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
    <span class="token function">$emit</span><span class="token punctuation">(</span><span class="token parameter">eventName<span class="token punctuation">,</span> <span class="token operator">...</span>payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 通过 parentVNode 拿到其 VNodeData</span>
      <span class="token keyword">const</span> parentData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parentVNode<span class="token punctuation">.</span>data
      <span class="token comment">// 执行 handler</span>
      parentData<span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">on</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>eventName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  
    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里就可以通过 this.$emit 发射事件</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>实际上，这就是事件的实现思路。由于 <code>$emit</code> 是框架层面的设计，所以我们在设计框架时可以提供一个最基本的组件，将框架层面的设计都归纳到该组件中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">$emit</span><span class="token punctuation">(</span><span class="token parameter">eventName<span class="token punctuation">,</span> <span class="token operator">...</span>payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 通过 parentVNode 拿到其 VNodeData</span>
      <span class="token keyword">const</span> parentData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parentVNode<span class="token punctuation">.</span>data
      <span class="token comment">// 执行 handler</span>
      parentData<span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">on</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>eventName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 其他......</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>这样框架的使用者在开发组件时，只需要继承我们的 <code>Component</code> 即可：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 用户的代码</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
  
  <span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 直接使用即可</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><h2 id="contextvnode"><a href="http://interview.poetries.top/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#contextvnode" class="header-anchor">#</a> contextVNode</h2> <p>我们已经知道了与一个组件相关的 <code>VNode</code> 有两个，一个是组件自身产出的 <code>VNode</code>，可以通过组件实例的 <code>instance.$vnode</code> 访问，另一个是当使用组件时用来描述组件标签的 <code>VNode</code>，我们可以通过组件实例的 <code>instance.$parentVNode</code> 访问，并且：</p> <div class="language-js extra-class"><pre class="language-js"><code>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>parentVNode <span class="token operator">===</span> instance<span class="token punctuation">.</span>$parentVNode
  </code></pre></div><p>那么 <code>contextVNode</code> 是什么呢？实际上<strong>子组件标签描述的 <code>VNode.contextVNode</code> 是父组件的标签描述 <code>VNode</code></strong>，或者说<strong>子组件实例的 <code>$parentVNode.contextVNode</code> 是父组件实例的 <code>$parentVNode</code></strong>，假设根组件渲染了 <code>Foo</code> 组件，而 <code>Foo</code> 组件又渲染 <code>Bar</code> 组件，此时就形成了一条父子链：<strong><code>Bar</code> 组件的父组件是 <code>Foo</code></strong>。</p> <p><img src="./组件设计_files/component-chain.ddddc28e.png" alt="" class="medium-zoom-image"></p> <p>为什么子组件的标签描述 <code>VNode</code> 需要引用父组件的标签描述 <code>VNode</code> 呢？这是因为一个组件的标签描述 <code>VNode</code> 中存储着该组件的实例对象，即 <code>VNode.children</code> 属性。还记得之前我们讲到过，对于组件来说，它的 <code>VNode.children</code> 属性会存储组件实例对象吗。这样通过这一层引用关系，子组件就知道它的父组件是谁，同时父组件也知道它有哪些子组件。</p> <p>语言描述会有些抽象，我们拿具体案例演示一下，假设我们的根组件有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 根组件模板 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Foo</span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>它对应的 <code>VNode</code> 如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> FooVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> Foo<span class="token punctuation">,</span> <span class="token comment">// Foo 指的是 class Foo {}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>接着 <code>Foo</code> 组件的模板如下，它渲染了 <code>Bar</code> 组件：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 组件 Foo 的模板 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Bar</span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>它对应的 <code>VNode</code> 如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> BarVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> Bar<span class="token punctuation">,</span> <span class="token comment">// Foo 指的是 class Bar {}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>我们使用 <code>mountComponent</code> 函数挂载 <code>FooVNode</code> 组件：</p> <div class="language-js extra-class"><div class="highlight-lines"><div class="highlighted">&nbsp;</div><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token function">mountComponent</span><span class="token punctuation">(</span>FooVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
  <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建 Foo 组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染，instance.$vnode 的值就是 BarVNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 使用 mountComponent 函数递归挂载 BarVNode</span>
    <span class="token function">mountComponent</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上代码所示，首先我们调用 <code>mountComponent</code> 函数挂载 <code>FooVNode</code>，会创建 <code>Foo</code> 组件实例，接着调用 <code>Foo</code> 组件实例的 <code>render</code> 函数得到 <code>Foo</code> 组件产出的 <code>VNode</code>，这其实就是 <code>BarVNode</code>，由于 <code>BarVNode</code> 的类型也是组件，所以我们会递归调用 <code>mountComponent</code> 挂载 <code>BarVNode</code>，最终 <code>mountComponent</code> 函数会执行两次。接下来我们为使用 <code>contextVNode</code> 完善上面的代码，看看如何来建立起父子链：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token function">mountComponent</span><span class="token punctuation">(</span>FooVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
  <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> contextVNode <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>contextVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> parentComponent <span class="token operator">=</span> contextVNode<span class="token punctuation">.</span>children
      instance<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parentComponent
      parentComponent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
      instance<span class="token punctuation">.</span>$root <span class="token operator">=</span> parentComponent<span class="token punctuation">.</span>$root
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      instance<span class="token punctuation">.</span>$root <span class="token operator">=</span> instance
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 渲染</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 使用 mountComponent 函数递归挂载</span>
    <span class="token function">mountComponent</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  
    vnode<span class="token punctuation">.</span>ref <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上高亮代码所示，我们为 <code>mountComponent</code> 函数添加了第三个参数 <code>contextVNode</code>，我们可以一下这个过程发生了什么：</p> <ul><li>1、初次调用 <code>mountComponent</code> 挂载 <code>FooVNode</code> 时，没有传递第三个参数，所以 <code>contextVNode = null</code>，这时说明当前挂载的组件就是根组件，所以我们让当前组件实例的 <code>$root</code> 属性值引用其自身。</li> <li>2、当递归调用 <code>mountComponent</code> 挂载 <code>BarVNode</code> 时，我们传递了第三个参数，并且点三个参数是 <code>FooVNode</code>。此时 <code>contextVNode = FooVNode</code>，我们通过 <code>contextVNode.children</code> 即可拿到 <code>Foo</code> 组件的实例，并把它赋值给 <code>Bar</code> 组件实例的 <code>$parent</code> 属性，同时把 <code>Bar</code> 组件实例添加到 <code>Foo</code> 组件实例的 <code>$children</code> 数组中，这样这条父子链就成功建立了。</li></ul> <p>实际上，除了组件实例间建立父子关系，组件的 <code>VNode</code> 间也可以建立父子关系，只需要增加一行代码即可：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token function">mountComponent</span><span class="token punctuation">(</span>FooVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  
  <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> contextVNode <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vnode<span class="token punctuation">.</span>contextVNode <span class="token operator">=</span> contextVNode
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>为什么要在组件的 <code>VNode</code> 上也建立这种父子联系呢？答案是在其他地方有用到，这么做就是为了在某些情况下少传递一些参数，直接通过 <code>VNode</code> 之间的联系找到我们想要的信息即可。另外在如上的演示中，我们省略了避开函数式组件的逻辑，因为函数式组件没有组件实例，所谓的父子关系只针对于有状态组件。实现逻辑很简单，就是通过一个 <code>while</code> 循环<strong>沿着父子链一直向上找到第一个非函数式组件，并把该组件的实例作为当前组件实例的 <code>$parent</code> 即可</strong>。</p> <h2 id="el"><a href="http://interview.poetries.top/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#el" class="header-anchor">#</a> el</h2> <p><code>VNode</code> 既然是真实DOM的描述，那么理所应当的，当它被渲染完真实DOM之后，我们需要将真实DOM对象的引用添加到 <code>VNode</code> 的 <code>el</code> 属性上。由于 <code>VNode</code> 具有不同的类型，不同类型的 <code>VNode</code> 其 <code>el</code> 属性所引用的真实DOM对象也不同，下图展示了所有 <code>VNode</code> 类型：</p> <p><img src="./组件设计_files/vnode-types2.b09b6339.png" alt="" class="medium-zoom-image"></p> <ul><li>1、<code>html/svg</code> 标签</li></ul> <p>其 <code>el</code> 属性值为真实DOM元素的引用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> div 元素的引用 <span class="token comment">// 如 document.createElement('div')</span>
  <span class="token punctuation">}</span>
  </code></pre></div><ul><li>2、组件</li></ul> <p>其 <code>el</code> 属性值为组件本身所渲染真实DOM的根元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    tag<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
    el<span class="token operator">:</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
  <span class="token punctuation">}</span>
  </code></pre></div><ul><li>3、纯文本</li></ul> <p>其 <code>el</code> 属性值为文本元素的引用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token string">'txt'</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> 文本元素的引用 <span class="token comment">// 如 document.createTextNode('txt')</span>
  <span class="token punctuation">}</span>
  </code></pre></div><ul><li>4、Fragment</li></ul> <p>其 <code>el</code> 属性值为片段中第一个DOM元素的引用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'h1'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'h2'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> h1 元素的引用而非 h2
  <span class="token punctuation">}</span>
  </code></pre></div><p>当然片段本身可能是一个空数组，即 <code>children</code> 属性值为 <code>[]</code>，此时代表该片段不渲染任何东西，但在框架设计中，我们会渲染一个空的文本节点占位，所以此时 <code>el</code> 属性值为该占位的空文本元素的引用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> 占位的空文本元素 <span class="token comment">// document.createTextNode('')</span>
  <span class="token punctuation">}</span>
  </code></pre></div><ul><li>5、Portal</li></ul> <p><code>Portal</code> 比较特殊，根据 <code>Portal</code> 寓意，其内容可以被渲染到任何地方，但其真正的挂载点会有一个空文本节点占位，所以 <code>Portal</code> 的 <code>VNode.el</code> 属性值引用的始终是这个空文本节点。当然这是 <code>vue3</code> 的设计，理论上将我们完全可以做到让 <code>el</code> 引用真正的挂载容器元素。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> 占位的空文本元素 <span class="token comment">// document.createTextNode('')</span>
  <span class="token punctuation">}</span>
  </code></pre></div></div>
  <!-- 设计vnode -->
  <div class="content__default"><p>上一章讲述了组件的本质，知道了一个组件的产出是 <code>VNode</code>，渲染器(<code>Renderer</code>)的渲染目标也是 <code>VNode</code>。可见 <code>VNode</code> 在框架设计的整个环节中都非常重要，甚至<strong>设计 <code>VNode</code> 本身就是在设计框架</strong>，<code>VNode</code> 的设计还会对后续算法的性能产生影响。本章我们就着手对 <code>VNode</code> 进行一定的设计，尝试用 <code>VNode</code> 描述各类渲染内容。</p> <h2 id="用-vnode-描述真实-dom"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#%E7%94%A8-vnode-%E6%8F%8F%E8%BF%B0%E7%9C%9F%E5%AE%9E-dom" class="header-anchor">#</a> 用 VNode 描述真实 DOM</h2> <p>一个 <code>html</code> 标签有它的名字、属性、事件、样式、子节点等诸多信息，这些内容都需要在 <code>VNode</code> 中体现，我们可以用如下对象来描述一个红色背景的正方形 <code>div</code> 元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      style<span class="token operator">:</span> <span class="token punctuation">{</span>
        width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
        height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
        backgroundColor<span class="token operator">:</span> <span class="token string">'red'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>我们使用 <code>tag</code> 属性来存储标签的名字，用 <code>data</code> 属性来存储该标签的附加信息，比如 <code>style</code>、<code>class</code>、事件等，通常我们把一个 <code>VNode</code> 对象的 <code>data</code> 属性称为 <code>VNodeData</code>。</p> <p>为了描述子节点，我们需要给 <code>VNode</code> 对象添加 <code>children</code> 属性，如下 <code>VNode</code> 对象用来描述一个有子节点的 <code>div</code> 元素：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      tag<span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>若有多个子节点，则可以把 <code>children</code> 属性设计为一个数组：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>除了标签元素之外，DOM 中还有文本节点，我们可以用如下 <code>VNode</code> 对象来描述一个文本节点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> textVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token string">'文本内容'</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，由于文本节点没有标签名字，所以它的 <code>tag</code> 属性值为 <code>null</code>。由于文本节点也无需用额外的 <code>VNodeData</code> 来描述附加属性，所以其 <code>data</code> 属性值也是 <code>null</code>。</p> <p>唯一需要注意的是我们使用 <code>children</code> 属性来存储一个文本节点的文本内容。有的同学可能会问：“可不可以新建一个属性 <code>text</code> 来存储文本内容呢？”</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> textVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    text<span class="token operator">:</span> <span class="token string">'文本内容'</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>这完全没有问题，这取决于你如何设计，但是<strong>尽可能的在保证语义能够说得通的情况下复用属性，会使 <code>VNode</code> 对象更加轻量</strong>，所以我们采取使用 <code>children</code> 属性来存储文本内容的方案。</p> <p>如下是一个以文本节点作为子节点的 <code>div</code> 标签的 <code>VNode</code> 对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token string">'文本内容'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><h2 id="用-vnode-描述抽象内容"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#%E7%94%A8-vnode-%E6%8F%8F%E8%BF%B0%E6%8A%BD%E8%B1%A1%E5%86%85%E5%AE%B9" class="header-anchor">#</a> 用 VNode 描述抽象内容</h2> <p>什么是抽象内容呢？组件就属于抽象内容，比如你在 模板 或 <code>jsx</code> 中使用了一个组件，如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>你的意图并不是要在页面中渲染一个名为 <code>MyComponent</code> 的标签元素，而是要渲染 <code>MyComponent</code> 组件所产出的内容。</p> <p>但我们仍然需要使用 <code>VNode</code> 来描述 <code>&lt;MyComponent/&gt;</code>，并给此类用来描述组件的 <code>VNode</code> 添加一个标识，以便在挂载的时候有办法区分一个 <code>VNode</code> 到底是普通的 <code>html</code> 标签还是组件。</p> <p>我们可以使用如下 <code>VNode</code> 对象来描述上面的模板：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      tag<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，用来描述组件的 <code>VNode</code> 其 <code>tag</code> 属性值引用的就是组件类(或函数)本身，而不是标签名称字符串。所以理论上：<strong>我们可以通过检查 <code>tag</code> 属性值是否是字符串来确定一个 <code>VNode</code> 是否是普通标签</strong>。</p> <p>除了组件之外，还有两种抽象的内容需要描述，即 <code>Fragment</code> 和 <code>Portal</code>。我们先来了解一下什么是 <code>Fragment</code> 以及它所解决的问题。</p> <p><code>Fragment</code> 的寓意是要渲染一个片段，假设我们有如下模板：</p> <div class="language-html extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Columns</span> <span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>组件 <code>Columns</code> 会返回多个 <code>&lt;td&gt;</code> 元素：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>大家思考一个问题，如上模板的 <code>VNode</code> 如何表示？如果模板中只有一个 <code>td</code> 标签，即只有一个根元素，这很容易表示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'td'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>但是模板中不仅仅只有一个 <code>td</code> 标签，而是有多个 <code>td</code> 标签，即多个根元素，这如何表示？此时我们就需要引入一个抽象元素，也就是我们要介绍的 <code>Fragment</code>。</p> <div class="language-js extra-class"><div class="highlight-lines"><div class="highlighted">&nbsp;</div><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> Fragment <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> fragmentVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// tag 属性值是一个唯一标识</span>
    tag<span class="token operator">:</span> Fragment<span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'td'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'td'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'td'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，我们把所有 <code>td</code> 标签都作为 <code>fragmentVNode</code> 的子节点，根元素并不是一个实实在在的真实 DOM，而是一个抽象的标识，即 <code>Fragment</code>。</p> <p>当渲染器在渲染 <code>VNode</code> 时，如果发现该 <code>VNode</code> 的类型是 <code>Fragment</code>，就只需要把该 <code>VNode</code> 的子节点渲染到页面。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在上面的代码中 <code>fragmentVNode.tag</code> 属性的值是一个通过 <code>Symbol</code> 创建的唯一标识，但实际上我们更倾向于给 <code>VNode</code> 对象添加一个 <code>flags</code> 属性，用来代表该 <code>VNode</code> 的类型，这在本章的后面会详细说明。</p></div> <p>再来看看 <code>Portal</code>，什么是 <code>Portal</code> 呢？</p> <p>一句话：它允许你把内容渲染到任何地方。其应用场景是，假设你要实现一个蒙层组件 <code>&lt;Overlay/&gt;</code>，要求是该组件的 <code>z-index</code> 的层级最高，这样无论在哪里使用都希望它能够遮住全部内容，你可能会将其用在任何你需要蒙层的地方。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Overlay</span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>如上，不幸的事情发生了，在没有 <code>Portal</code> 的情况下，上面的 <code>&lt;Overlay/&gt;</code> 组件的内容只能渲染到 <code>id="box"</code> 的 <code>div</code> 标签下，这就会导致蒙层的层级失效甚至布局都可能会受到影响。</p> <p>其实解决办法也很简单，假如 <code>&lt;Overlay/&gt;</code> 组件要渲染的内容不受 DOM 层级关系限制，即可以渲染到任何位置，该问题将迎刃而解。</p> <p>使用 <code>Portal</code> 可以这样编写 <code>&lt;Overlay/&gt;</code> 组件的模板：</p> <div class="language-html extra-class"><div class="highlight-lines"><br><div class="highlighted">&nbsp;</div><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Portal</span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#app-root<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>overlay<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Portal</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>其最终效果是，无论你在何处使用 <code>&lt;Overlay/&gt;</code> 组件，它都会把内容渲染到 <code>id="app-root"</code> 的元素下。由此可知，所谓 <code>Portal</code> 就是把子节点渲染到给定的目标，我们可以使用如下 <code>VNode</code> 对象来描述上面这段模板：</p> <div class="language-js extra-class"><div class="highlight-lines"><div class="highlighted">&nbsp;</div><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> Portal <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> portalVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> Portal<span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      target<span class="token operator">:</span> <span class="token string">'#app-root'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'overlay'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p><code>Portal</code> 类型的 <code>VNode</code> 与 <code>Fragment</code> 类型的 <code>VNode</code> 类似，都需要一个唯一的标识，来区分其类型，目的是告诉渲染器如何渲染该 <code>VNode</code>。</p> <h2 id="vnode-的种类"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#vnode-%E7%9A%84%E7%A7%8D%E7%B1%BB" class="header-anchor">#</a> VNode 的种类</h2> <p>当 <code>VNode</code> 描述不同的事物时，其属性的值也各不相同。比如一个 <code>VNode</code> 对象是 <code>html</code> 标签的描述，那么其 <code>tag</code> 属性值就是一个字符串，即标签的名字；如果是组件的描述，那么其 <code>tag</code> 属性值则引用组件类(或函数)本身；如果是文本节点的描述，那么其 <code>tag</code> 属性值为 <code>null</code>。</p> <p>最终我们发现，<strong>不同类型的 <code>VNode</code> 拥有不同的设计</strong>，这些差异积少成多，所以我们完全可以将它们分门别类。</p> <p>总的来说，我们可以把 <code>VNode</code> 分成五类，分别是：<strong><code>html/svg</code> 元素</strong>、<strong>组件</strong>、<strong>纯文本</strong>、<strong>Fragment</strong> 以及 <strong>Portal</strong>：</p> <p><img src="./设计vnode_files/vnode-types.7d99313d.png" alt="vnode types" class="medium-zoom-image"></p> <p>如上图所示，我们可以把组件细分为 <strong>有状态组件</strong> 和 <strong>函数式组件</strong>。同时有状态组件还可以细分为三部分：<strong>普通的有状态组件</strong>、<strong>需要被 keepAlive 的有状态组件</strong> 以及 <strong>已经被 keepAlive 的有状态组件</strong> 。</p> <p>但无论是普通的有状态组件还是 <code>keepAlive</code> 相关的有状态组件，它们都是<strong>有状态组件</strong>。所以我们在设计 <code>VNode</code> 时可以将它们作为一类看待。</p> <h2 id="使用-flags-作为-vnode-的标识"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#%E4%BD%BF%E7%94%A8-flags-%E4%BD%9C%E4%B8%BA-vnode-%E7%9A%84%E6%A0%87%E8%AF%86" class="header-anchor">#</a> 使用 flags 作为 VNode 的标识</h2> <p>既然 <code>VNode</code> 有类别之分，我们就有必要使用一个唯一的标识，来标明某一个 <code>VNode</code> 属于哪一类。同时给 <code>VNode</code> 添加 <code>flags</code> 也是 <code>Virtual DOM</code> 算法的优化手段之一。</p> <p>比如在 <code>Vue2</code> 中区分 <code>VNode</code> 是 <code>html</code> 元素还是组件亦或是普通文本，是这样做的：</p> <ul><li>1、拿到 <code>VNode</code> 后先尝试把它当作组件去处理，如果成功地创建了组件，那说明该 <code>VNode</code> 就是组件的 <code>VNode</code></li> <li>2、如果没能成功地创建组件，则检查 <code>vnode.tag</code> 是否有定义，如果有定义则当作普通标签处理</li> <li>3、如果 <code>vnode.tag</code> 没有定义则检查是否是注释节点</li> <li>4、如果不是注释节点，则会把它当作文本节点对待</li></ul> <p>以上这些判断都是在挂载(或<code>patch</code>)阶段进行的，换句话说，一个 <code>VNode</code> 到底描述的是什么是在挂载或 <code>patch</code> 的时候才知道的。这就带来了两个难题：<strong>无法从 <code>AOT</code> 的层面优化</strong>、<strong>开发者无法手动优化</strong>。</p> <p>为了解决这个问题，我们的思路是在 <code>VNode</code> 创建的时候就把该 <code>VNode</code> 的类型通过 <code>flags</code> 标明，这样在挂载或 <code>patch</code> 阶段通过 <code>flags</code> 可以直接避免掉很多消耗性能的判断，我们先提前感受一下渲染器的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// VNode 是普通标签</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// VNode 是组件</span>
    <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// VNode 是纯文本</span>
    <span class="token function">mountText</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上，采用了位运算，在一次挂载任务中如上判断很可能大量的进行，使用位运算在一定程度上再次拉升了运行时性能。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>实际上 <code>Vue3</code> 在 <code>Virtual DOM</code> 的优化上采用的就是 <a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener noreferrer">inferno<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的手段。具体如何做我们会在后面的章节介绍。</p></div> <p>这就意味着我们在设计 <code>VNode</code> 对象时，应该包含 <code>flags</code> 字段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// VNode 对象</span>
  <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> <span class="token operator">...</span>
  <span class="token punctuation">}</span>
  </code></pre></div><h2 id="枚举值-vnodeflags"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#%E6%9E%9A%E4%B8%BE%E5%80%BC-vnodeflags" class="header-anchor">#</a> 枚举值 VNodeFlags</h2> <p>那么一个 <code>VNode</code> 对象的 <code>flags</code> 可以是哪些值呢？那就看 <code>VNode</code> 有哪些种类就好了，每一个 <code>VNode</code> 种类我们都为其分配一个 <code>flags</code> 值即可，我们把它设计成一个枚举值并取名为 <code>VNodeFlags</code>，在 <code>javascript</code> 里就用一个对象来表示即可：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> VNodeFlags <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// html 标签</span>
    <span class="token constant">ELEMENT_HTML</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment">// SVG 标签</span>
    <span class="token constant">ELEMENT_SVG</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
  
    <span class="token comment">// 普通有状态组件</span>
    <span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token comment">// 需要被keepAlive的有状态组件</span>
    <span class="token constant">COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token comment">// 已经被keepAlive的有状态组件</span>
    <span class="token constant">COMPONENT_STATEFUL_KEPT_ALIVE</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">,</span>
    <span class="token comment">// 函数式组件</span>
    <span class="token constant">COMPONENT_FUNCTIONAL</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">,</span>
  
    <span class="token comment">// 纯文本</span>
    <span class="token constant">TEXT</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">,</span>
    <span class="token comment">// Fragment</span>
    <span class="token constant">FRAGMENT</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">,</span>
    <span class="token comment">// Portal</span>
    <span class="token constant">PORTAL</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上这些枚举属性所代表的意义能够与下面的图片一一对应上：</p> <p><img src="./设计vnode_files/vnode-types.7d99313d.png" alt="vnode types" class="medium-zoom-image"></p> <p>我们注意到，这些枚举属性的值基本都是通过将十进制数字 <code>1</code> 左移不同的位数得来的。根据这些基本的枚举属性值，我们还可以派生出额外的三个标识：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// html 和 svg 都是标签元素，可以用 ELEMENT 表示</span>
  VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span> <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span> <span class="token operator">|</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
  <span class="token comment">// 普通有状态组件、需要被keepAlive的有状态组件、已经被keepAlice的有状态组件 都是“有状态组件”，统一用 COMPONENT_STATEFUL 表示</span>
  VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL</span> <span class="token operator">=</span>
    VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span> <span class="token operator">|</span>
    VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE</span> <span class="token operator">|</span>
    VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_KEPT_ALIVE</span>
  <span class="token comment">// 有状态组件 和  函数式组件都是“组件”，用 COMPONENT 表示</span>
  VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span> <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL</span> <span class="token operator">|</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_FUNCTIONAL</span>
  </code></pre></div><p>其中 <code>VNodeFlags.ELEMENT</code>、<code>VNodeFlags.COMPONENT_STATEFUL</code> 以及 <code>VNodeFlags.COMPONENT</code> 是由基本标识通过<code>按位或(|)</code>运算得到的，这三个派生值将用于辅助判断。</p> <p>有了这些 <code>flags</code> 之后，我们在创建 <code>VNode</code> 的时候就可以预先为其打上 <code>flags</code>，以标明该 <code>VNode</code> 的类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// html 元素节点</span>
  <span class="token keyword">const</span> htmlVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// svg 元素节点</span>
  <span class="token keyword">const</span> svgVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'svg'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 函数式组件</span>
  <span class="token keyword">const</span> functionalComponentVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_FUNCTIONAL</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> MyFunctionalComponent
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 普通的有状态组件</span>
  <span class="token keyword">const</span> normalComponentVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> MyStatefulComponent
  <span class="token punctuation">}</span>
  
  <span class="token comment">// Fragment</span>
  <span class="token keyword">const</span> fragmentVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">,</span>
    <span class="token comment">// 注意，由于 flags 的存在，我们已经不需要使用 tag 属性来存储唯一标识</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// Portal</span>
  <span class="token keyword">const</span> portalVnode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">,</span>
    <span class="token comment">// 注意，由于 flags 的存在，我们已经不需要使用 tag 属性来存储唯一标识，tag 属性用来存储 Portal 的 target</span>
    tag<span class="token operator">:</span> target
  <span class="token punctuation">}</span>
  </code></pre></div><p>如下是利用 <code>VNodeFlags</code> 判断 <code>VNode</code> 类型的例子，比如判断一个 <code>VNode</code> 是否是组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用按位与(&amp;)运算</span>
  functionalComponentVnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span> <span class="token comment">// 真</span>
  normalComponentVnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span> <span class="token comment">// 真</span>
  htmlVnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span> <span class="token comment">// 假</span>
  </code></pre></div><p>熟悉位运算的话，理解起来很简单。这实际上是多种位运算技巧中的一个小技巧。我们可以列一个表格：</p> <table><thead><tr><th>VNodeFlags</th> <th>左移运算</th> <th>32 位的 bit 序列(出于简略，只用 9 位表示)</th></tr></thead> <tbody><tr><td>ELEMENT_HTML</td> <td>无</td> <td>00000000<code>1</code></td></tr> <tr><td>ELEMENT_SVG</td> <td>1 &lt;&lt; 1</td> <td>0000000<code>1</code>0</td></tr> <tr><td>COMPONENT_STATEFUL_NORMAL</td> <td>1 &lt;&lt; 2</td> <td>000000<code>1</code>00</td></tr> <tr><td>COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE</td> <td>1 &lt;&lt; 3</td> <td>00000<code>1</code>000</td></tr> <tr><td>COMPONENT_STATEFUL_KEPT_ALIVE</td> <td>1 &lt;&lt; 4</td> <td>0000<code>1</code>0000</td></tr> <tr><td>COMPONENT_FUNCTIONAL</td> <td>1 &lt;&lt; 5</td> <td>000<code>1</code>00000</td></tr> <tr><td>TEXT</td> <td>1 &lt;&lt; 6</td> <td>00<code>1</code>000000</td></tr> <tr><td>FRAGMENT</td> <td>1 &lt;&lt; 7</td> <td>0<code>1</code>0000000</td></tr> <tr><td>PORTAL</td> <td>1 &lt;&lt; 8</td> <td><code>1</code>00000000</td></tr></tbody></table> <p>根据上表展示的基本 <code>flags</code> 值可以很容易地得出下表：</p> <table><thead><tr><th>VNodeFlags</th> <th>32 位的比特序列(出于简略，只用 9 位表示)</th></tr></thead> <tbody><tr><td>ELEMENT</td> <td>0000000<code>1</code> <code>1</code></td></tr> <tr><td>COMPONENT_STATEFUL</td> <td>0000<code>1</code> <code>1</code> <code>1</code>00</td></tr> <tr><td>COMPONENT</td> <td>000<code>1</code> <code>1</code> <code>1</code> <code>1</code>00</td></tr></tbody></table> <p>所以很自然的，只有 <code>VNodeFlags.ELEMENT_HTML</code> 和 <code>VNodeFlags.ELEMENT_SVG</code> 与 <code>VNodeFlags.ELEMENT</code> 进行按位与(<code>&amp;</code>)运算才会得到非零值，即为真。</p> <h2 id="children-和-childrenflags"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#children-%E5%92%8C-childrenflags" class="header-anchor">#</a> children 和 ChildrenFlags</h2> <p>DOM 是一棵树早已家至人说，既然 <code>VNode</code> 是真实渲染内容的描述，那么它必然也是一棵树。在之前的设计中，我们给 <code>VNode</code> 定义了 <code>children</code> 属性，用来存储子 <code>VNode</code>。大家思考一下，一个标签的子节点会有几种情况？</p> <p>总的来说无非有以下几种：</p> <ul><li>没有子节点</li> <li>只有一个子节点</li> <li>多个子节点
  <ul><li>有 <code>key</code></li> <li>无 <code>key</code></li></ul></li> <li>不知道子节点的情况</li></ul> <p>我们可以用一个叫做 <code>ChildrenFlags</code> 的对象来枚举出以上这些情况，作为一个 <code>VNode</code> 的子节点的类型标识：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> ChildrenFlags <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未知的 children 类型</span>
    <span class="token constant">UNKNOWN_CHILDREN</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token comment">// 没有 children</span>
    <span class="token constant">NO_CHILDREN</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment">// children 是单个 VNode</span>
    <span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
  
    <span class="token comment">// children 是多个拥有 key 的 VNode</span>
    <span class="token constant">KEYED_VNODES</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token comment">// children 是多个没有 key 的 VNode</span>
    <span class="token constant">NONE_KEYED_VNODES</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>由于 <code>ChildrenFlags.KEYED_VNODES</code> 和 <code>ChildrenFlags.NONE_KEYED_VNODES</code> 都属于多个 <code>VNode</code>，所以我们可以派生出一个“多节点”标识，以方便程序的判断：</p> <div class="language-js extra-class"><pre class="language-js"><code>ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span> <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">KEYED_VNODES</span> <span class="token operator">|</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NONE_KEYED_VNODES</span>
  </code></pre></div><p>这样我们判断一个 <code>VNode</code> 的子节点是否是多个子节点就变得容易多了：</p> <div class="language-js extra-class"><pre class="language-js"><code>someVNode<span class="token punctuation">.</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span>
  </code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>为什么 <code>children</code> 也需要标识呢？原因只有一个：<strong>为了优化</strong>。在后面讲解 <code>diff</code> 算法的章节中你将会意识到，这些信息是至关重要的。</p></div> <p>在一个 <code>VNode</code> 对象中，我们使用 <code>flags</code> 属性来存储该 <code>VNode</code> 的类型，类似的，我们将使用 <code>childFlags</code> 来存储子节点的类型，我们来举一些实际的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 没有子节点的 div 标签</span>
  <span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 文本节点的 childFlags 始终都是 NO_CHILDREN</span>
  <span class="token keyword">const</span> textVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token string">'我是文本'</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 拥有多个使用了key的 li 标签作为子节点的 ul 标签</span>
  <span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">KEYED_VNODES</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        key<span class="token operator">:</span> <span class="token number">0</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        tag<span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        key<span class="token operator">:</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 只有一个子节点的 Fragment</span>
  <span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>但并非所有类型的 <code>VNode</code> 的 <code>children</code> 属性都是用来存储子 <code>VNode</code>，比如组件的“子 <code>VNode</code>”其实不应该作为 <code>children</code> 而是应该作为 <code>slots</code>，所以我们会定义 <code>VNode.slots</code> 属性来存储这些子 <code>VNode</code>，不过目前来说我们还不需要深入探讨有关插槽的知识。</p> <h2 id="vnodedata"><a href="http://interview.poetries.top/principle-docs/vue/04-%E8%AE%BE%E8%AE%A1%20VNode.html#vnodedata" class="header-anchor">#</a> VNodeData</h2> <p>前面提到过，<code>VNodeData</code> 指的是 <code>VNode</code> 的 <code>data</code> 属性，它是一个对象：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token punctuation">{</span>
    flags<span class="token operator">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>
    <span class="token comment">// VNodeData</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p><code>VNodeData</code> 顾名思义，它就是 <code>VNode</code> 数据，用于对 <code>VNode</code> 进行描述。举个例子，假如一个 <code>VNode</code> 的类型是 <code>html</code> 标签，则 <code>VNodeData</code> 中可以包含 <code>class</code>、<code>style</code> 以及一些事件，这样渲染器在渲染此 <code>VNode</code> 时，才知道这个标签的背景颜色、字体大小以及监听了哪些事件等等。所以从设计角度来讲，任何可以对 <code>VNode</code> 进行描述的内容，我们都可以将其存放到 <code>VNodeData</code> 对象中，如：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'class-a'</span><span class="token punctuation">,</span> <span class="token string">'active'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      style<span class="token operator">:</span> <span class="token punctuation">{</span>
        background<span class="token operator">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>
        color<span class="token operator">:</span> <span class="token string">'green'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment">// 其他数据...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如果 <code>VNode</code> 的类型是组件，那么我们同样可以用 <code>VNodeData</code> 来描述组件，比如组件的事件、组件的 <code>props</code> 等等，假设有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">@some-event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handler<span class="token punctuation">"</span></span> <span class="token attr-name">prop-a</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  </code></pre></div><p>则其对应的 <code>VNodeData</code> 应为：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token punctuation">{</span>
    flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL</span><span class="token punctuation">,</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      on<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string">'some-event'</span><span class="token operator">:</span> handler
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      propA<span class="token operator">:</span> <span class="token string">'1'</span>
      <span class="token comment">// 其他数据...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>当然了，只要能够正确地对 <code>VNode</code> 进行描述，具体的数据结构你可以随意设计。我们暂且不限制 <code>VNodeData</code> 的固定格式。</p> <p>在后续章节中，我们会根据需求逐渐地完善 <code>VNodeData</code> 的设计。</p> <p>至此，我们已经对 <code>VNode</code> 完成了一定的设计，目前为止我们所设计的 <code>VNode</code> 对象如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span>
    <span class="token comment">// _isVNode 属性在上文中没有提到，它是一个始终为 true 的值，有了它，我们就可以判断一个对象是否是 VNode 对象</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token comment">// el 属性在上文中也没有提到，当一个 VNode 被渲染为真实 DOM 之后，el 属性的值会引用该真实DOM</span>
    el<span class="token operator">:</span> Element <span class="token operator">|</span> <span class="token keyword">null</span>
    flags<span class="token operator">:</span> VNodeFlags
    tag<span class="token operator">:</span> string <span class="token operator">|</span> FunctionalComponent <span class="token operator">|</span> ComponentClass <span class="token operator">|</span> <span class="token keyword">null</span>
    data<span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">null</span>
    children<span class="token operator">:</span> VNodeChildren
    childFlags<span class="token operator">:</span> ChildrenFlags
  <span class="token punctuation">}</span>
  </code></pre></div><p>其中 <code>_isVNode</code> 属性和 <code>el</code> 属性在上文中没有提到，<code>_isVNode</code> 属性是一个始终为 <code>true</code> 的值，有了它，我们就可以判断一个对象是否是 <code>VNode</code> 对象。<code>el</code> 属性的值在 <code>VNode</code> 被渲染为真实 DOM 之前一直都是 <code>null</code>，当 <code>VNode</code> 被渲染为真实 DOM 之后，<code>el</code> 属性的值会引用该真实 DOM。</p> <p>实际上，如果你看过 <code>Vue3</code> 的源码，你会发现在源码中一个 <code>VNode</code> 对象除了包含本节我们所讲到的这些属性之外，还包含诸如 <code>handle</code> 和 <code>contextVNode</code>、<code>parentVNode</code>、<code>key</code>、<code>ref</code>、<code>slots</code> 等其他额外的属性。</p> <p>我们之所以没有在本章中包含这些内容，是因为目前来讲，我们根本不需要这些属性，比如 <code>handle</code> 属性仅用于函数式组件，所以我们会在函数式组件原理相关的章节再讲。</p></div> 
  <!-- vnode的h函数 -->
  <div class="content__default"><blockquote><p>自从有了 <code>VNode</code> ，开发页面的方式就变成了书写 <code>VNode</code>，但如果日常开发中需要手写 <code>VNode</code> ，那绝对是反人类的，在“组件的本质”一章中我们使用了 <code>snabbdom</code> 的 <code>h</code> 函数来辅助讲解一些小例子，<code>h</code> 函数作为创建 <code>VNode</code> 对象的函数封装，在一定程度上改善了这个问题，但却没有解决本质问题，这也是为什么我们需要模板或 <code>jsx</code> 的原因。但 <code>h</code> 函数依然很重要，因为无论是模板还是 <code>jsx</code> 都需要经过编译，那么是直接编译成 <code>VNode</code> 树好呢？还是编译成由 <code>h</code> 函数组成的调用集合好呢？这个其实很难说，但可以肯定的一点是，我们将可<strong>公用、灵活、复杂的逻辑封装成函数，并交给运行时</strong>，这能够大大降低编译器的书写难度，甚至经过编译器生成的代码也具有一定的可读性，而 <code>h</code> 函数就是众多运行时函数中的一个。</p></blockquote> <h2 id="在vnode创建时确定其类型-flags"><a href="http://interview.poetries.top/principle-docs/vue/05-%E8%BE%85%E5%8A%A9%E5%88%9B%E5%BB%BA%20VNode%20%E7%9A%84%20h%20%E5%87%BD%E6%95%B0.html#%E5%9C%A8vnode%E5%88%9B%E5%BB%BA%E6%97%B6%E7%A1%AE%E5%AE%9A%E5%85%B6%E7%B1%BB%E5%9E%8B-flags" class="header-anchor">#</a> 在VNode创建时确定其类型 - flags</h2> <p>一个最简单的 <code>h</code> 函数如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>这个 <code>h</code> 函数只能用来创建一个空的 <code>&lt;h1&gt;&lt;/h1&gt;</code> 标签，可以说没有任何意义。为了让 <code>h</code> 函数更加灵活，我们可以增加一些参数，问题是哪些内容应该提取到参数中呢？如果提取的参数多了，就会导致函数的使用不便，如果提取的参数少了又会导致函数的功能不足，所以这也是一个探索的过程。实际上只需要把 <code>tag</code>、<code>data</code> 和 <code>children</code> 提取为参数即可：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>我们来看看为什么三个参数就能满足需求，对于 <code>_isVNode</code> 属性，它的值始终都为 <code>true</code>，所以不需要提取到参数中。对于 <code>flags</code> 属性，我们可以通过检查 <code>tag</code> 属性值的特征来确定该 <code>VNode</code> 的 <code>flags</code> 属性值，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> tag <span class="token operator">===</span> <span class="token string">'svg'</span> <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span> <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上代码所示，如果 <code>tag</code> 是字符串则可以确定该 <code>VNode</code> 是标签元素，再次通过 <code>tag === 'svg'</code> 进一步判断是否是 <code>SVG</code> 标签，从而确定了该 <code>VNode</code> 的类型。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>请注意区分下文中出现的 <code>tag</code>，有时指的是 <code>VNode</code> 对象的 <code>tag</code> 属性，有时指的是 <code>h</code> 函数的第一个参数。</p></div> <p>对于 <code>Fragment</code> 类型的 <strong><code>VNode</code></strong>，它的 <code>tag</code> 属性值为 <code>null</code>，但是纯文本类型的 <code>VNode</code> 其 <code>tag</code> 属性值也是 <code>null</code>，所以为了区分，我们可以增加一个唯一的标识，当 <code>h</code> 函数的第一个参数(<code>tag</code>)的值等于该标识的时候，则意味着创建的是 <code>Fragment</code> 类型的 <code>VNode</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><div class="highlighted">&nbsp;</div><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token comment">// 唯一标识</span>
  <span class="token keyword">export</span> <span class="token keyword">const</span> Fragment <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> tag <span class="token operator">===</span> <span class="token string">'svg'</span> <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span> <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>这时我们可以像如下这样调用 <code>h</code> 函数创建 <code>Fragment</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> Fragment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
  
  <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children<span class="token punctuation">)</span>
  </code></pre></div><p>类似的，对于<code>Portal</code> 类型的 <strong><code>VNode</code></strong>，它的 <code>tag</code> 属性值也可以是字符串，这就会与普通标签元素类型的 <code>VNode</code> 冲突，导致无法区分一个 <code>VNode</code> 到底是普通标签元素还是 <code>Portal</code>，所以我们参考 <code>Fragment</code> 的实现方式，增加一个 <code>Portal</code> 标识：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> Fragment <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">export</span> <span class="token keyword">const</span> Portal <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> tag <span class="token operator">===</span> <span class="token string">'svg'</span> <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span> <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> Portal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span>
      tag <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>target
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>这里需要注意的一点是，类型为 <code>Portal</code> 的 <code>VNode</code>，其 <code>tag</code> 属性值存储的是 <code>Portal</code> 挂载的目标，即 <code>target</code>。通常模板在经过编译后，我们把 <code>target</code> 数据存储在 <code>VNodeData</code> 中，所以我们看到如上代码中包含 <code>tag = data &amp;&amp; data.target</code>。</p> <p>如果一个 <code>VNode</code> 对象的 <code>tag</code> 属性值不满足以上全部条件，那只有一种可能了，即该 <code>VNode</code> 是组件。有的同学可能会说，也有可能是文本节点啊，没错，但是我们很少会用 <code>h</code> 函数去创建一个文本节点，而是单纯的使用字符串，然后在内部实现中检测到该字符串的寓意是文本节点的时候会为其自动创建一个纯文本的 <code>VNode</code> 对象，例如：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span>
    <span class="token string">'div'</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      style<span class="token operator">:</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">'我是文本'</span>
  <span class="token punctuation">)</span>
  </code></pre></div><p>如上代码所示，<code>h</code> 函数的第三个参数 <code>children</code> 的值是一段文本字符串，这时在 <code>h</code> 函数内部会为这段文本字符串创建一个与之相符的纯文本 <code>VNode</code> 对象。</p> <p>我们回过头来，继续讨论当一个 <code>VNode</code> 是组件时，如何根据 <code>tag</code> 属性确定该 <code>VNode</code> 对象的 <code>flags</code> 值，很简单如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token comment">// 省略...</span>
  <span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> tag <span class="token operator">===</span> <span class="token string">'svg'</span> <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span> <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> Portal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flags <span class="token operator">=</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span>
      tag <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>target
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 兼容 Vue2 的对象式组件</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flags <span class="token operator">=</span> tag<span class="token punctuation">.</span>functional
          <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_FUNCTIONAL</span>       <span class="token comment">// 函数式组件</span>
          <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span>  <span class="token comment">// 有状态组件</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Vue3 的类组件</span>
        flags <span class="token operator">=</span> tag<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> tag<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>render
          <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span>  <span class="token comment">// 有状态组件</span>
          <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_FUNCTIONAL</span>       <span class="token comment">// 函数式组件</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>在 <code>Vue2</code> 中用一个对象作为组件的描述，而在 <code>Vue3</code> 中，有状态组件是一个继承了基类的类。所以如果是 <code>Vue2</code> 的对象式组件，我们通过检查该对象的 <code>functional</code> 属性的真假来判断该组件是否是函数式组件。在 <code>Vue3</code> 中，因为有状态组件会继承基类，所以通过原型链判断其原型中是否有 <code>render</code> 函数的定义来确定该组件是否是有状态组件。</p> <p>一旦确定了一个 <code>VNode</code> 的类型，那么 <code>h</code> 函数就可返回带有正确类型的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">// 省略用来确定 flags 的代码</span>
  
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      flags<span class="token punctuation">,</span>
      <span class="token comment">// 其他属性...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><h2 id="在vnode创建时确定其children的类型"><a href="http://interview.poetries.top/principle-docs/vue/05-%E8%BE%85%E5%8A%A9%E5%88%9B%E5%BB%BA%20VNode%20%E7%9A%84%20h%20%E5%87%BD%E6%95%B0.html#%E5%9C%A8vnode%E5%88%9B%E5%BB%BA%E6%97%B6%E7%A1%AE%E5%AE%9A%E5%85%B6children%E7%9A%84%E7%B1%BB%E5%9E%8B" class="header-anchor">#</a> 在VNode创建时确定其children的类型</h2> <p>上文通过 <strong>检测 <code>tag</code> 属性值</strong> 来确定一个 <code>VNode</code> 对象的 <code>flags</code> 属性值。类似地，可以通过 <strong>检测 <code>children</code></strong> 来确定 <code>childFlags</code> 的值。根据 <code>h</code> 函数的调用方式可以很容易地确定参数 <code>children</code> 包含哪些值：</p> <ul><li>1、<code>children</code> 是一个数组：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span>
  </code></pre></div><ul><li>2、<code>children</code> 是一个 <code>VNode</code> 对象：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  </code></pre></div><ul><li>3、没有 <code>children</code>：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
  </code></pre></div><ul><li>4、<code>children</code> 是一个普通文本字符串：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是文本'</span><span class="token punctuation">)</span>
  </code></pre></div><p>以上是四种常见的 <code>h</code> 函数的调用方式，根据这四种调用方式中 <code>children</code> 的不同形式即可确定一个 <code>VNode</code> 对象的 <code>childFlags</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略用于确定 flags 相关的代码</span>
  
    <span class="token keyword">let</span> childFlags <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> length <span class="token punctuation">}</span> <span class="token operator">=</span> children
      <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 没有 children</span>
        childFlags <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 单个子节点</span>
        childFlags <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span>
        children <span class="token operator">=</span> children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 多个子节点，且子节点使用key</span>
        childFlags <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">KEYED_VNODES</span>
        children <span class="token operator">=</span> <span class="token function">normalizeVNodes</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 没有子节点</span>
      childFlags <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">.</span>_isVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 单个子节点</span>
      childFlags <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 其他情况都作为文本节点处理，即单个子节点，会调用 createTextVNode 创建纯文本类型的 VNode</span>
      childFlags <span class="token operator">=</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span>
      children <span class="token operator">=</span> <span class="token function">createTextVNode</span><span class="token punctuation">(</span>children <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>首先，如果 <code>children</code> 是数组，则根据数组的长度来判断 <code>children</code> 的类型到底是 <code>ChildrenFlags.NO_CHILDREN</code>、<code>ChildrenFlags.SINGLE_VNODE</code> 还是 <code>ChildrenFlags.KEYED_VNODES</code>。这里大家可能会有疑问：“为什么多个子节点时会直接被当做使用了 <code>key</code> 的子节点？”，这是因为 <code>key</code> 是可以人为创造的，如下是 <code>normalizeVNodes</code> 函数的简化：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">normalizeVNodes</span><span class="token punctuation">(</span><span class="token parameter">children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newChildren <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 遍历 children</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果原来的 VNode 没有key，则使用竖线(|)与该VNode在数组中的索引拼接而成的字符串作为key</span>
        child<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token string">'|'</span> <span class="token operator">+</span> i
      <span class="token punctuation">}</span>
      newChildren<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回新的children，此时 children 的类型就是 ChildrenFlags.KEYED_VNODES</span>
    <span class="token keyword">return</span> newChildren
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上， <code>normalizeVNodes</code> 函数接收 <code>children</code> 数组作为参数，并遍历该数组，对于数组中没有 <code>key</code> 的 <code>VNode</code> 对象，为其添加一个由竖线(<code>|</code>)与该 <code>VNode</code> 在数组中的索引拼接而成的字符串作为该 <code>VNode</code> 的 <code>key</code>。</p> <p>如果 <code>children</code> 不是数组，则判断 <code>children</code> 是否为 <code>null/undefined</code>，条件为真则说明没有子节点，所以 <code>childFlags</code> 的值为 <code>ChildrenFlags.NO_CHILDREN</code>。如果 <code>children</code> 不为 <code>null/undefined</code>，并且 <code>children._isVNode</code> 为真，则说明 <code>children</code> 就是单个 <code>VNode</code> 对象，即单个子节点 <code>ChildrenFlags.SINGLE_VNODE</code>。</p> <p>最后，如果 <code>children</code> 不满足以上任何条件，则会把 <code>children</code> 作为纯文本节点的文本内容处理，这时会使用 <code>createTextVNode</code> 函数创建一个纯文本类型的 <code>VNode</code>，<code>createTextVNode</code> 函数接收一个字符串作为参数，创建一个与之相符的纯文本类型的 <code>VNode</code>，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createTextVNode</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token comment">// flags 是 VNodeFlags.TEXT</span>
      flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      <span class="token comment">// 纯文本类型的 VNode，其 children 属性存储的是与之相符的文本内容</span>
      children<span class="token operator">:</span> text<span class="token punctuation">,</span>
      <span class="token comment">// 文本节点没有子节点</span>
      childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p><strong>这里再次强调！！！</strong> ，以上用于确定 <code>childFlags</code> 的代码仅限于非组件类型的 <code>VNode</code>，因为对于组件类型的 <code>VNode</code> 来说，它并没有子节点，所有子节点都应该作为 <code>slots</code> 存在，所以如果使用 <code>h</code> 函数创建一个组件类型的 <code>VNode</code>，那么我们应该把 <code>children</code> 的内容转化为 <code>slots</code>，然后再把 <code>children</code> 置为 <code>null</code>，这些内容我们会在合适的章节讲解。</p> <h2 id="使用-h-函数创建-vnode"><a href="http://interview.poetries.top/principle-docs/vue/05-%E8%BE%85%E5%8A%A9%E5%88%9B%E5%BB%BA%20VNode%20%E7%9A%84%20h%20%E5%87%BD%E6%95%B0.html#%E4%BD%BF%E7%94%A8-h-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA-vnode" class="header-anchor">#</a> 使用 h 函数创建 VNode</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>本章关于 <code>h</code> 函数的完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/6x2nvmmxn3" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/6x2nvmmxn3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>假设有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>用 <code>h</code> 函数来创建与之相符的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  </code></pre></div><p>得到的 <code>VNode</code> 对象如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.ELEMENT_HTML</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.ELEMENT_HTML</span>
      tag<span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.NO_CHILDREN</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.SINGLE_VNODE</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><blockquote><p>---- 我是一条分割线(^o^)/~ ---</p></blockquote> <p>假设有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>我是文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>用 <code>h</code> 函数来创建与之相符的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementWithTextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是文本'</span><span class="token punctuation">)</span>
  </code></pre></div><p>得到的 <code>VNode</code> 对象如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementWithTextVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.ELEMENT_HTML</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> <span class="token number">64</span><span class="token punctuation">,</span>  <span class="token comment">// VNodeFlags.TEXT</span>
      tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token string">'我是文本'</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.NO_CHILDREN</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.SINGLE_VNODE</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><blockquote><p>---- 我是一条分割线(^o^)/~ ---</p></blockquote> <p>假设有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>我们在之前的章节中曾经遇到过此模板，我们知道这种模板拥有多个根节点，它是一个 <code>Fragment</code>，我们可以像如下这样使用 <code>h</code> 函数来创建 <code>Fragment</code> 类型的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> Fragment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./h'</span>
  <span class="token keyword">const</span> fragmentVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'td'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'td'</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span>
  </code></pre></div><p>得到的 <code>VNode</code> 对象如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fragmentVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.FRAGMENT</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.ELEMENT_HTML</span>
        tag<span class="token operator">:</span> <span class="token string">'td'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment">// ChildrenFlags.NO_CHILDREN</span>
        key<span class="token operator">:</span> <span class="token string">'|0'</span><span class="token punctuation">,</span> <span class="token comment">// 自动生成的 key</span>
        el<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.ELEMENT_HTML</span>
        tag<span class="token operator">:</span> <span class="token string">'td'</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment">// ChildrenFlags.NO_CHILDREN</span>
        key<span class="token operator">:</span> <span class="token string">'|1'</span><span class="token punctuation">,</span> <span class="token comment">// 自动生成的 key</span>
        el<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.KEYED_VNODES</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>观察如上 <code>VNode</code> 对象可以发现，<code>children</code> 数组中的每一个 <code>VNode</code> 都自动添加了 <code>key</code> 属性。</p> <blockquote><p>---- 我是一条分割线(^o^)/~ ---</p></blockquote> <p>假设有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Portal</span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#box<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Portal</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>这段模板是一个 <code>Portal</code>，并且会将其内容渲染到 <code>id="box"</code> 的元素下。我们可以像如下这样使用 <code>h</code> 函数来创建 <code>Portal</code> 类型的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> Portal <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./h'</span>
  <span class="token keyword">const</span> portalVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
    Portal<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      target<span class="token operator">:</span> <span class="token string">'#box'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  </code></pre></div><p>得到的 <code>VNode</code> 对象如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> portalVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.PORTAL</span>
    tag<span class="token operator">:</span> <span class="token string">'#box'</span><span class="token punctuation">,</span>  <span class="token comment">// 类型为 Portal 的 VNode，其 tag 属性值等于 data.target</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#box'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.ELEMENT_HTML</span>
      tag<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.NO_CHILDREN</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.SINGLE_VNODE</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>如上 <code>VNode</code> 对象所示，类型为 <code>Portal</code> 的 <code>VNode</code> 其 <code>tag</code> 属性值等于 <code>data.target</code>。</p> <blockquote><p>---- 我是一条分割线(^o^)/~ ---</p></blockquote> <p>假设有如下模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyFunctionalComponent</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MyFunctionalComponent</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  </code></pre></div><p>这段模板中包含了一个函数式组件，并为该组件提供了一个空的 <code>div</code> 标签作为默认的插槽内容，我们尝试用 <code>h</code> 函数创建与该模板相符的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 一个函数式组件</span>
  <span class="token keyword">function</span> <span class="token function">MyFunctionalComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 传递给 h 函数的第一个参数就是组件函数本身</span>
  <span class="token keyword">const</span> functionalComponentVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComponent<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  </code></pre></div><p>来看一下我们最终得到的 <code>VNode</code> 对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> functionalComponentVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>  <span class="token comment">// VNodeFlags.COMPONENT_FUNCTIONAL</span>
    tag<span class="token operator">:</span> MyFunctionalComponent<span class="token punctuation">,</span> <span class="token comment">// tag 属性值引用组件函数</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// ChildrenFlags.SINGLE_VNODE</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>大家观察如上 <code>VNode</code> 对象，其中 <code>tag</code> 属性的值就是组件函数本身，另外 <code>functionalComponentVNode.children</code> 的值就是作为默认插槽的空 <code>div</code> 标签的 <code>VNode</code>，我们暂且这样设计，因为它不会影响我们对渲染器的理解，等到讲解插槽的章节时再来说明：为什么我们不使用 <code>children</code> 属性来存储插槽内容，以及我们应该如何使用 <code>VNode</code> 来描述插槽。</p> <blockquote><p>---- 我是一条分割线(^o^)/~ ---</p></blockquote> <p>我们再来使用 <code>h</code> 函数创建一个有状态组件的 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 有状态组件</span>
  <span class="token keyword">class</span> <span class="token class-name">MyStatefulComponent</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">const</span> statefulComponentVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyStatefulComponent<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  </code></pre></div><p>我们将得到如下 <code>VNode</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> statefulComponentVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>  <span class="token comment">// VNodeFlags.COMPONENT_FUNCTIONAL</span>
    tag<span class="token operator">:</span> MyStatefulComponent<span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>观察 <code>statefulComponentVNode.flags</code> 属性的值，我们明明使用 <code>h</code> 创建的是有状态组件的 <code>VNode</code>，为什么最终产生的 <code>VNode</code> 是函数式组件呢？别急，大家还记得 <code>h</code> 函数是如何区分有状态组件和函数式组件的吗？如下是我们之前编写的 <code>h</code> 中的一段用来区分函数式组件和有状态组件的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Vue3 的类组件</span>
  flags <span class="token operator">=</span>
    tag<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> tag<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>render
      <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span> <span class="token comment">// 有状态组件</span>
      <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_FUNCTIONAL</span> <span class="token comment">// 函数式组件</span>
  </code></pre></div><p>只有当组件的原型上拥有 <code>render</code> 函数时才会把它当作有状态组件，这里我们再次说明为什么要这样设计，实际上我们在编写有状态组件时，通常需要继承一个框架提供好的基础组件，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyStatefulComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  </code></pre></div><p>其中 <code>Component</code> 组件就是基础组件，而基础组件中会包含 <code>render</code> 函数，如下是 <code>Component</code> 组件的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>那么基础组件的 <code>render</code> 函数有什么用呢？我们知道对于一个组件来说它的 <code>render</code> 函数就是它的一切，假设一个组件没有 <code>render</code> 函数，那么请问该组件存在的意义是什么？它要渲染的又是什么？所以在设计框架的时候，组件是必须要拥有 <code>render</code> 函数的，如果没有 <code>render</code> 函数我们需要打印错误信息来提示用户，这个“警示”的工作就是由基础组件的 <code>render</code> 函数来完成的，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token string">'组件缺少 render 函数'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>它是如何起作用的呢？还记得我们在“组件的本质”一章中曾经讲到过的挂载组件的 <code>mountComponent</code> 函数吗：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 渲染</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 挂载</span>
    <span class="token function">mountElement</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>在挂载组件时我们会创建组件实例，并调用组件的 <code>render</code> 函数，由于任何组件都会继承基础组件，所以一旦组件没有 <code>render</code> 函数，那么基础组件的 <code>render</code> 函数将被调用，此时就会抛出一个异常提示用户：“你的组件缺少 <code>render</code> 函数”。</p> <p>实际上，基础组件还会做更多的任务，本章不会展开讨论。大家只需要知道<strong>在设计有状态组件时，我们会设计一个基础组件，所有组件都会继承基础组件，并且基础组件拥有用来报告错误信息的 <code>render</code> 函数</strong>，这就是我们可以通过以下代码来区分函数式组件和有状态组件的原因：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Vue3 的类组件</span>
  flags <span class="token operator">=</span>
    tag<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> tag<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>render
      <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span> <span class="token comment">// 有状态组件</span>
      <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_FUNCTIONAL</span> <span class="token comment">// 函数式组件</span>
  </code></pre></div><p>了解了这些，我们再来使用 <code>h</code> 函数创建有状态组件的 <code>VNode</code>，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 有状态组件应该继承 Component</span>
  <span class="token keyword">class</span> <span class="token class-name">MyStatefulComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">const</span> statefulComponentVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyStatefulComponent<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  </code></pre></div><p>此时我们得到的 <code>VNode</code> 对象如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> statefulComponentVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    flags<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token comment">// VNodeFlags.COMPONENT_STATEFUL_NORMAL</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      _isVNode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      flags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    childFlags<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    el<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  </code></pre></div><p>可以看到 <code>statefulComponentVNode.flags</code> 的值已经修正了。</p> <p>至此，我们的 <code>h</code> 函数已经可以创建任何类型的 <code>VNode</code> 对象了，有了 <code>VNode</code> 对象，我们下一步要做的就是将 <code>VNode</code> 对象渲染成真实 DOM，下一章我们将开启渲染器之旅。</p></div> 
  <!-- 自定义渲染 -->
  <div class="content__default"><blockquote><p>在本章之前，我们花费了很大的篇幅全面的讲解了一个普通渲染器的实现原理，它可以将 <code>Virtual DOM</code> 渲染为 Web 平台的真实 DOM。本章我们将在上一章的基础上讲解更加高级的渲染器：自定义渲染器(<code>Custom renderer</code>)以及异步渲染。</p></blockquote> <h2 id="自定义渲染器的原理"><a href="http://interview.poetries.top/principle-docs/vue/06-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86" class="header-anchor">#</a> 自定义渲染器的原理</h2> <p>渲染器是围绕 <code>Virtual DOM</code> 而存在的，在 Web 平台下它能够把 <code>Virtual DOM</code> 渲染为浏览器中的真实 DOM 对象，通过前面几章的讲解，相信你已经能够认识到渲染器的实现原理，为了能够将 <code>Virtual DOM</code> 渲染为真实 DOM，渲染器内部需要调用浏览器提供的 DOM 编程接口，下面罗列了在出上一章中我们曾经使用到的那些浏览器为我们提供的 DOM 编程接口：</p> <ul><li><code>document.createElement / createElementNS</code>：创建标签元素。</li> <li><code>document.createTextNode</code>：创建文本元素。</li> <li><code>el.nodeValue</code>：修改文本元素的内容。</li> <li><code>el.removeChild</code>：移除 DOM 元素。</li> <li><code>el.insertBefore</code>：插入 DOM 元素。</li> <li><code>el.appendChild</code>：追加 DOM 元素。</li> <li><code>el.parentNode</code>：获取父元素。</li> <li><code>el.nextSibling</code>：获取下一个兄弟元素。</li> <li><code>document.querySelector</code>：挂载 <code>Portal</code> 类型的 <code>VNode</code> 时，用它查找挂载点。</li></ul> <p>这些 DOM 编程接口完成了 Web 平台(或者说浏览器)下对 DOM 的增加、删除、查找的工作，它是 Web 平台独有的，所以如果渲染器自身强依赖于这些方法(函数)，那么这个渲染器也只能够运行在浏览器中，它不具备跨平台的能力。换句话说，如果想要实现一个平台无关的渲染器，那么渲染器自身必须不能强依赖于任何一个平台下特有的接口，而是应该提供一个抽象层，将 “DOM” 的增加、删除、查找等操作使用抽象接口实现，具体到某个平台下时，由开发者决定如何使用该平台下的接口实现这个抽象层，这就是自定义渲染器的本质。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在下文中，我们将使用 “元素” 一词指代所有平台中的元素对象，例如在 Web 平台下 “元素” 一词指的就是 DOM 元素。</p></div> <p>渲染器除了负责对元素的增加、删除、查找之外，它还负责修改某个特定元素自身的属性/特性，例如 Web 平台中元素具有 <code>id</code>、<code>href</code> 等属性/特性。在上一章中，我们使用 <code>patchData</code> 函数来完成元素自身属性/特性的更新，如下代码用于修改一个元素的类名列表(<code>class</code>)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// patchData.js</span>
    <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
      el<span class="token punctuation">.</span>className <span class="token operator">=</span> nextValue
      <span class="token keyword">break</span>
    </code></pre></div><p>这段代码同样也只能运行在浏览器中，为了渲染器能够跨平台，那么修改一个元素自身的属性/特性的工作也应该作为可自定义的一部分才行，因此，一个跨平台的渲染器应该至少包含两个可自定义的部分：<strong>可自定义元素的增加、删除、查找等操作</strong>、<strong>可自定义元素自身属性/特性的修改操作</strong>。这样对于任何一个元素来说，它的增删改查都已经变成了可自定义的部分，我们只需要“告知”渲染器在对元素进行增删改查时应该做哪些具体的操作即可。</p> <p>接下来我们就着手将一个普通渲染器修改为拥有自定义能力的渲染器，在之前的讲解中，我们将渲染器的代码存放在了 <code>render.js</code> 文件中，如下是整个 <code>render.js</code> 文件的核心代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 导出渲染器</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// ========== 挂载 ==========</span>
    
    <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountText</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountFragment</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountPortal</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// ========== patch ==========</span>
    
    <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
      <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
      nextChildFlags<span class="token punctuation">,</span>
      prevChildren<span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      container</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">patchText</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">patchPortal</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
    <span class="token keyword">function</span> <span class="token function">lis</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    </code></pre></div><p>观察如上代码结构，可以发现一个渲染器由两部分组成：<code>mount</code> 和 <code>patch</code>。在 <code>mount</code> 和 <code>patch</code> 中都会调用浏览器提供的 DOM 编程接口来完成真正的渲染工作。为了将浏览器提供的 DOM 编程接口与渲染器的代码分离，我们可以将如上代码封装到一个叫做 <code>createRenderer</code> 的函数中，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token comment">// ========== 挂载 ==========</span>
    
      <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountText</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountFragment</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountPortal</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token comment">// ========== patch ==========</span>
    
      <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
        <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
        nextChildFlags<span class="token punctuation">,</span>
        prevChildren<span class="token punctuation">,</span>
        nextChildren<span class="token punctuation">,</span>
        container</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">patchText</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">patchPortal</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token keyword">return</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
    <span class="token keyword">function</span> <span class="token function">lis</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    </code></pre></div><p><code>createRenderer</code> 函数的返回值就是之前的 <code>render</code> 函数，也就是说调用 <code>createRenderer</code> 函数可以创建一个渲染器。<code>createRenderer</code> 函数接收一个参数 <code>options</code>，该参数的作用是为了允许外界有能力将操作元素的具体实现以选项的方式传递进来。</p> <p>那么 <code>options</code> 参数中应该包含哪些选项呢？其实前面我们已经分析过了，只要是需要自定义的部分就应该作为选项传递进来，所以参数 <code>options</code> 中至少要包含两部分：一部分是元素的增加、删除、查找；另外一部分是元素的修改，即 <code>patchData</code> 函数。如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// nodeOps 是一个对象，该对象包含了所有用于操作节点的方法</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">createText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
        <span class="token comment">// more...</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      patchData
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>基于此，在 <code>createRenderer</code> 函数内部我们就可以通过解构的方式从 <code>options</code> 参数中得到具体的方法：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// options.nodeOps 选项中包含了本章开头罗列的所有操作 DOM 的方法</span>
      <span class="token comment">// options.patchData 选项就是 patchData 函数</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>
        nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
          createElement<span class="token operator">:</span> platformCreateElement<span class="token punctuation">,</span>
          createText<span class="token operator">:</span> platformCreateText<span class="token punctuation">,</span>
          setText<span class="token operator">:</span> platformSetText<span class="token punctuation">,</span> <span class="token comment">// 等价于 Web 平台的 el.nodeValue</span>
          appendChild<span class="token operator">:</span> platformAppendChild<span class="token punctuation">,</span>
          insertBefore<span class="token operator">:</span> platformInsertBefore<span class="token punctuation">,</span>
          removeChild<span class="token operator">:</span> platformRemoveChild<span class="token punctuation">,</span>
          parentNode<span class="token operator">:</span> platformParentNode<span class="token punctuation">,</span>
          nextSibling<span class="token operator">:</span> platformNextSibling<span class="token punctuation">,</span>
          querySelector<span class="token operator">:</span> platformQuerySelector
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        patchData<span class="token operator">:</span> platformPatchData
      <span class="token punctuation">}</span> <span class="token operator">=</span> options
    
      <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
      <span class="token comment">// ========== 挂载 ==========</span>
      <span class="token comment">// 省略...</span>
    
      <span class="token comment">// ========== patch ==========</span>
      <span class="token comment">// 省略...</span>
    
      <span class="token keyword">return</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上代码所示，<code>options.nodeOps</code> 选项是一个对象，它包含了所有用于对元素进行增、删、查的操作，<code>options.patchData</code> 选项是一个函数，用于处理某个特定元素上的属性/特定，这些内容都是在创建渲染器时由外界来决定的。</p> <p>接下来我们要做的就是将渲染器中原本使用了 Web 平台进行 DOM 操作的地方修改成使用通过解构得到的函数进行替代，例如在创建 DOM 元素时，原来的实现如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isSVG <span class="token operator">=</span> isSVG <span class="token operator">||</span> vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>现在我们应该使用 <code>platformCreateElement</code> 函数替代 <code>document.createElement(NS)</code>：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">,</span> refNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isSVG <span class="token operator">=</span> isSVG <span class="token operator">||</span> vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token function">platformCreateElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>类似的，其他所有涉及 DOM 操作的地方都应该使用这些通过解构得到的抽象接口替代。当这部分工作完成之后，接下来要做的就是对这些用于操作节点的抽象方法进行实现，如下代码所示，我们实现了 Web 平台下创建 DOM 节点的方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> isSVG
            <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
            <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>再举一个例子，下面这条语句是我们之前实现的渲染器中用于移除旧 <code>children</code> 中节点的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    </code></pre></div><p>现在我们将之替换为 <code>platformRemoveChild</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">platformRemoveChild</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    </code></pre></div><p>为了让这段代码在 Web 平台正常工作，我们需要在创建渲染器时实现 <code>nodeOps.removeChild</code> 函数：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> isSVG
            <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
            <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>也许你已经想到了，当我们实现了所有 <code>nodeOps</code> 下的规定的抽象接口之后，实际上就完成了一个面向 Web 平台的渲染器，如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> isSVG
            <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
            <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">setText</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          node<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> text
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          parent<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> ref<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">parentNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> node<span class="token punctuation">.</span>parentNode
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">nextSibling</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> node<span class="token punctuation">.</span>nextSibling
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>当然了，如上代码所创建的渲染器只能够完成 Web 平台中对 DOM 的增加、删除和查找的功能，为了能够修改 DOM 元素自身的属性和特性，我们还需要在创建渲染器时将 <code>patchData</code> 函数作为选项传递过去，好在我们之前已经封装了 <code>patchData</code> 函数，现在直接拿过来用即可：</p> <div class="language-js extra-class"><div class="highlight-lines"><div class="highlighted">&nbsp;</div><br><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> patchData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./patchData'</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略...</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      patchData
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/mq8v65qyry" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/mq8v65qyry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>以上我们就完成了对渲染器的抽象，使它成为一个平台无关的工具。并基于此实现了一个 Web 平台的渲染器，专门用于浏览器环境。</p> <h2 id="自定义渲染器的应用"><a href="http://interview.poetries.top/principle-docs/vue/06-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8" class="header-anchor">#</a> 自定义渲染器的应用</h2> <p><code>Vue3</code> 提供了一个叫做 <code>@vue/runtime-test</code> 的包，其作用是方便开发者在无 DOM 环境时有能力对组件的渲染内容进行测试，这实际上就是对自定义渲染器的应用。本节我们尝试来实现与 <code>@vue/runtime-test</code> 具有相同功能的渲染器。</p> <p>原理其实很简单，如下代码所示，这是用于 Web 平台下创建真实 DOM 元素的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> isSVG
            <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
            <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>其中 <code>nodeOps.createElement</code> 函数会返回一个真实的 DOM 对象，在其内部调用的是浏览器为我们提供的 <code>document.createElement/NS</code> 函数。实际上 <code>nodeOps.createElement</code> 函数的真正意图是：<strong>创建一个元素</strong>，然而并没有规定这个元素应该由谁来创建，或这个元素应该具有什么样的特征，这就是自定义的核心所在。因此，我们完全使 <code>nodeOps.createElement</code> 函数返回一个普通对象来代指一个元素，后续的所有操作都是基于我们所规定的元素而进行，如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
            type<span class="token operator">:</span> <span class="token string">'ELEMENT'</span><span class="token punctuation">,</span>
            tag
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>在这段代码中，我们自行规定了 <code>nodeOps.createElement</code> 函数所返回的元素的格式，即 <code>customElement</code> 对象，它包含两个属性，分别是 用来代表元素类型的 <code>type</code> 属性以及用来代表元素名称的 <code>tag</code> 属性。虽然看上去很奇怪，但这确实是一个完全符合要求的实现。这么做的结果就是：<strong><code>nodeOps.createElement</code> 函数所创建的元素不来自于浏览器的 DOM 编程接口，更不来自于任何其他平台的 API</strong>，因此，如上代码所创建的渲染器也将是一个平台无关的渲染器。这就是为什么 <code>@vue/runtime-test</code> 可以运行在 <code>NodeJs</code> 中的原因。</p> <p>当然了，如上代码中 <code>customElement</code> 只有两个属性，实际上这并不能满足需求，即使元素的格式由我们自行定义，但还是要有一定的限制，例如元素会有子节点，子节点也需要保存对父节点的引用，元素自身也会有属性/特性等等。一个最小且完整的元素定义应该包含以下属性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
      type<span class="token punctuation">,</span> <span class="token comment">// 元素的类型：ELEMENT ---&gt; 标签元素；TEXT ---&gt; 文本</span>
      tag<span class="token punctuation">,</span> <span class="token comment">// 当 type === 'ELEMENT' 时，tag 属性为标签名字</span>
      parentNode<span class="token punctuation">,</span> <span class="token comment">// 对父节点的引用</span>
      children<span class="token punctuation">,</span> <span class="token comment">// 子节点</span>
      props<span class="token punctuation">,</span>  <span class="token comment">// 当 type === 'ELEMENT' 时，props 中存储着元素的属性/特性</span>
      eventListeners<span class="token punctuation">,</span>  <span class="token comment">// 当 type === 'ELEMENT' 时，eventListeners 中存储着元素的事件信息</span>
      text  <span class="token comment">// 当 type === 'TEXT' 时，text 存储着文本内容</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>现在 <code>customElement</code> 就是一个能完全代替真实 DOM 对象的模拟实现了，我们用它修改之前的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
            type<span class="token operator">:</span> <span class="token string">'ELEMENT'</span><span class="token punctuation">,</span>
            tag<span class="token punctuation">,</span>
            parentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
            children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            eventListeners<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            text<span class="token operator">:</span> <span class="token keyword">null</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>如上代码所示，由于 <code>nodeOps.createElement</code> 函数用于创建元素节点，因此 <code>type</code> 属性的值为 <code>'ELEMENT'</code>；刚刚创建的元素还不能确定其父节点，因此 <code>parentNode</code> 为 <code>null</code>；用于存储子节点的 <code>children</code> 属性被初始化为一个数组，<code>props</code> 属性和 <code>eventListeners</code> 被初始化为空对象；最后的 <code>text</code> 为 <code>null</code>，因为它不是一个文本节点。</p> <p>现在创建元素节点的功能已经实现，那么创建文本节点呢？如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
            type<span class="token operator">:</span> <span class="token string">'TEXT'</span><span class="token punctuation">,</span>
            parentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
            text<span class="token operator">:</span> text
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>文本元素的 <code>type</code> 类型值为 <code>'TEXT'</code>，<code>parentNode</code> 同样被初始化为 <code>unll</code>，<code>text</code> 属性存储着文本节点的内容。由于文本元素没有子节点、属性/特性、事件等信息，因此不需要其他描述信息。</p> <p>文本节点与元素节点的创建都已经实现，接下来我们看看当元素被追加时应该如何处理，即 <code>nodeOps.appendChild</code> 函数的实现：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 简历父子关系</span>
          child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> parent
          parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>如上高亮代码所示，追加节点时我们要做的就是建立节点间正确的父子关系，在 Web 平台下，当我们调用 <code>el.appendChild</code> 函数时，父子关系是由浏览器负责建立的，但在模拟实现中，这个关系需要我们自己来维护。不过好在这很简单，让子元素的 <code>parentNode</code> 指向父元素，同时将子元素添加到父元素的 <code>children</code> 数组中即可。</p> <p>类似的，如下是 <code>nodeOps.removeChild</code> 函数的实现：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 简历父子关系</span>
          child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> parent
          parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 找到将要移除的元素 child 在父元素的 children 中的位置</span>
          <span class="token keyword">const</span> i <span class="token operator">=</span> parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果找到了，则将其删除</span>
            parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 没找到，说明渲染器出了问题，例如没有在 nodeOps.appendChild 函数中维护正确的父子关系等</span>
            <span class="token comment">// 这时需要打印错误信息，以提示开发者</span>
            console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'target: '</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span>
            console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'parent: '</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">'target 不是 parent 的子节点'</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 清空父子链</span>
          child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>如上高亮代码所示，在移除节点时，思路也很简单，首先需要在父节点的 <code>children</code> 属性中查找即将要被移除的节点的位置索引，如果找到了，那么就直接将其从父节点的 <code>children</code> 数组中移除即可。如果没有找到则说明渲染器出问题了，例如在你实现自定义渲染器时没有在 <code>nodeOps.appendChild</code> 函数或 <code>nodeOps.insertBefore</code> 函数中维护正确的父子关系，这时我们需要打印错误信息以提示开发者。最后不要忘记清空父子链。</p> <p>通过如上的讲解，你可能已经领会到了，我们所做的其实就是在模拟 Web 平台在操作元素时的行为，并且这个模拟的思路也及其简单。实际上，当我们实现了所有 <code>nodeOps</code> 下的抽象函数之后，那么这个类似于 <code>@vue/runtime-test</code> 的自定义渲染器就基本完成了。当然，不要忘记的是我们还需要实现 <code>patchData</code> 函数，这可能比你想象的要简单的多，如下高亮代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">createText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span>
        <span class="token comment">// 其他 nodeOps 函数的实现</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">patchData</span><span class="token punctuation">(</span>
        <span class="token parameter">el<span class="token punctuation">,</span>
        key<span class="token punctuation">,</span>
        prevValue<span class="token punctuation">,</span>
        nextValue</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将属性添加到元素的 props 对象下</span>
        el<span class="token punctuation">.</span>props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
        <span class="token comment">// 我们将属性名字中前两个字符是 'o' 和 'n' 的属性认为是事件绑定</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 如果是事件，则将事件添加到元素的 eventListeners 对象下</span>
          <span class="token keyword">const</span> event <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">;</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>eventListeners <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>eventListeners <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>在创建渲染器时我们需要实现 <code>patchData</code> 函数的功能，它的功能是用来更新元素自身的属性/特性的，在之前的讲解中我们实现了 Web 平台中 <code>patchData</code> 函数，然而在这个模拟实现中，我们要做的事情就少了很多。只需要把元素的属性添加到元素的 <code>props</code> 对象中即可，同时如果是事件的话，我们也只需要将其添加到元素的 <code>eventListeners</code> 对象中就可以了。</p> <p>实际上，本节我们所实现的自定义渲染器，就能够满足我们对组件测试的需求，我们可以利用它来测试组件所渲染内容的正确性。如果你想要进一步提升该自定义渲染器的能力，例如希望该渲染器有能力在控制台中打印出操作元素的信息，也很简单，我们以创建元素为例，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> customElement <span class="token operator">=</span> <span class="token punctuation">{</span>
            type<span class="token operator">:</span> <span class="token string">'ELEMENT'</span><span class="token punctuation">,</span>
            tag<span class="token punctuation">,</span>
            parentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
            children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            eventListeners<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            text<span class="token operator">:</span> <span class="token keyword">null</span>
          <span class="token punctuation">}</span>
    
          console<span class="token punctuation">.</span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            type<span class="token operator">:</span> <span class="token string">'CREATE ELEMENT'</span><span class="token punctuation">,</span>
            targetNode<span class="token operator">:</span> customElement
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
          <span class="token keyword">return</span> customElement
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>只需要在 <code>nodeOps.createElement</code> 函数中调用 <code>console.table</code> 进行打印你想要的信息即可，例如我们打印了一个对象，该对象包含 <code>type</code> 属性用于指示当前操作元素的类型，所以对于创建元素来说，我们为 <code>type</code> 属性赋值了字符串 <code>'CREATE ELEMENT'</code>，同时将目标节点也打印了出来(即 <code>targetNode</code>)。类似的，追加节点可以打印如下信息：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      nodeOps<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略... */</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 简历父子关系</span>
          child<span class="token punctuation">.</span>parentNode <span class="token operator">=</span> parent
          parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    
          console<span class="token punctuation">.</span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            type<span class="token operator">:</span> <span class="token string">'APPEND'</span><span class="token punctuation">,</span>
            targetNode<span class="token operator">:</span> child<span class="token punctuation">,</span>
            parentNode<span class="token operator">:</span> parent
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>怎么样，是不是很简单。当然了这只是自定义渲染器的应用之一，对于自定义渲染器来说，它可发挥的空间还是非常大的，举几个例子：</p> <ul><li>渲染到 <code>PDF</code>，我们可以实现一个自定义渲染器如 <code>vue-pdf-renderer</code>，它能够将 <code>Vue</code> 组件渲染为 <code>PDF</code> 文件。</li> <li>渲染到文件系统，我们可以实现一个 <code>vue-file-renderer</code>，它可以根据 <code>VNode</code> 的结构在本地渲染与该结构相同的文件目录。</li> <li><code>canvas</code> 渲染器，我们可以实现一个 <code>vue-canvas-renderer</code>，它可以从渲染器的层面渲染 <code>canvas</code>，而非组件层面。</li></ul> <p>以上仅仅是简单的列了几个小想法，实际上由于自定义渲染器本身就是平台无关的，很多事情需要看特定平台的能力，渲染器为你提供的就是在组件层面的抽象能力以及虚拟 DOM 的更新算法，剩下的就靠社区的想象力和实现能力了。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/v39py7lxq5" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/v39py7lxq5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="references"><a href="http://interview.poetries.top/principle-docs/vue/06-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.html#references" class="header-anchor">#</a> References</h2> <ul><li><a href="https://www.youtube.com/watch?reload=9&amp;v=cCOL7MC4Pl0&amp;feature=youtu.be" target="_blank" rel="noopener noreferrer">Jake Archibald: In The Loop - JSConf.Asia 2018<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://html.spec.whatwg.org/#event-loop-processing-model" target="_blank" rel="noopener noreferrer">https://html.spec.whatwg.org/#event-loop-processing-model<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> 
    <!-- 渲染器挂载 -->
    <div class="content__default"><hr> <h2 id="sidebardepth-4"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#sidebardepth-4" class="header-anchor">#</a> sidebarDepth: 4</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>本章主要讲解渲染器将各种类型的 <code>VNode</code> 挂载为真实 DOM 的原理，阅读本章内容你将对 <code>Fragment</code> 和 <code>Portal</code> 有更加深入的理解，同时渲染器对有状态组件和函数式组件的挂载实际上也透露了有状态组件和函数式组件的实现原理，这都会包含在本章的内容之中。另外本章的代码将使用上一章所编写的 <code>h</code> 函数，所以请确保你已经阅读了上一章的内容。</p></div> <h2 id="责任重大的渲染器"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E8%B4%A3%E4%BB%BB%E9%87%8D%E5%A4%A7%E7%9A%84%E6%B8%B2%E6%9F%93%E5%99%A8" class="header-anchor">#</a> 责任重大的渲染器</h2> <p>所谓渲染器，简单的说就是将 <code>Virtual DOM</code> 渲染成特定平台下真实 <code>DOM</code> 的工具(就是一个函数，通常叫 <code>render</code>)，渲染器的工作流程分为两个阶段：<code>mount</code> 和 <code>patch</code>，如果旧的 <code>VNode</code> 存在，则会使用新的 <code>VNode</code> 与旧的 <code>VNode</code> 进行对比，试图以最小的资源开销完成 <code>DOM</code> 的更新，这个过程就叫 <code>patch</code>，或“打补丁”。如果旧的 <code>VNode</code> 不存在，则直接将新的 <code>VNode</code> 挂载成全新的 <code>DOM</code>，这个过程叫做 <code>mount</code>。</p> <p>通常渲染器接收两个参数，第一个参数是将要被渲染的 <code>VNode</code> 对象，第二个参数是一个用来承载内容的容器(<code>container</code>)，通常也叫挂载点，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> container<span class="token punctuation">.</span>vnode
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 没有旧的 VNode，只有新的 VNode。使用 `mount` 函数挂载全新的 VNode</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token comment">// 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了</span>
          container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> vnode
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 有旧的 VNode，也有新的 VNode。则调用 `patch` 函数打补丁</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token comment">// 更新 container.vnode</span>
          container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> vnode
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>整体思路非常简单，如果旧的 <code>VNode</code> 不存在且新的 <code>VNode</code> 存在，那就直接挂载(<code>mount</code>)新的 <code>VNode</code> ；如果旧的 <code>VNode</code> 存在且新的 <code>VNode</code> 不存在，那就直接将 <code>DOM</code> 移除；如果新旧 <code>VNode</code> 都存在，那就打补丁(<code>patch</code>)：</p> <table><thead><tr><th>旧 VNode</th> <th>新 VNode</th> <th>操作</th></tr></thead> <tbody><tr><td>❌</td> <td>✅</td> <td>调用 <code>mount</code> 函数</td></tr> <tr><td>✅</td> <td>❌</td> <td>移除 <code>DOM</code></td></tr> <tr><td>✅</td> <td>✅</td> <td>调用 <code>patch</code> 函数</td></tr></tbody></table> <p>之所以说渲染器的责任非常之大，是因为它不仅仅是一个把 <code>VNode</code> 渲染成真实 <code>DOM</code> 的工具，它还负责以下工作：</p> <ul><li>控制部分组件生命周期钩子的调用</li></ul> <p>在整个渲染周期中包含了大量的 <code>DOM</code> 操作、组件的挂载、卸载，控制着组件的生命周期钩子调用的时机。</p> <ul><li>多端渲染的桥梁</li></ul> <p>渲染器也是多端渲染的桥梁，自定义渲染器的本质就是把特定平台操作“DOM”的方法从核心算法中抽离，并提供可配置的方案。</p> <ul><li>与异步渲染有直接关系</li></ul> <p><code>Vue3</code> 的异步渲染是基于调度器的实现，若要实现异步渲染，组件的挂载就不能同步进行，DOM的变更就要在合适的时机，一些需要在真实DOM存在之后才能执行的操作(如 <code>ref</code>)也应该在合适的时机进行。对于时机的控制是由调度器来完成的，但类似于组件的挂载与卸载以及操作 <code>DOM</code> 等行为的入队还是由渲染器来完成的，这也是为什么 <code>Vue2</code> 无法轻易实现异步渲染的原因。</p> <ul><li>包含最核心的 Diff 算法</li></ul> <p><code>Diff</code> 算法是渲染器的核心特性之一，可以说正是 <code>Diff</code> 算法的存在才使得 <code>Virtual DOM</code> 如此成功。</p> <h2 id="挂载普通标签元素"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD%E6%99%AE%E9%80%9A%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0" class="header-anchor">#</a> 挂载普通标签元素</h2> <h3 id="基本原理"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" class="header-anchor">#</a> 基本原理</h3> <p>渲染器的责任重大，所以它做的事情也非常多，一口吃成胖子是不太现实的，我们需要一点点地消化。</p> <p>在初次调用渲染器渲染某个 <code>VNode</code> 时：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    </code></pre></div><p>由于没有旧的 <code>VNode</code> 存在，所以会调用 <code>mount</code> 函数挂载全新的 <code>VNode</code> ，这个小节我们就探讨一下渲染器的 <code>mount</code> 函数是如何把 <code>VNode</code> 渲染成真实 <code>DOM</code> 的，以及其中一些核心的关键点。</p> <p><code>mount</code> 函数的作用是把一个 <code>VNode</code> 渲染成真实 <code>DOM</code>，根据不同类型的 <code>VNode</code> 需要采用不同的挂载方式，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> flags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
      <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载普通标签</span>
        <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载组件</span>
        <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载纯文本</span>
        <span class="token function">mountText</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载 Fragment</span>
        <span class="token function">mountFragment</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载 Portal</span>
        <span class="token function">mountPortal</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>我们根据 <code>VNode</code> 的 <code>flags</code> 属性值能够区分一个 <code>VNode</code> 对象的类型，不同类型的 <code>VNode</code> 采用不同的挂载函数：</p> <p><img src="./渲染器的挂载_files/flags-mount.4756a068.png" alt="" class="medium-zoom-image"></p> <p>我们首先来讨论一下 <code>mountElement</code> 函数，它用于挂载普通标签元素。我们在"组件的本质"一章中曾经编写过如下这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>这是一个极简的用于挂载普通标签元素的 <code>mountElement</code> 函数，它会调用浏览器提供的 <code>document.createElement</code> 函数创建元素，接着调用 <code>appendChild</code> 函数将元素添加到 <code>container</code> 中，但它具有以下缺陷：</p> <ul><li>1、<code>VNode</code> 被渲染为真实DOM之后，没有引用真实DOM元素</li> <li>2、没有将 <code>VNodeData</code> 应用到真实DOM元素上</li> <li>3、没有继续挂载子节点，即 <code>children</code></li> <li>4、不能严谨地处理 <code>SVG</code> 标签</li></ul> <p>针对这四个问题，我们逐个去解决。先来看第一个问题：<strong><code>VNode</code> 被渲染为真实DOM之后，没有引用真实DOM元素</strong>，这个问题很好解决，只需要添加一行代码即可：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> el
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>再来看第二个问题：<strong>没有将 <code>VNodeData</code> 应用到元素上</strong>，我们知道 <code>VNodeData</code> 作为 <code>VNode</code> 的描述，对于标签元素来说它包含了元素的样式、事件等诸多信息，我们需要将这些信息应用到新创建的真实DOM元素上，假设我们有如下 <code>VNode</code>：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>再次强调，本章使用上一章节中所编写的 <code>h</code> 函数。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        style<span class="token operator">:</span> <span class="token punctuation">{</span>
          height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          background<span class="token operator">:</span> <span class="token string">'red'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
    </code></pre></div><p>我们使用 <code>h</code> 函数创建了一个描述 <code>div</code> 标签的 <code>VNode</code> 对象，观察 <code>VNodeData</code> 可以发现，它拥有一些内联样式，所以在 <code>mountElement</code> 函数内，我们需要将这些内联样式应用到元素上，我们给 <code>mountElement</code> 增加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
    
      <span class="token comment">// 拿到 VNodeData</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 VNodeData 存在，则遍历之</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// key 可能是 class、style、on 等等</span>
          <span class="token keyword">switch</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
              <span class="token comment">// 如果 key 的值是 style，说明是内联样式，逐个将样式规则应用到 el</span>
              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> data<span class="token punctuation">.</span>style<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
              <span class="token punctuation">}</span>
            <span class="token keyword">break</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上代码所示，在创建真实DOM之后，我们需要检查 <code>VNodeData</code> 是否存在，如果 <code>VNodeData</code> 存在则遍历之。由于 <code>VNodeData</code> 中不仅仅包含内联样式的描述(即 <code>style</code>)，还可能包含其他描述如 <code>class</code>、事件等等，所以我们使用 <code>switch...case</code> 语句对不同的 <code>key</code> 值做区分处理，以 <code>style</code> 为例，我们只需要将 <code>data.style</code> 中的样式规则应用到真实DOM即可。使用渲染器渲染 <code>elementVNode</code> 的效果如下：</p> <p><img src="./渲染器的挂载_files/vnodedata-style.ad61c1c6.png" alt="" class="medium-zoom-image"></p> <p>对于 <code>class</code> 或事件或其他DOM属性都是类似的处理方式，为了不偏题我们放到后面统一讲解，接下来我们来看第三个问题：<strong>没有继续挂载子节点，即 <code>children</code></strong>，我们知道 <code>VNode</code> 是有可能存在子节点的，现在的 <code>mountElement</code> 函数仅仅将该 <code>VNode</code> 本身所描述的DOM元素添加到了页面中，却没有理会其子节点，为了递归地挂载子节点，我们需要为 <code>mountElement</code> 函数增加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> el
      <span class="token comment">// 省略处理 VNodeData 相关的代码</span>
    
      <span class="token comment">// 递归挂载子节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> el<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>观察如上代码中用来递归挂载子节点的代码，我们默认把 <code>vnode.children</code> 当作数组来处理，同时递归挂载的时候调用的仍然是 <code>mountElement</code> 函数。这存在两个瑕疵，第一个瑕疵是 <code>VNode</code> 对象的 <code>children</code> 属性不总是数组，因为当 <code>VNode</code> 只有一个子节点时，该 <code>VNode</code> 的 <code>children</code> 属性直接指向该子节点，且 <code>VNode</code> 的 <code>childFlags</code> 的值为 <code>ChildrenFlags.SINGLE_VNODE</code>，所以我们不应该总是使用 <code>for</code> 循环遍历 <code>vnode.children</code>。第二个瑕疵是我们在 <code>for</code> 循环内部直接调用了 <code>mountElement</code> 属性去挂载每一个 <code>children</code> 中的 <code>VNode</code> 对象，但问题是 <code>children</code> 中的 <code>VNode</code> 对象可能是任意类型的，所以我们不应该直接调用 <code>mountElement</code> 函数，而是应该调用 <code>mount</code> 函数。更加严谨的代码如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> el
      <span class="token comment">// 省略处理 VNodeData 的代码</span>
    
      <span class="token comment">// 拿到 children 和 childFlags</span>
      <span class="token keyword">const</span> childFlags <span class="token operator">=</span> vnode<span class="token punctuation">.</span>childFlags
      <span class="token keyword">const</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children
      <span class="token comment">// 检测如果没有子节点则无需递归挂载</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">!==</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 如果是单个子节点则调用 mount 函数挂载</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> el<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 如果是单多个子节点则遍历并调用 mount 函数挂载</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上代码所示，我们通过 <code>vnode.childFlags</code> 拿到该 <code>VNode</code> 子节点的类型，接着检测其是否含有子节点，如果存在子节点，会检测是单个子节点还是多个子节点，只有当存在多个子节点时其 <code>children</code> 属性才是可遍历的数组，最后调用 <code>mount</code> 函数挂载之。</p> <p>我们尝试修改之前的 <code>elementVNode</code>，为其添加子节点：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        style<span class="token operator">:</span> <span class="token punctuation">{</span>
          height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          background<span class="token operator">:</span> <span class="token string">'red'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        style<span class="token operator">:</span> <span class="token punctuation">{</span>
          height<span class="token operator">:</span> <span class="token string">'50px'</span><span class="token punctuation">,</span>
          width<span class="token operator">:</span> <span class="token string">'50px'</span><span class="token punctuation">,</span>
          background<span class="token operator">:</span> <span class="token string">'green'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
    </code></pre></div><p>如上代码可知，我们为 <code>elementVnode</code> 添加了一个子节点，该子节点是一个边长为 <code>50px</code> 的绿色正方形，使用渲染器渲染修改后的 <code>elementVnode</code> 的效果如下：</p> <p><img src="./渲染器的挂载_files/vnodedata-children.0d6064f7.png" alt="" class="medium-zoom-image"></p> <p>接着我们来看最后一个问题：<strong>不能严谨地处理 <code>SVG</code> 标签</strong>，在之前的 <code>mountElement</code> 函数中我们使用 <code>document.createElement</code> 函数创建DOM元素，但是对于 <code>SVG</code> 标签，更加严谨的方式是使用 <code>document.createElementNS</code> 函数，修改 <code>mountElement</code> 如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> isSVG <span class="token operator">=</span> vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> el
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>我们通过 <code>vnode.flags</code> 来判断一个标签是否是 <code>SVG</code>，但是大家不要忘记 <code>vnode.flags</code> 是如何被标记为 <code>VNodeFlags.ELEMENT_SVG</code>的，我们在讲解 <code>h</code> 函数时说明过这个问题，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flags <span class="token operator">=</span> tag <span class="token operator">===</span> <span class="token string">'svg'</span> <span class="token operator">?</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span> <span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>我们注意到，只有当标签名字全等于字符串 <code>'svg'</code> 时，该 <code>VNode</code> 的 <code>flags</code> 才会被标记为 <code>VNodeFlags.ELEMENT_SVG</code>，这意味着 <code>&lt;circle/&gt;</code> 标签不会被标记为 <code>VNodeFlags.ELEMENT_SVG</code>，所以在创建 <code>&lt;circle/&gt;</code> 元素时并不会使用 <code>document.createElementNS</code> 函数，但 <code>&lt;circle/&gt;</code> 标签确实是 <code>svg</code> 标签，如何解决这个问题呢？其实很简单，因为 <strong><code>svg</code> 的书写总是以 <code>&lt;svg&gt;</code> 标签开始的，所有其他 <code>svg</code> 相关的标签都是 <code>&lt;svg&gt;</code> 标签的子代元素</strong>。所以解决方案就是：在 <code>mountElement</code> 函数中一旦 <code>isSVG</code> 为真，那么后续创建的所有子代元素都会被认为是 <code>svg</code> 标签，我们需要修改 <code>mountElement</code> 函数，为其添加第三个参数，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isSVG <span class="token operator">=</span> isSVG <span class="token operator">||</span> vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_SVG</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> isSVG
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span><span class="token string">'http://www.w3.org/2000/svg'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
      <span class="token comment">// 省略处理 VNodeData 的代码</span>
    
      <span class="token keyword">const</span> childFlags <span class="token operator">=</span> vnode<span class="token punctuation">.</span>childFlags
      <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">!==</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 这里需要把 isSVG 传递下去</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> el<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里需要把 isSVG 传递下去</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上代码所示，我们为 <code>mountElement</code> 增加了第三个参数 <code>isSVG</code>，接着在判断一个 <code>VNode</code> 是否是 <code>svg</code> 元素时优先使用参数中的 <code>isSVG</code> 作为判断条件，并且使用 <code>vnode.flags &amp; VNodeFlags.ELEMENT_SVG</code> 作为回退判断条件，最后在挂载子节点的时候将 <code>isSVG</code> 参数传递下去。这样我们就能达到一个目的：<strong>即使 <code>&lt;circle/&gt;</code> 标签对应的 <code>vnode.flags</code> 不是 <code>VNodeFlags.ELEMENT_SVG</code>，但在 <code>mountElement</code> 函数看来它依然是 <code>svg</code> 标签</strong>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>实际上我们也应该对大部分挂载函数做一定的修改，即增加第三个参数，这里就省略了。完整可运行代码请查看：<a href="https://codesandbox.io/s/6v38x6k0nw" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/6v38x6k0nw<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="class的处理"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#class%E7%9A%84%E5%A4%84%E7%90%86" class="header-anchor">#</a> class的处理</h3> <p>前面我们在 <code>mountElement</code> 函数中实现了将内联样式应用到元素的功能，接着我们来想办法将 <code>class</code> 也应用到元素上，在开始实现功能之前我们第一步要做的是：<strong>设计数据结构</strong>，比如我们采用了 <code>data.style</code> 来存储内联样式的数据，并且其数据结构就是一个 <code>key-value</code> 的映射，对于 <code>class</code> 我们希望使用 <code>data.class</code> 来存储其数据，并且我们希望 <code>data.class</code> 的值就是类名字符串，例如：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'cls-a cls-b'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
    </code></pre></div><p>这样我们就可以轻松将类名列表添加到DOM元素上，我们为 <code>mountElement</code> 添加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    
      <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> data<span class="token punctuation">.</span>style<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span>
            <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
              el<span class="token punctuation">.</span>className <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
              <span class="token keyword">break</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
              <span class="token keyword">break</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上高亮代码所示，我们给 <code>switch</code> 添加了一个 <code>case</code> 语句块，用来匹配 <code>VNodeData</code> 中的 <code>class</code> 数据，由于我们将 <code>data.class</code> 设计成了可直接使用的类名列表字符串，所以只需要直接将 <code>data.class</code> 赋值给 <code>el.className</code> 即可，如下是渲染 <code>elementVNode</code> 的效果：</p> <p><img src="./渲染器的挂载_files/mount-element-class.3873d5f4.png" alt="" class="medium-zoom-image"></p> <p>效果已经达到了，但是我们需要额外思考一些东西。在上面的讲解中我们直接把 <code>data.class</code> 的数据结构设计成可直接使用的类名列表字符串，但这是很底层的设计，换句话说这是框架层面的设计，我们还需要考虑应用层的设计，什么意思呢？来看如下这段模板：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cls-a<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dynamicClass<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
    </code></pre></div><p>在这段模板中我们同时使用了 <code>class</code> 属性和绑定的 <code>:class</code> 属性，对于非绑定的 <code>class</code> 属性来说它的值就是我们最终想要的类名列表字符串，但是对于绑定的 <code>:class</code> 属性来说它的值是动态的 <code>javascript</code> 值，所以我们需要设计一下哪些值是被允许的。</p> <p>首先数组应该是被允许的：</p> <div class="language-js extra-class"><pre class="language-js"><code>dynamicClass <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'class-b'</span><span class="token punctuation">,</span> <span class="token string">'class-c'</span><span class="token punctuation">]</span>
    </code></pre></div><p>对象也应该是被允许的：</p> <div class="language-js extra-class"><pre class="language-js"><code>dynamicClass <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token string">'class-b'</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token string">'class-c'</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>在编译器对模板进行编译时，我们把非绑定和绑定的 <code>class</code> 属性值合并，如下是我们期望编译器对上面模板的编译结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'class-a'</span><span class="token punctuation">,</span> dynamicClass<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>如果 <code>dynamicClass</code> 是数组，那么如上代码等价于：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'class-a'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'class-b'</span><span class="token punctuation">,</span> <span class="token string">'class-c'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>如果 <code>dynamicClass</code> 是对象，那么编译的结果等价于：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">'class-a'</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token string">'class-b'</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token string">'class-c'</span><span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>可以看到在使用 <code>h</code> 函数创建 <code>VNode</code> 时，<code>VNodeData</code> 中的 <code>class</code> 还不可能是我们最终想要的类名列表字符串，那怎么办呢？很简单，我们只需要在 <code>h</code> 函数内部编写一个函数将如上数据结构序列化成我们想要的类名列表字符串就可以了，这就像一个小小的算法题目，相信大家都写的出来，这里就不展开讲解，下面的链接中拥有完整的可执行代码。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/397w7kxy1" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/397w7kxy1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>实际上，通过对 <code>class</code> 的讲解，我们涉及了在框架设计中比较重要的概念：<strong>应用层的设计</strong>，这是框架设计的核心，在设计一个功能的时候，你首先要考虑的应该是应用层的使用，然后再考虑如何与底层衔接。还是以 <code>class</code> 为例，为一个标签元素设置类名的方法是可定的(调用 <code>el.className</code> 或 <code>setAttribute</code>)，关键就在于你想在应用层做出怎样的设计，很自然的你要思考如何转化应用层的数据结构与底层衔接。</p> <h3 id="attributes-和-dom-properties"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#attributes-%E5%92%8C-dom-properties" class="header-anchor">#</a> Attributes 和 DOM Properties</h3> <p>接下来我们讲一讲DOM的 <code>Attributes</code> 以及 <code>Properties</code>，下面我们分别简称他们为 <code>attr</code> 和 <code>DOM Prop</code>，那么他们两个之间有什么区别呢？这里我们简单解释一下，我们知道浏览器在加载页面之后会对页面中的标签进行解析，并生成与之相符的 DOM 对象，每个标签中都可能包含一些属性，如果这些属性是<strong>标准属性</strong>，那么解析生成的DOM对象中也会包含与之对应的属性，例如：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
    </code></pre></div><p>由于 <code>id</code> 是标准属性，所以我们可以通过 <code>document.body.id</code> 来访问它的值，实际上我们常说的 <code>Attr</code> 指的就是那些存在于标签上的属性，而 <code>DOM Prop</code> 就是存在于DOM对象上的属性。但是当标签上存在非标准属性时，该属性不会被转化为 <code>DOM Prop</code>，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>body custom<span class="token operator">=</span><span class="token string">"val"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
    </code></pre></div><p>由于 <code>custom</code> 是非标准属性，所以当你尝试通过 <code>document.body.custom</code> 访问其值时会得到 <code>undefined</code>，这也是为什么 <code>setAttribute</code> 方法存在的原因，因为该方法允许我们为 DOM 元素设置自定义属性（不会初始化同名的 <code>property</code>）。另外该方法也允许我们为 DOM 元素设置标准属性的值，所以我们可不可以总是使用 <code>setAttribute</code> 设置全部的 <code>DOM</code> 属性呢？答案是：不行。举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// checkbox 元素</span>
    <span class="token keyword">const</span> checkboxEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span>
    <span class="token comment">// 使用 setAttribute 设置 checked 属性为 false</span>
    checkboxEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'checked'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>checkboxEl<span class="token punctuation">.</span>checked<span class="token punctuation">)</span> <span class="token comment">// true</span>
    </code></pre></div><p>可以看到虽然我们使用 <code>setAttribute</code> 函数将复选框的 <code>checked</code> 属性设置为 <code>false</code>，但是当我们访问 <code>checkboxEl.checked</code> 时得到的依然是 <code>true</code>，这是因为在 <code>setAttribute</code> 函数为元素设置属性时，无论你传递的值是什么类型，它都会将该值转为字符串再设置到元素上，所以如下两句代码是等价的：</p> <div class="language-js extra-class"><pre class="language-js"><code>checkboxEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'checked'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token comment">// 等价于</span>
    checkboxEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'checked'</span><span class="token punctuation">,</span> <span class="token string">'false'</span><span class="token punctuation">)</span>
    </code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>一些特殊的 <code>attribute</code>，比如 <code>checked/disabled</code> 等，只要出现了，对应的 <code>property</code> 就会被初始化为 <code>true</code>，无论设置的值是什么,只有调用 <code>removeAttribute</code> 删除这个 <code>attribute</code>，对应的 <code>property</code> 才会变成 <code>false</code>。</p></div> <p>这就指引我们有些属性不能通过 <code>setAttribute</code> 设置，而是应该直接通过 DOM 元素设置：<code>el.checked = true</code>。好在这样的属性不多，我们可以列举出来：<code>value</code>、<code>checked</code>、<code>selected</code>、<code>muted</code>。除此之外还有一些属性也需要使用 <code>Property</code> 的方式设置到 DOM 元素上，例如 <code>innerHTML</code> 和 <code>textContent</code> 等等。</p> <p>刚才我们讲解了为什么同样是写在标签上的属性，却要区分对待的原因，接下来我们进入正题，开始完成将属性应用到 DOM 元素上的实现，到目前为止，我们已经为 <code>VNodeData</code> 设计了三个属性，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
      style<span class="token operator">:</span> <span class="token operator">...</span><span class="token punctuation">,</span> <span class="token comment">// 内联样式数据</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token operator">...</span><span class="token punctuation">,</span> <span class="token comment">// class 数据</span>
      target<span class="token operator">:</span> <span class="token operator">...</span> <span class="token comment">// Portal 的挂载目标</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>接下来我们还会为 <code>VNodeData</code> 添加更多属性，用来存储标签的数据，如下 <code>input</code> 标签所示：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cls-a<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span> <span class="token attr-name">custom</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    </code></pre></div><p>它有四个属性，我们打算在 <code>VNodeData</code> 中存储其属性名以及数据：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'cls-a'</span><span class="token punctuation">,</span>
      type<span class="token operator">:</span> <span class="token string">'checkbox'</span><span class="token punctuation">,</span>
      checked<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      custom<span class="token operator">:</span> <span class="token string">'1'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>如上代码所示，我们已经实现了关于 <code>class</code>、<code>style</code> 的处理，所以接下来我们要处理的就是 <code>VNodeData</code> 中除 <code>class</code> 和 <code>style</code> 之外的全部数据，当然也要排除 <code>VNodeData</code> 中的 <code>target</code> 属性，因为它只用于 <code>Portal</code>。处理方式很简单，我们为 <code>mountElement</code> 函数添加如下高亮代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> domPropsRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\[A-Z]|^(?:value|checked|selected|muted)$</span><span class="token regex-delimiter">/</span></span>
    <span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    
      <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> data<span class="token punctuation">.</span>style<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span>
            <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
              el<span class="token punctuation">.</span>className <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
              <span class="token keyword">break</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>domPropsRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当作 DOM Prop 处理</span>
                el<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当作 Attr 处理</span>
                el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上高亮代码所示，我们首先创建了一个正则表达式 <code>domPropsRE</code>，用来检测那些应该以 <code>Property</code> 的方式添加到 DOM 元素上的属性，其他的属性使用 <code>setAttribute</code> 方法设置。另外我们注意到正则 <code>domPropsRE</code> 除了用来匹配我们前面说过的固定的几个属性之外，它还能匹配那些拥有大写字母的属性，这是为了匹配诸如 <code>innerHTML</code>、<code>textContent</code> 等属性设计的，同时这也顺便实现了一个特性，即拥有大写字母的属性我们都会采用 <code>el[key] = xxx</code> 的方式将其添加到 DOM 元素上。</p> <p>如下是渲染上面 <code>input</code> 标签的效果图：</p> <p><img src="./渲染器的挂载_files/mount-element-attr-prop.876ad25d.png" alt="" class="medium-zoom-image"></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/821421zvp8" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/821421zvp8<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="事件的处理"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86" class="header-anchor">#</a> 事件的处理</h3> <p>现在我们只剩下为 DOM 元素添加事件了，实际上在 <code>mount</code> 阶段为 DOM 元素添加事件很容易，我们只需要在元素对象上调用 <code>addEventListener</code> 方法即可，关键在于我们的 <code>VNodeData</code> 要如何设计。</p> <p>通常我们给元素添加事件的规则是<strong>使用 <code>v-on</code> 或 <code>@</code> 符号加上事件名字</strong>，例如给元素添加点击事件：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handler<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    </code></pre></div><p>当然事件名字中不包含 <code>'on'</code> 前缀，即 <code>click</code> 而不是 <code>onclick</code>，我们可以用如下 <code>VNode</code> 对象来描述如上模板：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      click<span class="token operator">:</span> handler
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>然而这么做是有问题的，如上代码所示 <code>elementVNode</code> 的 <code>VNodeData</code> 中的 <code>click</code> 属性没办法与其他DOM属性区分，所以渲染器并不知道 <code>click</code> 属性代表的是事件，当然我们可以做出规定，例如我们规定 <code>VNodeData</code> 中的 <code>click</code> 属性是个特殊的属性，它用来存储事件回调函数，但这是很笨的方法，因为 DOM 原生事件很多，这种方案需要我们一一列举所有 DOM 事件并且扩展性很差。所以我们需要考虑如何将事件与属性区分，其实我们就沿用原生 DOM 对象的设计即可，在原生 DOM 对象中所有事件函数的名字都是 <code>'on' + 事件名称</code> 的形式，所以我们可以在 <code>VNodeData</code> 中使用 <code>onclick</code> 代替 <code>click</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      onclick<span class="token operator">:</span> handler
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </code></pre></div><p>当然从模板到 <code>VNodeData</code> 的这个变化是由编译器来做的，这样设计之后我们就可以很容易地区分 <code>VNodeData</code> 中的某个属性是 DOM 属性还是 DOM 事件：<strong>只需要检测属性名的前两个字符是不是 <code>'on'</code> 即可</strong>。</p> <p>在区分出事件之后，我们就可以着手将事件添加到 DOM 元素上了，只需调用 <code>el.addEventListener</code> 方法即可，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    
      <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> data<span class="token punctuation">.</span>style<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span>
            <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>isSVG<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                el<span class="token punctuation">.</span>className <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 事件</span>
                el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>domPropsRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当作 DOM Prop 处理</span>
                el<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当作 Attr 处理</span>
                el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上高亮代码所示，我们通过检查 <code>VNodeData</code> 对象的键名(<code>key</code>)的前两个字符是否是 <code>'on'</code>，来区分其是否是事件，如果是事件则调用 <code>el.addEventListener</code> 将事件回调函数添加到元素上。</p> <p>我们可以测试一下我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 事件回调函数</span>
    <span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'click me'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// VNode</span>
    <span class="token keyword">const</span> elementVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      style<span class="token operator">:</span> <span class="token punctuation">{</span>
        width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
        height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
        backgroundColor<span class="token operator">:</span> <span class="token string">'red'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment">// 点击事件</span>
      onclick<span class="token operator">:</span> handler
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    <span class="token function">render</span><span class="token punctuation">(</span>elementVnode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    </code></pre></div><p>其效果如下，当点击红色方块时会触发点击事件执行回调函数：</p> <p><img src="./渲染器的挂载_files/mount-element-event.36e70dcc.png" alt="" class="medium-zoom-image"></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/jzvjwp7p75" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/jzvjwp7p75<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>需要强调的是，在 <code>mount</code> 阶段我们没有考虑事件更新的情况，我们会在讲解 <code>patch</code> 阶段的内容时说明。</p> <h2 id="挂载纯文本、fragment-和-portal"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD%E7%BA%AF%E6%96%87%E6%9C%AC%E3%80%81fragment-%E5%92%8C-portal" class="header-anchor">#</a> 挂载纯文本、Fragment 和 Portal</h2> <h3 id="挂载文本节点"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9" class="header-anchor">#</a> 挂载文本节点</h3> <p>如果一个 <code>VNode</code> 的类型是 <code>VNodeFlags.TEXT</code>，那么 <code>mount</code> 函数会调用 <code>mountText</code> 函数挂载该纯文本元素：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> flags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
      <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载普通标签</span>
        <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载组件</span>
        <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载纯文本</span>
        <span class="token function">mountText</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载 Fragment</span>
        <span class="token function">mountFragment</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载 Portal</span>
        <span class="token function">mountPortal</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p><code>mountText</code> 函数实现起来很简单，由于纯文本类型的 <code>VNode</code> 其 <code>children</code> 属性存储着与之相符的文本字符串，所以只需要调用 <code>document.createTextNode</code> 函数创建一个文本节点即可，然后将其添加到 <code>container</code> 中，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountText</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> el
      container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>我们修改一下之前的 <code>elementVNode</code>，为其添加一个文本子节点：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        style<span class="token operator">:</span> <span class="token punctuation">{</span>
          height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          background<span class="token operator">:</span> <span class="token string">'red'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token string">'我是文本'</span>
    <span class="token punctuation">)</span>
    </code></pre></div><p>使用渲染器渲染如上 <code>elementVnode</code> 的结果如下图所示：</p> <p><img src="./渲染器的挂载_files/mount-text.10e948e2.png" alt="" class="medium-zoom-image"></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/72zq40y0q6" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/72zq40y0q6<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="挂载-fragment"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD-fragment" class="header-anchor">#</a> 挂载 Fragment</h3> <p>其实挂载 <code>Fragment</code> 和单纯地挂载一个 <code>VNode</code> 的 <code>children</code> 是没什么区别的，在没有 <code>Fragment</code> 时我们要想挂载一个片段，这个片段必须使用包裹元素包裹，如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- div 就是包裹元素 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    </code></pre></div><p>有了 <code>Fragment</code> 则不需要包裹元素：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Fragment</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Fragment</span><span class="token punctuation">&gt;</span></span>
    </code></pre></div><p>这两段代码的区别是：<code>&lt;Fragment&gt;</code> 标签不会被渲染为真实DOM，也就不会产生多余的DOM元素，再来观察一下这两个模板片段对应的 <code>VNode</code>：</p> <ul><li>没有 <code>Fragment</code>：</li></ul> <div class="language-js extra-class"><div class="highlight-lines"><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
      flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token string">"div"</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
          tag<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span>
          data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          el<span class="token operator">:</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
          tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
          data<span class="token operator">:</span> <span class="token keyword">null</span>
          childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          el<span class="token operator">:</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    </code></pre></div><ul><li>有 <code>Fragment</code>：</li></ul> <div class="language-js extra-class"><div class="highlight-lines"><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
      flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">,</span>
      tag<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
          tag<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span>
          data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          el<span class="token operator">:</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          flags<span class="token operator">:</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT_HTML</span><span class="token punctuation">,</span>
          tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
          data<span class="token operator">:</span> <span class="token keyword">null</span>
          childFlags<span class="token operator">:</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          el<span class="token operator">:</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
      el<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>通过对比可以很容易地发现，使用包裹元素的模板与 <code>Fragment</code> 唯一的区别就是 <code>elementVNode.flags</code> 和 <code>elementVNode.tag</code> 的不同。在 <code>mount</code> 函数内部，如果一个 <code>VNode</code> 的类型是 <code>Fragment</code> (即 <code>VNodeFlags.FRAGMENT</code>)，则会使用 <code>mountFragment</code> 函数进行挂载，实际上对于 <code>Fragment</code> 类型的 <code>VNode</code> 的挂载，就等价于只挂载一个 <code>VNode</code> 的 <code>children</code>，仅此而已，实现如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFragment</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 拿到 children 和 childFlags</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> children<span class="token punctuation">,</span> childFlags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>childFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 如果是单个子节点，则直接调用 mount</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 如果没有子节点，等价于挂载空片段，会创建一个空的文本节点占位</span>
          <span class="token keyword">const</span> placeholder <span class="token operator">=</span> <span class="token function">createTextVNode</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
          <span class="token function">mountText</span><span class="token punctuation">(</span>placeholder<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 多个子节点，遍历挂载之</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>逻辑非常简单，既然只需要挂载 <code>children</code>，那么就必须拿到 <code>children</code> 才行，顺便拿到 <code>children</code> 的类型 <code>childFlags</code>，然后根据不同的类型采用不同的挂载方式，其本质就是递归地调用 <code>mount</code> 函数进行挂载。</p> <p>我们可以修改 <code>elementVnode</code>，让它的子节点是一个 <code>Fragment</code>。 如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        style<span class="token operator">:</span> <span class="token punctuation">{</span>
          height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          background<span class="token operator">:</span> <span class="token string">'red'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是标题1......'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是标题2......'</span><span class="token punctuation">)</span>
      <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
    </code></pre></div><p>最终的渲染效果如下图所示：</p> <p><img src="./渲染器的挂载_files/mount-fragment.82152fec.png" alt="" class="medium-zoom-image"></p> <p>另外对于 <code>Fragment</code> 类型的 <code>VNode</code> 来说，当它被渲染为真实DOM之后，其 <code>el</code> 属性的引用是谁呢？这需要根据片段中节点的数量来决定，如果只有一个节点，那么 <code>el</code> 属性就指向该节点；如果有多个节点，则 <code>el</code> 属性值是第一个节点的引用；如果片段中没有节点，即空片段，则 <code>el</code> 属性引用的是占位的空文本节点元素，所以我们需要为 <code>mountFragment</code> 函数增加三句代码，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFragment</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> children<span class="token punctuation">,</span> childFlags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>childFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
          <span class="token comment">// 单个子节点，就指向该节点</span>
          vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> children<span class="token punctuation">.</span>el
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token keyword">const</span> placeholder <span class="token operator">=</span> <span class="token function">createTextVNode</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
          <span class="token function">mountText</span><span class="token punctuation">(</span>placeholder<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token comment">// 没有子节点指向占位的空文本节点</span>
          vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> placeholder<span class="token punctuation">.</span>el
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 多个子节点，指向第一个子节点</span>
          vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>那么这样设计有什么意义呢？这是因为在 <code>patch</code> 阶段对DOM元素进行移动时，应该确保将其放到正确的位置，而不应该始终使用 <code>appendChild</code> 函数，有时需要使用 <code>insertBefore</code> 函数，这时候我们就需要拿到相应的节点引用，这时候 <code>vnode.el</code> 属性是必不可少的，就像上面的代码中即使 <code>Fragment</code> 没有子节点我们依然需要一个占位的空文本节点作为位置的引用。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/109r8nlwk4" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/109r8nlwk4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="挂载-portal"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD-portal" class="header-anchor">#</a> 挂载 Portal</h3> <p>实际上 <code>Portal</code> 可以不严谨地认为是<strong>可以被到处挂载的 <code>Fragment</code></strong>。类型为 <code>Fragment</code> 的 <code>VNode</code> 其 <code>tag</code> 属性值为 <code>null</code>，而类型是 <code>Portal</code> 的 <code>VNode</code> 其 <code>tag</code> 属性值为挂载点(选择器或真实DOM元素)。实现 <code>Portal</code> 的关键是要将其 <code>VNode</code> 的 <code>children</code> 中所包含的子 <code>VNode</code> 挂载到 <code>tag</code> 属性所指向的挂载点，<code>mountPortal</code> 函数的实现如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountPortal</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> tag<span class="token punctuation">,</span> children<span class="token punctuation">,</span> childFlags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
    
      <span class="token comment">// 获取挂载点</span>
      <span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span> <span class="token operator">:</span> tag
    
      <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将 children 挂载到 target 上，而非 container</span>
        <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 将 children 挂载到 target 上，而非 container</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上代码所示，挂载 <code>Portal</code> 的关键是我们需要通过 <code>vnode.tag</code> 获取到真正的挂载点，也就是 <code>target</code>，真正挂载时使用此挂载点代替 <code>container</code> 即可。</p> <p>那么对于 <code>Portal</code> 类型的 <code>VNode</code> 其 <code>el</code> 属性应该指向谁呢？应该指向挂载点元素吗？实际上虽然 <code>Portal</code> 所描述的内容可以被挂载到任何位置，但仍然需要一个占位元素，并且 <code>Portal</code> 类型的 <code>VNode</code> 其 <code>el</code> 属性应该指向该占位元素，为什么这么设计呢？这是因为 <code>Portal</code> 的另外一个特性：<strong>虽然 <code>Portal</code> 的内容可以被渲染到任意位置，但它的行为仍然像普通的DOM元素一样，如事件的捕获/冒泡机制仍然按照代码所编写的DOM结构实施</strong>。要实现这个功能就必须需要一个占位的DOM元素来承接事件。但目前来说，我们用一个空的文本节点占位即可，我们为 <code>mountPortal</code> 函数添加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountPortal</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> tag<span class="token punctuation">,</span> children<span class="token punctuation">,</span> childFlags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
      <span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span> <span class="token operator">:</span> tag
      <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childFlags <span class="token operator">&amp;</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">MULTIPLE_VNODES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    
      <span class="token comment">// 占位的空文本节点</span>
      <span class="token keyword">const</span> placeholder <span class="token operator">=</span> <span class="token function">createTextVNode</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
      <span class="token comment">// 将该节点挂载到 container 中</span>
      <span class="token function">mountText</span><span class="token punctuation">(</span>placeholder<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token comment">// el 属性引用该节点</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> placeholder<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
    </code></pre></div><p>如上高亮代码所示，我们创建了一个空文本节点，并将它挂载到 <code>container</code> 下(<strong>注意不是挂载到 <code>target</code> 下</strong>)，最后让 <code>Portal</code> 类型的 <code>VNode</code> 节点的 <code>el</code> 属性引用该空文本节点。</p> <p>为了测试我们的代码，我们修改 <code>elementVNode</code> 如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> elementVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        style<span class="token operator">:</span> <span class="token punctuation">{</span>
          height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
          background<span class="token operator">:</span> <span class="token string">'red'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">h</span><span class="token punctuation">(</span>Portal<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#portal-box'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是标题1......'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是标题2......'</span><span class="token punctuation">)</span>
      <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
    </code></pre></div><p>使用渲染器渲染该 <code>elementVNode</code> 的效果图如下：</p> <p><img src="./渲染器的挂载_files/mount-portal.835104ff.png" alt="" class="medium-zoom-image"></p> <p>可以发现 <code>Portal</code> 的挂载点是 <code>#portal-box</code>，而非 <code>#app</code>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/nr16wzln8m" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/nr16wzln8m<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="有状态组件的挂载和原理"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E5%8E%9F%E7%90%86" class="header-anchor">#</a> 有状态组件的挂载和原理</h2> <p>我们在“组件的本质”一章中讲到过：<strong>组件的产出是 <code>VNode</code></strong>，当时我们也大致实现了有状态组件的挂载，其思路是<strong>拿到组件产出的 <code>VNode</code>，并将之挂载到正确的 <code>container</code> 中</strong>，思路很简单，我们着手实现。</p> <p>回顾一下我们的 <code>mount</code> 函数，如下高亮代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> flags <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
      <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载普通标签</span>
        <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载组件</span>
        <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载纯文本</span>
        <span class="token function">mountText</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载 Fragment</span>
        <span class="token function">mountFragment</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 挂载 Portal</span>
        <span class="token function">mountPortal</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>当 <code>VNode</code> 的 <code>flags</code> 的值属于组件时(<code>VNodeFlags.COMPONENT</code>)，则会调用 <code>mountComponent</code> 函数挂载该 <code>VNode</code>，但是组件还分为有状态组件和函数式组件，所以在 <code>mountComponent</code> 函数内部，我们需要再次对组件的类型进行区分，并使用不同的挂载方式，如下是 <code>mountComponent</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>道理很简单，我们通过检查 <code>vnode.flags</code> 判断要挂载的 <code>VNode</code> 是否属于有状态组件(即 <code>VNodeFlags.COMPONENT_STATEFUL</code>)，如果该 <code>VNode</code> 描述的是有状态组件则调用 <code>mountStatefulComponent</code> 函数挂载，否则将该 <code>VNode</code> 当作函数式组件的描述，使用 <code>mountFunctionalComponent</code> 挂载。</p> <p>挂载一个有状态组件只需要四步，如下是 <code>mountStatefulComponent</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 创建组件实例</span>
      <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 渲染VNode</span>
      instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
      instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
    </code></pre></div><ul><li>第一步：创建组件实例</li></ul> <p>如果一个 <code>VNode</code> 描述的是有状态组件，那么 <code>vnode.tag</code> 属性值就是组件类的引用，所以通过 <code>new</code> 关键字创建组件实例。</p> <ul><li>第二步：获取组件产出的 <code>VNode</code></li></ul> <p>一个组件的核心就是其 <code>render</code> 函数，通过调用 <code>render</code> 函数可以拿到该组件要渲染的内容。</p> <ul><li>第三步：<code>mount</code> 挂载</li></ul> <p>既然已经拿到了 <code>VNode</code>，那么就将其挂载到 <code>container</code> 上就可以了。</p> <ul><li>第四步：让组件实例的 <code>$el</code> 属性和 <code>vnode.el</code> 属性的值引用组件的根DOM元素</li></ul> <p>组件的 <code>render</code> 函数会返回该组件产出的 <code>VNode</code>，当该 <code>VNode</code> 被挂载为真实DOM之后，就可以通过 <code>instance.$vnode.el</code> 元素拿到组件的根DOM元素，接着我们就可以让组件实例的 <code>$el</code> 属性和 <code>vnode.el</code> 属性的值都引用该DOM元素。如果组件的 <code>render</code> 返回的是一个片段(<code>Fragment</code>)，那么 <code>instance.$el</code> 和 <code>vnode.el</code> 引用的就是该片段的第一个DOM元素。</p> <p>我们来测试一下我们的代码，假设我们要渲染的 <code>VNode</code> 如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// h 函数的第一个参数是组件类</span>
    <span class="token keyword">const</span> compVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span>
    <span class="token function">render</span><span class="token punctuation">(</span>compVnode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    </code></pre></div><p>如下是组件 <code>MyComponent</code> 组件的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>
          <span class="token string">'div'</span><span class="token punctuation">,</span>
          <span class="token punctuation">{</span>
            style<span class="token operator">:</span> <span class="token punctuation">{</span>
              background<span class="token operator">:</span> <span class="token string">'green'</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">[</span>
            <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是组件的标题1......'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是组件的标题2......'</span><span class="token punctuation">)</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>该组件的 <code>render</code> 函数返回了它要渲染的内容，如下是使用渲染器渲染后的效果：</p> <p><img src="./渲染器的挂载_files/mount-stateful-comp.75876604.png" alt="" class="medium-zoom-image"></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/2on8xyk01y" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/2on8xyk01y<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>这里再次强调一下，这就是<strong>有状态组件的挂载原理</strong>，仅此而已。有的同学可能会产生疑惑，比如这里没有体现生命周期呀，也没有体现 <code>data</code>、<code>props</code>、<code>ref</code> 或者 <code>slots</code> 等等，实际上我们早在“组件的本质”一章中就提到过<strong>这些内容是在基本原理的基础上，再次设计的产物，它们为 <code>render</code> 函数生成 <code>VNode</code> 的过程中提供数据来源服务</strong>，而<strong>组件产出 <code>VNode</code> 才是永恒的核心</strong>，所以本节我们重在讲解原理，至于 <code>data</code>、<code>props</code>、<code>ref</code> 等内容属于组件实例的设计，我们会在后续的章节中统一讲解。</p> <h2 id="函数式组件的挂载和原理"><a href="http://interview.poetries.top/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E5%8E%9F%E7%90%86" class="header-anchor">#</a> 函数式组件的挂载和原理</h2> <p>函数式组件就更加简单了，它就是一个返回 <code>VNode</code> 的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">MyFunctionalComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 返回要渲染的内容描述，即 VNode</span>
      <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>
        <span class="token string">'div'</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          style<span class="token operator">:</span> <span class="token punctuation">{</span>
            background<span class="token operator">:</span> <span class="token string">'green'</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span>
          <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是组件的标题1......'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'我是组件的标题2......'</span><span class="token punctuation">)</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    </code></pre></div><p>在挂载函数式组件的时候，比挂载有状态组件少了一个实例化的过程，如果一个 <code>VNode</code> 描述的是函数式组件，那么其 <code>tag</code> 属性值就是该函数的引用，如下：</p> <p>如下是 <code>mountFunctionalComponent</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取 VNode</span>
      <span class="token keyword">const</span> $vnode <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// el 元素引用该组件的根元素</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
    </code></pre></div><p>我们来测试一下我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> compVnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComponent<span class="token punctuation">)</span>
    <span class="token function">render</span><span class="token punctuation">(</span>compVnode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    </code></pre></div><p>最终的渲染效果如下：</p> <p><img src="./渲染器的挂载_files/mount-functional-comp.3208eb1c.png" alt="" class="medium-zoom-image"></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/02nrpqkvv" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/02nrpqkvv<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>实际上如果对于 <strong>有状态组件</strong> 和 <strong>函数式组件</strong> 具体的区别不太了解的同学看到这里或许会产生疑问，觉得 <strong>有状态组件</strong> 的实例化很多余，实际上实例化是必须的，因为 <strong>有状态组件</strong> 在实例化的过程中会初始化一系列 <strong>有状态组件</strong> 所特有的东西，诸如 <code>data(或state)</code>、<code>computed</code>、<code>watch</code>、生命周期等等。而函数式组件只有 <code>props</code> 和 <code>slots</code>，它要做的工作很少，所以性能上会更好。具体的关于本地数据、<code>props</code> 数据，计算属性，插槽等的设计和实现，我们在后面的章节中统一讲解，这里给大家展示的就是最根本的原理。</p></div> 
<!-- 渲染器patch -->
<div class="content__default"><blockquote><p>在上一章中我们讲解并实现了渲染器的挂载逻辑，本质上就是将各种类型的 <code>VNode</code> 渲染成真实DOM的过程。渲染器除了将全新的 <code>VNode</code> 挂载成真实DOM之外，它的另外一个职责是负责对新旧 <code>VNode</code> 进行比对，并以合适的方式更新DOM，也就是我们常说的 <code>patch</code>。本章内容除了让你了解基本的比对逻辑之外，还讲述了在新旧 <code>VNode</code> 比对的过程中应该遵守怎样的原则，让我们开始吧！</p></blockquote> <h2 id="基本原则"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99" class="header-anchor">#</a> 基本原则</h2> <p>通常重渲染(<code>re-render</code>)是由组件的更新开始的，因为在框架的使用层面开发者通过变更数据状态从而引起框架内部对UI的自动更新，但是组件的更新本质上还是对真实DOM的更新，或者说是对标签元素的更新，所以我们就优先来看一下如何更新一个标签元素。</p> <p>我们首先回顾一下渲染器的代码，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> container<span class="token punctuation">.</span>vnode
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 没有旧的 VNode，使用 `mount` 函数挂载全新的 VNode</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了</span>
      container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> vnode
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 有旧的 VNode，则调用 `patch` 函数打补丁</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
      <span class="token comment">// 更新 container.vnode</span>
      container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> vnode
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。</span>
      container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      container<span class="token punctuation">.</span>vnode <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮的两句代码所示，当使用 <code>render</code> 渲染器渲染一个全新的 <code>VNode</code> 时，会调用 <code>mount</code> 函数挂载该 <code>VNode</code>，同时让容器元素存储对该 <code>VNode</code> 对象的引用，这样当再次调用渲染器渲染新的 <code>VNode</code> 对象到相同的容器元素时，由于旧的 <code>VNode</code> 已经存在，所以会调用 <code>patch</code> 函数以合适的方式进行更新，如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span>

<span class="token comment">// 第一次渲染 VNode 到 #app，此时会调用 mount 函数</span>
<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 第二次渲染新的 VNode 到相同的 #app 元素，此时会调用 patch 函数</span>
<span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><code>patch</code> 函数会对新旧 <code>VNode</code> 进行比对，也就是我们所说的 <code>diff</code>，那么不同的两个 <code>VNode</code> 之间应该遵守怎样的比对规则呢？其实这个问题很容易回答，我们知道 <code>VNode</code> 有类型之分，不同类型的 <code>VNode</code> 之间存在一定的差异，所以不同的 <code>VNode</code> 之间第一个比对原则就是：<strong>只有相同类型的 <code>VNode</code> 才有比对的意义</strong>，例如我们有两个 <code>VNode</code>，其中一个 <code>VNode</code> 的类型是标签元素，而另一个 <code>VNode</code> 的类型是组件，当这两个 <code>VNode</code> 进行比对时，最优的做法是<strong>使用新的 <code>VNode</code> 完全替换旧的 <code>VNode</code></strong>，换句话说我们根本就没有做任何比对的操作，因为这完全没有意义，所以根据这个思想我们实现的 <code>patch</code> 函数如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 分别拿到新旧 VNode 的类型，即 flags</span>
  <span class="token keyword">const</span> nextFlags <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>flags
  <span class="token keyword">const</span> prevFlags <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>flags

  <span class="token comment">// 检查新旧 VNode 的类型是否相同，如果类型不同，则直接调用 replaceVNode 函数替换 VNode</span>
  <span class="token comment">// 如果新旧 VNode 的类型相同，则根据不同的类型调用不同的比对函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevFlags <span class="token operator">!==</span> nextFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchElement</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchComponent</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchText</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchFragment</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchPortal</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，既然 <code>patch</code> 函数的作用是用来比对新旧 <code>VNode</code>，那么 <code>patch</code> 函数必然需要接收新旧 <code>VNode</code> 作为参数，我们使用 <code>prevVNode</code> 形参代表旧的 <code>VNode</code>，使用 <code>nextVNode</code> 形参代表新的 <code>VNode</code>，如上是很清晰的一段比对逻辑，首先我们需要拿到新旧 <code>VNode</code> 的类型(<code>flags</code>)，接着是一连串的 <code>if...else if</code> 语句，其核心原则是：<strong>如果类型不同，则直接调用 <code>replaceVNode</code> 函数使用新的 <code>VNode</code> 替换旧的 <code>VNode</code>，否则根据不同的类型调用与之相符的比对函数</strong>，如下图所示：</p> <p><img src="./渲染器patch_files/flags-patch.6d43f459.png" alt="" class="medium-zoom-image"></p> <h2 id="替换-vnode"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%BF%E6%8D%A2-vnode" class="header-anchor">#</a> 替换 VNode</h2> <p>我们首先来研究一下如何替换 <code>VNode</code>，即 <code>replaceVNode</code> 函数应该做什么，我们先来复现需要替换 <code>VNode</code> 的场景，如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode 是一个 div 标签</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧的 VNode'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新的 VNode'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新的 VNode 是一个组件</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span>

<span class="token comment">// 先后渲染新旧 VNode 到 #app</span>
<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在如上代码中，我们先后渲染了新旧 <code>VNode</code> 到 <code>#app</code> 元素，由于新旧 <code>VNode</code> 具有不同的类型，所以此时会触发 <code>VNode</code> 的替换操作，替换操作并不复杂，本质就是<strong>把旧的 <code>VNode</code> 所渲染的DOM移除，再挂载新的 <code>VNode</code></strong>，如下是 <code>replaceVNode</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将旧的 VNode 所渲染的 DOM 从容器中移除</span>
  container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 再把新的 VNode 挂载到容器中</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/jlxjk18vm5" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/jlxjk18vm5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>看上去很简单，但实际上仅有这两行代码的话，是存在缺陷的。至于有何缺陷我们会在本章的后面讲解，因为目前我们的背景铺垫还不够。</p> <h2 id="更新标签元素"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0" class="header-anchor">#</a> 更新标签元素</h2> <h3 id="更新标签元素的基本原则"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99" class="header-anchor">#</a> 更新标签元素的基本原则</h3> <p>当新旧 <code>VNode</code> 的类型不同时，会调用 <code>replaceVNode</code> 函数直接使用新的 <code>VNode</code> 替换旧的 <code>VNode</code>。但如果新旧 <code>VNode</code> 的类型相同，则会根据不同的类型调用不同的比对函数，这一小节我们就来看看如何更新一个标签元素。</p> <p>首先即使两个 <code>VNode</code> 的类型同为标签元素，但它们也可能是不同的标签，也就是说它们的 <code>tag</code> 属性值不尽相同。这就又引申出了一条更新原则：<strong>我们认为不同的标签渲染的内容不同</strong>，例如 <code>ul</code> 标签下只能渲染 <code>li</code> 标签，所以拿 <code>ul</code> 标签和一个 <code>div</code> 标签进行比对是没有任何意义的，这种情况下我们不会对旧的标签元素打补丁，而是使用新的标签元素替换旧的标签元素，这就需要用到我们前面讲过的 <code>replaceVNode</code> 函数，如下 <code>patchElement</code> 函数所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么如果新旧 <code>VNode</code> 描述的是相同的标签呢？如果标签相同，那两个 <code>VNode</code> 之间的差异就只会出现在 <code>VNodeData</code> 和 <code>children</code> 上了，所以对于描述相同标签的两个 <code>VNode</code> 之间的比对，本质上就是对 <code>VNodeData</code> 和 <code>children</code> 的比对，我们先来看一下如何更新 <code>VNodeData</code>，如下面两个 <code>VNode</code> 所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  style<span class="token operator">:</span> <span class="token punctuation">{</span>
    width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    backgroundColor<span class="token operator">:</span> <span class="token string">'red'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  style<span class="token operator">:</span> <span class="token punctuation">{</span>
    width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
    border<span class="token operator">:</span> <span class="token string">'1px solid green'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如上代码所示，新旧 <code>VNode</code> 描述的都是 <code>div</code> 标签，但是他们拥有不同的样式，旧的 <code>VNode</code> 描述的是一个红色背景的 <code>div</code>，而新的 <code>VNode</code> 描述的是拥有绿色边框的 <code>div</code>，如果仅针对这个案例而言，我们的更新规则应该是：<strong>先将红色背景从元素上移除，再为元素添加绿色边框</strong>。如果我们把问题的解决方案宏观化，就变成了：<strong>将新的 VNodeData 全部应用到元素上，再把那些已经不存在于新的 <code>VNodeData</code> 上的数据从元素上移除</strong>，根据这个思想，我们为 <code>patchElement</code> 函数增加如下高亮的代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 拿到 新旧 VNodeData</span>
  <span class="token keyword">const</span> prevData <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>data
  <span class="token keyword">const</span> nextData <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
  <span class="token comment">// 新的 VNodeData 存在时才有必要更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历新的 VNodeData</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 根据 key 拿到新旧 VNodeData 值</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">const</span> nextValue <span class="token operator">=</span> nextData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
          <span class="token comment">// 遍历新 VNodeData 中的 style 数据，将新的样式应用到元素</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 遍历旧 VNodeData 中的 style 数据，将已经不存在于新的 VNodeData 的数据移除</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextValue<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们在更新 <code>VNodeData</code> 时的思路分为以下几步：</p> <ul><li>第 1 步：当新的 <code>VNodeData</code> 存在时，遍历新的 <code>VNodeData</code>。</li> <li>第 2 步：根据新 <code>VNodeData</code> 中的 <code>key</code>，分别尝试读取旧值和新值，即 <code>prevValue</code> 和 <code>nextValue</code>。</li> <li>第 3 步：使用 <code>switch...case</code> 语句匹配不同的数据进行不同的更新操作</li></ul> <p>以样式(<code>style</code>)的更新为例，如上代码所展示的更新过程是：</p> <ul><li>1 ：遍历新的样式数据(<code>prevValue</code>)，将新的样式数据全部应用到元素上</li> <li>2 ：遍历旧的样式数据(<code>nextValue</code>)，将那些已经不存在于新的样式数据中的样式从元素上移除，最终我们完成了元素样式的更新。</li></ul> <p>这个过程实际上就是更新标签元素的基本规则。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/9l2mxjkw14" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/9l2mxjkw14<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="更新-vnodedata"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0-vnodedata" class="header-anchor">#</a> 更新 VNodeData</h3> <p>观察我们在 <code>patchElement</code> 函数中用来更新样式的代码，大家有没有注意到似曾相识？没错，这段代码与 <code>mountElement</code> 函数内用来处理 <code>VNodeData</code> 的代码非常相似，这就指导我们封装一个函数用来统一处理 <code>VNodeData</code>，实际上无论是 <code>mountElement</code> 函数中用来处理 <code>VNodeData</code> 的代码还是 <code>patchElement</code> 函数中用来处理 <code>VNodeData</code> 的代码，它们的本质都是将 <code>VNodeData</code> 中的数据应用到 DOM 元素上，唯一的区别就是在 <code>mountElement</code> 函数中没有“旧”数据可言，而在 <code>patchElement</code> 函数中既有旧数据也有新数据，所以我们完全可以封装一个叫做 <code>patchData</code> 的函数，该函数接收新旧数据作为参数，对于 <code>mountElement</code> 函数来讲，由于它没有旧数据可言，所以在调用 <code>patchData</code> 函数时只需要传递 <code>null</code> 作为旧数据即可。</p> <p>我们先来使用 <code>patchData</code> 函数修改 <code>patchElement</code> 函数的代码，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token keyword">const</span> prevData <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>data
  <span class="token keyword">const</span> nextData <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data

  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">const</span> nextValue <span class="token operator">=</span> nextData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevValue <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nextData<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第四个参数为 null，代表移除数据</span>
        <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，使用 <code>patchData</code> 函数改写之后的代码变得较之前简洁了许多，核心思想没有变，仍然是：<strong>遍历新的 <code>VNodeData</code>，将旧值和新值都传递给 <code>patchData</code> 函数，并由 <code>patchData</code> 函数负责更新数据；同时也需要遍历旧的 <code>VNodeData</code>，将已经不存在于新的 <code>VNodeData</code> 中的数据从元素上移除</strong>，所以我们可以看到在遍历旧 <code>VNodeData</code> 时如果没有旧数据，或者虽然有旧数据但旧数据已经不存在于新数据上了，这时我们传递给 <code>patchData</code> 函数的第四个参数为 <code>null</code>，意味着将该数据从元素上移除。如下是 <code>patchData</code> 函数的实现，本质就是把原来 <code>patchElement</code> 函数中的 <code>switch</code> 语句块移动到了 <code>patchData</code> 函数中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patchData</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
      <span class="token comment">// 将新的样式数据应用到元素</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 移除已经不存在的样式</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextValue<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然以上 <code>patchData</code> 函数中的代码只包含对于样式(<code>style</code>)数据的处理，实际上我们可以把上一章中 <code>mountElement</code> 函数中完整的用来处理 <code>VNodeData</code> 数据的代码拷贝到 <code>patchData</code> 函数中，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patchData</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextValue<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span>style<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
      el<span class="token punctuation">.</span>className <span class="token operator">=</span> nextValue
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 事件</span>
        el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>domPropsRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 DOM Prop 处理</span>
        el<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 Attr 处理</span>
        el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样 <code>patchData</code> 函数就能够用来处理 <code>style</code>、<code>class</code>、<code>DOM Prop</code> 以及 <code>Attr</code> 的更新操作，并且可以同时满足 <code>mountElement</code> 和 <code>patchElement</code> 的需求。但 <code>patchData</code> 函数还不能够满足事件的更新操作，因为当新的 <code>VNodeData</code> 中已经不包含某个事件时，我们需要将旧的事件回调函数移除，解决办法很简单，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patchData</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
      <span class="token comment">// 省略处理样式的代码...</span>
    <span class="token keyword">case</span> <span class="token string">'class'</span><span class="token operator">:</span>
      <span class="token comment">// 省略处理 class 的代码...</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 事件</span>
        <span class="token comment">// 移除旧事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prevValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 添加新事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>domPropsRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 DOM Prop 处理</span>
        el<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextValue
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当作 Attr 处理</span>
        el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，如果旧的事件回调函数存在，我们先将其从 DOM 元素上移除，接着如果新的事件回调函数存在我们再将其添加到 DOM 元素中。至此我们的 <code>patchData</code> 函数就算大功告成了。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/wk8pl46o18" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/wk8pl46o18<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="更新子节点"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9" class="header-anchor">#</a> 更新子节点</h3> <p>当 <code>VNodeData</code> 更新完成之后，对于新旧两个标签来说，就剩下子节点的差异了，所以我们在 <code>patchElement</code> 函数中最后一步需要做的事情就是递归地更新子节点，如下高亮的代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token keyword">const</span> prevData <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>data
  <span class="token keyword">const</span> nextData <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data

  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> nextData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">const</span> nextValue <span class="token operator">=</span> nextData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> prevData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevValue <span class="token operator">=</span> prevData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevValue <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nextData<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第四个参数为 null，代表移除数据</span>
        <span class="token function">patchData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> prevValue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 调用 patchChildren 函数递归地更新子节点</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 旧的 VNode 子节点的类型</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 新的 VNode 子节点的类型</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 旧的 VNode 子节点</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 新的 VNode 子节点</span>
    el                    <span class="token comment">// 当前标签元素，即这些子节点的父节点</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在 <code>patchElement</code> 函数的最后调用了 <code>patchChildren</code> 函数，<code>patchChildren</code> 函数的作用就是对新旧 <code>VNode</code> 的子节点进行<strong>同层级</strong>的比较，它接收五个参数，前四个参数分别是新旧 <code>VNode</code> 子节点以及子节点的类型，第五个参数 <code>el</code> 是这些子节点的父节点，也就是当前被更新的标签元素。</p> <p>在开始实现同层级子节点的更新之前，需要根据我们目前掌握的知识思考一下应该如何做，<strong>思路是能够写出代码的原因</strong>。我们观察如下两个 <code>div</code> 标签的子节点，我们用 <code>VNode</code> 来表示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
</code></pre></div><p>如上代码所示， <code>prevVNode</code> 所描述的 <code>div</code> 标签只有一个子节点，所以 <code>prevVNode</code> 的子节点类型应该是 <code>ChildrenFlags.SINGLE_VNODE</code>，而 <code>nextVNode</code> 所描述的 <code>div</code> 标签没有子节点，所以 <code>nextVNode</code> 的子节点类型应该是 <code>ChildrenFlags.NO_CHILDREN</code>。如果单纯地看这个例子，我们应该如何更新呢？很简单，我们只需要把 <code>prevVNode</code> 的子节点移除即可。再来看下面的两个 <code>VNode</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这个例子与之前的例子恰好相反，<code>prevVNode</code> 没有子节点而 <code>nextVNode</code> 有一个子节点，所以 <code>prevVNode</code> 和 <code>nextVNode</code> 的子节点的类型分别是 <code>ChildrenFlags.NO_CHILDREN</code> 和 <code>ChildrenFlags.SINGLE_VNODE</code>，这时我们的更新操作也很简单，只需要把 <code>nextVNode</code> 的子节点挂载到 <code>div</code> 标签即可。再来看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在这个例子中，新旧 <code>div</code> 标签都有一个子节点，所以他们的子节点类型相同，这时子节点的更新操作就等价于两个子节点之间的 <code>patch</code>。</p> <p>通过这些例子我们注意到，根据新旧标签的子节点的类型不同，我们可以轻松地找到合适的方式去更新它们，我们在讲解 <code>VNode</code> 的种类时就曾经强调过，<code>VNode</code> 的类型标识在 <code>patch</code> 阶段是非常重要的信息，在这里就体现了出来。</p> <p>但无论是新标签还是旧标签，该标签的子节点都可以分为三种情况：只有一个子节点、没有子节点 以及 有多个子节点。至于一个标签的子节点属于哪种类型是可以通过该标签所对应的 <code>VNode</code> 对象的 <code>childFlags</code> 属性得知的。最终在这个思路的引导下我们就可以编写出 <code>patchChildren</code> 函数，如下代码所示：</p> <div class="language-js {} extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 也是单个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token comment">// 旧的 children 中没有子节点时，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
    <span class="token comment">// 旧的 children 中有多个子节点时，会执行该 case 语句块</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，虽然看上去代码很长，但是很有规律，我们使用了嵌套的 <code>switch...case</code> 语句，外层的 <code>switch...case</code> 语句用来匹配旧的 <code>children</code> 的类型，而内层的 <code>switch...case</code> 语句则用来匹配新的 <code>children</code> 的类型。由于新旧 <code>children</code> 各有三种情况，所以合起来共有九种(<code>3 * 3</code>)情况，根据不同的情况我们所做的操作也会不同。接下来我们逐个实现，当我们把这九种情况下的更新操作全部实现之后，我们的 <code>patchChildren</code> 函数就大功告成了。</p> <p>我们先来看一下当旧的 <code>children</code> 类型为 <code>ChildrenFlags.SINGLE_VNODE</code> 且新的 <code>children</code> 类型也是 <code>ChildrenFlags.SINGLE_VNODE</code> 的情况，即新旧 <code>children</code> 都是单个子节点，我们上面提到过，在这种情况下新旧 <code>children</code> 的比较等价于两个 <code>children(单个子节点)</code>之间的比较，所以只需要递归地调用 <code>patch</code> 函数即可，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 此时 prevChildren 和 nextChildren 都是 VNode 对象</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，只需一行代码即可搞定，我们编写一个案例来测试我们的代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    style<span class="token operator">:</span> <span class="token punctuation">{</span>
      height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      background<span class="token operator">:</span> <span class="token string">'red'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    style<span class="token operator">:</span> <span class="token punctuation">{</span>
      height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      background<span class="token operator">:</span> <span class="token string">'green'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>如上代码所示，新旧 <code>VNode</code> 描述的都是只有一个 <code>p</code> 标签作为子节点的 <code>div</code> 标签，所以新旧 <code>div</code> 标签的 <code>children</code> 类型都是单个子节点，只不过这两个 <code>p</code> 标签拥有不同的背景颜色，然后我们先后调用 <code>render</code> 渲染器渲染了这两个 <code>VNode</code>，最终效果是 <code>p</code> 标签的背景色被正确地更新了。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/m3oqr3knq9" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/m3oqr3knq9<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>接着我们来看一下当旧的 <code>children</code> 类型为 <code>ChildrenFlags.SINGLE_VNODE</code>，而新的 <code>children</code> 类型为 <code>ChildrenFlags.NO_CHILDREN</code> 时的情况，也就是说旧的 <code>children</code> 是单个子节点，而新的 <code>children</code> 为 <code>null</code>，即新的 <code>VNode</code> 没有子节点。在这种情况下我们只需要把旧的子节点移除即可，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 也是单个子节点时，会执行该 case 语句块</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，<code>container</code> 是父级元素，我们调用父级元素的 <code>removeChild</code> 方法将之前渲染好的 <code>prevChildren.el</code> 移除即可，同样只使用了一行代码就实现了功能。不过可能很多同学已经发现了这么做的问题所在，假如 <code>prevChildren</code> 的类型是一个片段的话，那么它可能渲染多个元素到容器中，所以我们需要对片段类型的 <code>VNode</code> 额外处理。但本质不变：<strong>想办法把已经渲染好了的 DOM 元素从页面上移除</strong>。</p> <p>最后我们使用如下例子测试我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
  <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    style<span class="token operator">:</span> <span class="token punctuation">{</span>
      height<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token string">'100px'</span><span class="token punctuation">,</span>
      background<span class="token operator">:</span> <span class="token string">'red'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>上例中 <code>prevVNode</code> 描述的是：以一个红色背景的 <code>p</code> 标签作为子节点的 <code>div</code> 标签，而 <code>nextVNode</code> 是一个没有子节点的 <code>div</code> 标签，接着我们先后渲染了旧的和新的 <code>VNode</code>，最终效果是 <code>p</code> 标签被移除了。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/3roo60w1kp" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/3roo60w1kp<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>接着我们再来看一下当旧的 <code>children</code> 类型为 <code>ChildrenFlags.SINGLE_VNODE</code>，而新的 <code>children</code> 类型为多个子节点时的情况，在这种情况下由于旧的子节点只有一个，而新的子节点有多个，所以我们可以采用<strong>将旧的单个子节点移除，再将新的多个子节点挂载上去</strong>的方案，在这个思路下我们可以做出如下实现，修改我们的 <code>patchChildren</code> 函数：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token function">patch</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 移除旧的单个子节点</span>
          container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token comment">// 遍历新的多个子节点，逐个挂载到容器中</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，实现起来也非常简单，我们使用了与之前一样的方法将旧的单个子节点移除，然后遍历新的多个子节点，并调用 <code>mount</code> 函数逐个将之挂载到容器中。我们可以使用下面的例子测试我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'只有一个子节点'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'子节点 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'子节点 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>

</code></pre></div><p>如上代码所示，旧的 <code>VNode</code> 是一个只有一个子节点的 <code>div</code> 标签，而新的 <code>VNode</code> 是一个拥有多个子节点的 <code>div</code> 标签。最终的效果是旧的单个子节点被移除，新的多个子节点全都被添加上去。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/lpm17161m" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/lpm17161m<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>以上我们讲解并实现了当旧的 <code>children</code> 类型为单个子节点时，所有情况下的更新操作，可以用一张图来总结，如下：</p> <p><img src="./渲染器patch_files/patch-children-1.39272592.png" alt="" class="medium-zoom-image"></p> <p>类似的，当旧的 <code>children</code> 类型为 <code>ChildrenFlags.NO_CHILDREN</code>，即没有子节点时，新的 <code>children</code> 依然可能有三种情况，我们也可以用一张图来表示：</p> <p><img src="./渲染器patch_files/patch-children-2.31ddc8a6.png" alt="" class="medium-zoom-image"></p> <p>我们来解释一下上图的操作：</p> <ul><li>情况一：没有旧的子节点、新的子节点为单个子节点，此时只需要把新的单个子节点添加到容器元素即可。</li> <li>情况二：没有旧的子节点、同时也没有新的子节点，那自然什么都不用做了。</li> <li>情况三：没有旧的子节点、但有多个新的子节点，那把这多个子节点都添加到容器元素即可。</li></ul> <p>基于此，我们可以轻松编写出对应的逻辑，如下 <code>patchChildren</code> 函数所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中没有子节点时，会执行该 case 语句块</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span>
          <span class="token comment">// 使用 mount 函数将新的子节点挂载到容器元素</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span>
          <span class="token comment">// 什么都不做</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token comment">// 遍历多个新的子节点，逐个使用 mount 函数挂载到容器元素</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>

    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/62x41myyrz" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/62x41myyrz<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>现在对于旧的 <code>children</code> 类型来说，我们只剩下最后一种情况没有处理了，就是当旧的 <code>children</code> 类型为多个子节点时，同样的我们来画一张图：</p> <p><img src="./渲染器patch_files/patch-children-3.06453ea2.png" alt="" class="medium-zoom-image"></p> <p>如上图所示，当旧的 <code>children</code> 类型为多个子节点时，新的 <code>children</code> 类型有三种情况，不同的情况采用不同的操作：</p> <ul><li>情况一：有多个旧的子节点，但新的子节点是单个子节点，这时只需要把所有旧的子节点移除，再将新的单个子节点添加到容器元素即可。</li> <li>情况二：有多个旧的子节点，但没有新的子节点，这时只需要把所有旧的子节点移除即可。</li> <li>情况三：新旧子节点都是多个子节点，这时将进入到至关重要的一步，即核心 <code>diff</code> 算法的用武之地。</li></ul> <p>实际上在整个新旧 <code>children</code> 的比对中，只有当新旧子节点都是多个子节点时才有必要进行真正的核心 <code>diff</code>，从而尽可能的复用子节点。</p> <p>对于<strong>情况一</strong>和<strong>情况二</strong>而言，实现起来相当容易，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，对于新的 <code>children</code> 为单个子节点的情况，我们遍历旧的子节点逐个将之从容器元素中移除，并调用 <code>mount</code> 函数将新的子节点挂载到容器元素中，对于新的 <code>children</code> 为没有子节点的情况，我们则直接遍历旧的子节点将其全部从容器元素中移除即可。实际上整个 <code>children</code> 的 <code>patch</code> 过程中，最复杂的当属最后一种情况：<strong>新旧子节点都是多个子节点的情况</strong>，之所以在这种情况下更新操作会变的复杂，是因为我们对“自己”的要求较高，因为假设按照之前的思路我们完全可以采用 <strong>“将旧的子节点全部移除，再将所有新的子节点添加”</strong> 的思路来完成更新，这样事情就会简单许多，不过虽然这么做可以实现最终的目的，但所有 DOM 的更新都毫无复用可言。限于本章的篇幅我们暂时采用简单的办法完成子节点的更新，对于真正的核心 <code>diff</code> 算法我们将会在下一章统一着重讲解，简化版本的实现如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">prevChildFlags<span class="token punctuation">,</span>
  nextChildFlags<span class="token punctuation">,</span>
  prevChildren<span class="token punctuation">,</span>
  nextChildren<span class="token punctuation">,</span>
  container</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>prevChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 旧的 children 中有多个子节点时，会执行该 case 语句块</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextChildFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token comment">// 遍历旧的子节点，将其全部移除</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 遍历新的子节点，将其全部添加</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们先遍历旧的子节点，将其全部从容器元素中移除。然后再遍历新的子节点，并将其全部添加到容器元素中。这样我们就完成了更新的操作，但这里再次强调：我们这么做是限于篇幅，同时为了方便后续案例代码的编写，在下一章中我们将着重讲解<strong>当新旧子节点都是多个子节点时，应该如何尽可能的复用子节点</strong>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/ym6k442lmj" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/ym6k442lmj<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="更新文本节点"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9" class="header-anchor">#</a> 更新文本节点</h2> <p>我们花了很大的篇幅讲解了标签元素的更新，实际上标签元素的确是 DOM 更新中的主要操作，接下来我们讲解一下文本节点的更新。如果新旧两个 <code>VNode</code> 的类型都是纯文本类型，那么在 <code>patch</code> 内部会调用 <code>patchText</code> 函数更新旧的文本节点。文本节点的更新非常简单，如果一个 DOM 元素是文本节点或注释节点，那么可以通过调用该 DOM 对象的 <code>nodeValue</code> 属性读取或设置文本节点(或注释节点)的内容，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建一个文本节点</span>
<span class="token keyword">const</span> textEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>

textEl<span class="token punctuation">.</span>nodeValue  <span class="token comment">// 'a'</span>

textEl<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> <span class="token string">'b'</span>

textEl<span class="token punctuation">.</span>nodeValue  <span class="token comment">// 'b'</span>
</code></pre></div><p>利用这一点我们就可以轻松实现对于文本元素的更新，如下是 <code>patchText</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchText</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到文本元素 el，同时让 nextVNode.el 指向该文本元素</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 只有当新旧文本内容不一致时才有必要更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>children
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>patchText</code> 函数接收新旧 <code>VNode</code> 作为参数，首先我们需要通过旧的 <code>prevVNode.el</code> 属性拿到已经渲染在页面上的文本节点元素，并让 <code>nextVNode.el</code> 指向它。接着由于对纯文本类型的 <code>VNode</code> 而言，它的 <code>children</code> 属性存储的就是其文本内容，所以通过对比新旧文本内容是否一致来决定是否需要更新，只有新旧文本内容不一致时我们才会设置文本节点的 <code>el.nodeValue</code> 属性的值，从而完成文本节点的更新。</p> <p>我们可以使用如下例子测试我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧文本'</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新文本'</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>我们先后创建了两个带有文本子节点的 <code>p</code> 标签，并调用 <code>render</code> 渲染器渲染了旧的 <code>VNode</code> 以及新的 <code>VNode</code>。最终效果是两秒之后文本被更新了。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/73zzzv9xn6" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/73zzzv9xn6<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="更新-fragment"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0-fragment" class="header-anchor">#</a> 更新 Fragment</h2> <p>如果两个 <code>VNode</code> 的类型都是片段，则 <code>patch</code> 函数会调用 <code>patchFragment</code> 函数更新片段的内容。实际上<strong>片段的更新是简化版的标签元素的更新</strong>，我们知道对于标签元素来说更新的过程分为两个步骤：首先需要更新标签本身的 <code>VNodeData</code>，其次更新其子节点。然而由于 <code>Fragment</code> 没有包裹元素，只有子节点，所以我们对 <code>Fragment</code> 的更新本质上就是更新两个片段的“子节点”。</p> <p>如下是 <code>patchFragment</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 直接调用 patchChildren 函数更新 新旧片段的子节点即可</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 旧片段的子节点类型</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 新片段的子节点类型</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 旧片段的子节点</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 新片段的子节点</span>
    container
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，我们直接调用 <code>patchChildren</code> 函数更新新旧片段的子节点即可，但是不要忘记更新 <code>nextVNode.el</code> 属性，就像我们当初实现 <code>mountFragment</code> 时一样，根据子节点的类型不同，<code>VNode</code> 所引用的元素也不同，我们为 <code>patchFragment</code> 添加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchFragment</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 直接调用 patchChildren 函数更新 新旧片段的子节点即可</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 旧片段的子节点类型</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span> <span class="token comment">// 新片段的子节点类型</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 旧片段的子节点</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>   <span class="token comment">// 新片段的子节点</span>
    container
  <span class="token punctuation">)</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
      nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>el
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
      nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们通过检查新的片段的 <code>children</code> 类型，如果新的片段的 <code>children</code> 类型是单个子节点，则意味着其 <code>vnode.children</code> 属性的值就是 <code>VNode</code> 对象，所以直接将 <code>nextVNode.children.el</code> 赋值给 <code>nextVNode.el</code> 即可。如果新的片段没有子节点，我们知道对于没有子节点的片段我们会使用一个空的文本节点占位，而 <code>prevVNode.el</code> 属性引用的就是该空文本节点，所以我们直接通过旧片段的 <code>prevVNode.el</code> 拿到该空文本元素并赋值给新片段的 <code>nextVNode.el</code> 即可。如果新的片段的类型是多个子节点，则 <code>nextVNode.children</code> 是一个 <code>VNode</code> 数组，我们会让新片段的 <code>nextVNode.el</code> 属性引用数组中的第一个元素。实际上这段逻辑与我们在 <code>mountFragment</code> 函数中所实现的逻辑是一致的。</p> <p>我们可以使用下面的例子测试我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧片段子节点 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧片段子节点 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新片段子节点 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新片段子节点 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>如上这段代码中我们创建了旧的和新的两个片段，并先后使用渲染器进行渲染，结果是片段得到了正确的更新。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/1r9k5y1ozq" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/1r9k5y1ozq<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="更新-portal"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9B%B4%E6%96%B0-portal" class="header-anchor">#</a> 更新 Portal</h2> <p>如果两个 <code>VNode</code> 的类型都是 <code>Portal</code>，那么 <code>patch</code> 函数内部会调用 <code>patchPortal</code> 函数进行更新。我们在“渲染器之挂载”一章中曾做出一个不严谨但很直观的比喻：可以把 <code>Portal</code> 当作可以到处挂载的 <code>Fragment</code>。实际上 <code>Portal</code> 的更新与 <code>Fragment</code> 类似，我们需要更新其子节点，但由于 <code>Portal</code> 可以被到处挂载，所以新旧 <code>Portal</code> 的挂载目标可能不同，所以对于 <code>Portal</code> 的更新除了要更新其子节点之外，还要对比新旧挂载目标是否相同，如果新的 <code>Portal</code> 的挂载目标变了我们就需要将 <code>Portal</code> 的内容从旧的容器中搬运到新的容器中。我们首先来更新 <code>Portal</code> 的子节点，如下代码所示，与更新 <code>Fragment</code> 的子节点相同：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">patchPortal</span> <span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>tag <span class="token comment">// 注意容器元素是旧的 container</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 让 nextVNode.el 指向 prevVNode.el</span>
  nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，我们首先调用 <code>patchChildren</code> 函数更新 <code>Portal</code> 的子节点，其中需要注意的是 <code>patchChildren</code> 的第五个参数是旧的挂载容器，也就是说即使新的 <code>Portal</code> 的挂载目标变了，但是在这一步的更新完成之后 <code>Portal</code> 的内容仍然存在于旧的容器中。接着我们将 <code>prevVNode.el</code> 赋值给 <code>nextVNode.el</code>，这一步要比 <code>Fragment</code> 容易的多，因为我们知道对于 <code>Portal</code> 类型的 <code>VNode</code> 来说其 <code>el</code> 属性始终是一个占位的文本节点。</p> <p>在如上这些工作完成之后，我们要思考的问题就是挂载目标了，由于新旧 <code>Portal</code> 的挂载目标可能是不同的，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 挂载目标是 id="box1" 的元素</span>
<span class="token keyword">const</span> prevPortal <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Portal<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#box1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 挂载目标是 id="box2" 的元素</span>
<span class="token keyword">const</span> nextPortal <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>Portal<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#box2'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看到，旧的 <code>Portal</code> 的挂载目标是 <code>id="box1"</code> 的容器元素，而新的 <code>Portal</code> 的挂载目标是 <code>id="box2"</code> 的容器元素。但是由于我们在更新子节点的过程中，传递给 <code>patchChildren</code> 函数的容器元素始终都是旧的容器元素，所以最终结果是：<strong>更新后的子节点也存在于旧的容器中</strong>，所以我们还需要做最后一步工作，就是<strong>把旧容器内的元素都搬运到新容器中</strong>，我们给 <code>patchPortal</code> 函数增加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchPortal</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">patchChildren</span><span class="token punctuation">(</span>
    prevVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    prevVNode<span class="token punctuation">.</span>tag <span class="token comment">// 注意 container 是旧的 container</span>
  <span class="token punctuation">)</span>
  <span class="token comment">// 让 nextVNode.el 指向 prevVNode.el</span>
  nextVNode<span class="token punctuation">.</span>el <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el

  <span class="token comment">// 如果新旧容器不同，才需要搬运</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取新的容器元素，即挂载目标</span>
    <span class="token keyword">const</span> container <span class="token operator">=</span>
      <span class="token keyword">typeof</span> nextVNode<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'string'</span>
        <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
        <span class="token operator">:</span> nextVNode<span class="token punctuation">.</span>tag

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>childFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">SINGLE_VNODE</span><span class="token operator">:</span>
        <span class="token comment">// 如果新的 Portal 是单个子节点，就把该节点搬运到新容器中</span>
        container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> ChildrenFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token operator">:</span>
        <span class="token comment">// 新的 Portal 没有子节点，不需要搬运</span>
        <span class="token keyword">break</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token comment">// 如果新的 Portal 是多个子节点，遍历逐个将它们搬运到新容器中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们通过 <code>nextVNode.tag !== prevVNode.tag</code> 来判断新旧 <code>Portal</code> 的容器是否相同，只有容器不同的情况下才需要搬运工作。搬运的原理是什么呢？我们知道当我们调用 <code>appendChild</code> 方法向 DOM 中添加元素时，如果被添加的元素已存在于页面上，那么就会移动该元素到目标容器元素下。我们利用这一点，由于经过 <code>patchChildren</code> 函数的处理之后，新的子节点已经存在于旧的容器中了，所以我们只需要在新容器元素上调用 <code>appendChild</code> 方法将这些已经存在于旧容器中的子节点搬运过去即可。</p> <p>当然了，在搬运的过程中，我们要检查新的 <code>Portal</code> 的子节点类型，并采用合适的处理方式。我们可以使用如下例子测试我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
  Portal<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#old-container'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'旧的 Portal'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>
  Portal<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'#new-container'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'新的 Portal'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 2秒后更新</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre></div><p>如上代码所示，在这个例子中 <code>prevVNode</code> 和 <code>nextVNode</code> 的类型都是 <code>Portal</code>，并且新旧 <code>Portal</code> 的挂载目标不同，分别是 <code>#old-container</code> 和 <code>#new-container</code>，如下是完整的代码和在线体验地址。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/xj118zm82o" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/xj118zm82o<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="有状态组件的更新"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0" class="header-anchor">#</a> 有状态组件的更新</h2> <p>接下来我们要介绍的就是有状态组件的更新，首先我们需要思考的问题是：在什么情况下才会触发有状态组件的更新呢？实际上对于有状态组件来说它的更新方式有两种：<strong>主动更新</strong> 和 <strong>被动更新</strong>。</p> <p>什么是<strong>主动更新</strong>呢？所谓主动更新指的是组件自身的状态发生变化所导致的更新，例如组件的 <code>data</code> 数据发生了变化就必然需要重渲染。但是大家不要忘记：一个组件所渲染的内容是很可能包含其它组件的，也就是子组件，对于子组件来讲，它除了自身状态之外，很可能还包含从父组件传递进来的外部状态(<code>props</code>)，所以父组件自身状态的变化很可能引起子组件外部状态的变化，此时就需要更新子组件，像这种因为外部状态变化而导致的组件更新就叫做<strong>被动更新</strong>。</p> <h3 id="主动更新"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0" class="header-anchor">#</a> 主动更新</h3> <p>我们先来讨论组件的主动更新，我们知道组件的核心是渲染函数，渲染函数会产出 <code>VNode</code>，渲染器会将渲染函数产出的 <code>VNode</code> 渲染为真实 DOM，当组件的状态变化时我们需要做的就是重新执行渲染函数并产出新的 <code>VNode</code>，最后通过新旧 <code>VNode</code> 之间的补丁算法完成真实 DOM 的更新。这里的关键点在于<strong>数据变化之后需要重新执行渲染函数，得到新的 VNode</strong>，我们来回顾一下前面章节中讲解过的用于挂载有状态组件的 <code>mountStatefulComponent</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 渲染VNode</span>
  instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 挂载</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
  instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre></div><p>组件挂载的核心步骤分为三步：1、创建组件实例，2、调用组件的 <code>render</code> 获得 <code>VNode</code>，3、将 <code>VNode</code> 挂载到容器元素。实际上我们可以把除了创建组件实例这一步之外的代码封装成一个函数，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><div class="highlighted">&nbsp;</div><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  instance<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、渲染VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 2、挂载</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
    <span class="token comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
    instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
  <span class="token punctuation">}</span>

  instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，在 <code>mountStatefulComponent</code> 函数内部，我们将除了创建组件实例之外的所有工作封装到了组件实例对象的 <code>instance._update</code> 函数中，紧接着在 <code>mountStatefulComponent</code> 函数的最后立即调用了 <code>_update</code> 函数，我们为什么要这么做呢？实际上 <code>_update</code> 函数所做的工作就是渲染组件，这样当组件自身状态发生变化后，我们就可以再次调用 <code>_update</code> 函数来完成组件的更新。</p> <p>假设我们有 <code>MyComponent</code> 组件，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// 自身状态 or 本地状态</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token comment">// mounted 钩子</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 两秒钟之后修改本地状态的值，并重新调用 _update() 函数更新组件</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>localState <span class="token operator">=</span> <span class="token string">'two'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上组件所示，该组件拥有一个叫做 <code>localState</code> 的数据，并且 <code>render</code> 函数中使用到了该数据。接着我们在组件的 <code>mounted</code> 钩子函数中设置了一个定时器，两秒钟之后会修改自身状态 <code>localState</code> 的值，由于我们目前没有讲解响应系统，所以我们暂时需要手动调用 <code>_update</code> 函数来完成组件的更新，等到后面响应系统相关的章节中我们再来详细讲解如何完成自动更新。另外在如上组件中我们使用了 <code>mounted</code> 生命周期钩子，但是就我们目前所实现的 <code>mountStatefulComponent</code> 函数而言，它并没有调用组件的任何生命周期函数的能力，为了代码的正常运行，我们需要为 <code>mountStatefulComponent</code> 函数添加执行 <code>mounted</code> 回调的能力，很简单我们只需要在组件被渲染为真实 DOM 之后调用该组件实例的 <code>mounted</code> 函数即可，如下高亮代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  instance<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、渲染VNode</span>
    instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 2、挂载</span>
    <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
    <span class="token comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
    instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
    <span class="token comment">// 5、调用 mounted 钩子</span>
    instance<span class="token punctuation">.</span>mounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样当我们使用 <code>mountStatefulComponent</code> 函数挂载有状态组件时，如果组件提供了 <code>mounted</code> 方法，那么该方法就会被当作钩子函数调用，更多的关于生命周期钩子函数的内容我们暂且不做深入讨论，我们还是回到组件更新的问题上。现在 <code>MyComponent</code> 组件的 <code>mounted</code> 钩子函数已经可以被正确执行，我们在 <code>mounted</code> 钩子函数内修改了组件的自身状态的值并再次调用了 <code>_update</code> 函数进行组件的更新，但是在更新时我们不应该像初次挂载组件那样去调用 <code>mount</code> 函数，而是应该调用 <code>patch</code> 函数将组件新产出的 <code>VNode</code> 与初次挂载时产出的旧 <code>VNode</code> 做比较并完成更新，但无论是初次挂载还是后续更新我们调用的都是 <code>_update</code> 函数，可是 <code>_update</code> 函数怎么知道当前这次渲染到底是初次挂载还是后续更新呢？所以我们需要为组件实例设计一个 <code>boolean</code> 类型的状态标识，用来标记组件是否已经被挂载，这样 <code>_update</code> 函数就能够区分当前这次渲染到底是初次挂载还是后续更新了，如下是我们修改之后的 <code>mountStatefulComponent</code> 函数的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  instance<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 instance._mounted 为真，说明组件已挂载，应该执行更新操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">.</span>_mounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1、拿到旧的 VNode</span>
      <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode
      <span class="token comment">// 2、重渲染新的 VNode</span>
      <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 3、patch 更新</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span>
      <span class="token comment">// 4、更新 vnode.el 和 $el</span>
      instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1、渲染VNode</span>
      instance<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 2、挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// 3、组件已挂载的标识</span>
      instance<span class="token punctuation">.</span>_mounted <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span>
      instance<span class="token punctuation">.</span>$el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> instance<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>el
      <span class="token comment">// 5、调用 mounted 钩子</span>
      instance<span class="token punctuation">.</span>mounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，我们通过一个 <code>if...else</code> 语句判断组件实例的 <code>instance._mounted</code> 属性值的真假，来判断应该执行初次挂载操作还是更新操作。<code>if</code> 语句块内的代码用于执行更新操作，大致分为四个步骤：</p> <ul><li>1、取得旧的 <code>VNode</code>，由于初次挂载组件时所产出的 <code>VNode</code> 存储在组件实例的 <code>$vnode</code> 属性中，所以我们可以通过 <code>$vnode</code> 属性拿到旧的 <code>VNode</code>。</li> <li>2、重新调用 <code>render</code> 函数产出新的 <code>VNode</code>。</li> <li>3、调用 <code>patch</code> 函数对比新旧 <code>VNode</code>，完成更新操作。</li></ul> <p>除了以上三步之外，我们还应该使用新的真实 DOM 元素去更新 <code>vnode.el</code> 属性和组件实例的 <code>$el</code> 属性的值。另外大家注意我们在第三步中传递给 <code>patch</code> 函数的第三个参数，它是容器元素，这个容器元素可以通过获取旧的 <code>vnode.el</code> 的父节点得到。</p> <p>现在组件的主动更新我们就讲解完了，下面的链接是完整代码和线上体验地址。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/jzl0nk81xy" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/jzl0nk81xy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="初步了解组件的外部状态-props"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81-props" class="header-anchor">#</a> 初步了解组件的外部状态 props</h3> <p>上面我们讲解了有状态组件的主动更新，接下来我们本应该继续讲解有状态组件的被动更新，但是在讲解被动更新之前，需要花点时间来做一些铺垫，我们先了解一下组件的 <code>props</code>，为什么需要了解 <code>props</code> 呢？因为组件的被动更新是由组件的外部状态变化所导致的，而 <code>props</code> 就是组件的外部状态。不过本节不会深入讨论 <code>props</code>，点到为止，我们会在后续的章节中专门详细地讲解 <code>props</code>。</p> <p>假设父组件的模板如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 父组件模板 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name">:text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localState<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>父组件的模板中渲染了 <code>ChildComponent</code> 子组件，<code>ChildComponent</code> 子组件有一个 <code>text</code> 属性，它是一个绑定属性，绑定的变量是父组件的自身状态 <code>localState</code>。这段模板被编译后的渲染函数可以表示为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段渲染函数就是父组件的渲染函数，所以我们可以这样定义父组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// 本地状态</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    childCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> childCompVNode
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，父组件渲染函数所返回的就是子组件的 <code>VNode</code>，即 <code>childCompVNode</code>。<code>childCompVNode</code> 将会被 <code>mountStatefulComponent</code> 函数挂载，挂载的步骤我们已经再熟悉不过了：1、创建组件实例，2、调用组件实例的 <code>render</code> 函数，3、调用 <code>mount</code> 函数挂载。实际上我们可以在组件实例创建之后立即初始化组件的 <code>props</code>。为 <code>mountStatefulComponent</code> 函数添加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 初始化 props</span>
  instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data

  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，在组件实例创建完成之后，我们为组件实例添加了 <code>$props</code> 属性，并且将 <code>vnode.data</code> 赋值给 <code>$props</code>。这样，子组件中就可以通过 <code>this.$props.text</code> 访问从父组件传递进来的 <code>props</code> 数据。如下是 <code>ChildComponent</code> 组件中使用外部数据的方式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过 this.$props.text 访问外部数据</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样我们就实现了父组件向子组件传递 <code>props</code> 的能力，不过在该实现中我们以最简单的方式，直接将 <code>VNodeData</code> 赋值给 <code>$props</code>，我们知道 <code>VNodeData</code> 中的数据并不全是 <code>props</code>，其中还包含事件以及其他重要的信息，所以在真正的实现中，我们会从 <code>VNodeData</code> 中提取 <code>props</code>。不过这并不是本章的重点内容，我们一切从简。</p> <p>现在子组件已经有能力拿到从父组件传递进来的 <code>props</code> 数据了，我们可以使用如下例子测试我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件中访问外部状态：this.$props.text</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 父组件向子组件传递的 props</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这里是完整的代码和在线体验地址：<a href="https://codesandbox.io/s/k5lll524m5" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/k5lll524m5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，可以看到如上代码能够正确运行，子组件中可以访问由父组件传递进来的数据。</p> <h3 id="被动更新"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E8%A2%AB%E5%8A%A8%E6%9B%B4%E6%96%B0" class="header-anchor">#</a> 被动更新</h3> <p>有了 <code>props</code> 的铺垫之后，我们可以开始讨论有状态组件的<strong>被动更新</strong>了。如前所述，被动更新指的是由外部状态变化而引起的更新操作，通常父组件自身状态的变化可能会引起子组件的更新，我们可以修改上面的例子，为父组件添加 <code>mounted</code> 钩子，并在该钩子函数中修改父组件的自身状态 <code>localState</code> 的值，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token comment">// 子组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件中访问外部状态：this.$props.text</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 两秒钟后将 localState 的值修改为 'two'</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>localState <span class="token operator">=</span> <span class="token string">'two'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 父组件向子组件传递的 props</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>如上高亮代码所示，我们为父组件定义了 <code>mounted</code> 钩子函数，在 <code>mounted</code> 钩子函数内我们设置了一个定时器，两秒钟后修改 <code>localState</code> 的值为 <code>'two'</code> 并调用 <code>_update</code> 方法更新父组件。这个过程我们可以理解为父组件 <code>ParentComponent</code> 先后产出了两个不同的 <code>VNode</code>：第一次渲染产出的 <code>VNode</code> 是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> prevCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'one'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>第二次由于自身状态变化所产出的 <code>VNode</code> 为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> nextCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'two'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>所以在 <code>_update</code> 函数内部的更新操作，等价于 <code>prevCompVNode</code> 和 <code>nextCompVNode</code> 之间的 <code>patch</code>，即：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">patch</span><span class="token punctuation">(</span>prevCompVNode<span class="token punctuation">,</span> nextCompVNode<span class="token punctuation">,</span> prevCompVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span>
</code></pre></div><p>由于 <code>prevCompVNode</code> 和 <code>nextCompVNode</code> 的类型都是组件类型的 <code>VNode</code>，所以在 <code>patch</code> 函数内部会调用 <code>patchComponent</code> 函数进行更新，如下高亮代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nextFlags <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>flags
  <span class="token keyword">const</span> prevFlags <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>flags

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevFlags <span class="token operator">!==</span> nextFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">ELEMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchElement</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchComponent</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchText</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">FRAGMENT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchFragment</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">PORTAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patchPortal</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>patchComponent</code> 函数接收三个参数，分别是旧的 <code>VNode</code> 和新的 <code>VNode</code> 以及容器元素 <code>container</code>，如下是 <code>patchComponent</code> 函数的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查组件是否是有状态组件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、获取组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token comment">// 2、更新 props</span>
    instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
    <span class="token comment">// 3、更新组件</span>
    instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码所示，我们通过检查组件的 <code>flags</code> 判断组件是否是有状态组件，如果是有状态组件则更新之。更新操作很简单，三步：</p> <ul><li>1、通过 <code>prevVNode.children</code> 拿到组件实例</li> <li>2、更新 <code>props</code>，使用新的 <code>VNodeData</code> 重新设置组件实例的 <code>$props</code> 属性</li> <li>3、由于组件的 <code>$props</code> 已更新，所以调用组件的 <code>_update</code> 方法，让组件重渲染。</li></ul> <p>这里需要澄清的一件事，我们之所以能够通过 <code>VNode</code> 的 <code>children</code> 属性来读取组件实例，例如上面代码中的 <code>prevVNode.children</code>，是因为每个类型为有状态组件的 <code>VNode</code>，在挂载期间我们都会让其 <code>children</code> 属性引用组件的实例，以便能够通过 <code>VNode</code> 访问组件实例对象。这一点我们早在“先设计 VNode 吧”一章中就有提及。所以我们需要修改 <code>mountStatefulComponent</code> 函数的代码，在创建组件实例后需要将实例对象赋值给 <code>vnode.children</code> 属性，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样我们在 <code>patchComponent</code> 函数中就能够通过 <code>VNode</code> 拿到组件实例了，这里我们再次强调：<code>VNode</code> 的 <code>children</code> 属性本应该用来存储子节点，但是对于组件类型的 <code>VNode</code> 来说，它的子节点都应该作为插槽存在，并且我们选择将插槽内容存储在单独的 <code>slots</code> 属性中，而非存储在 <code>children</code> 属性中，这样 <code>children</code> 属性就可以用来存储组件实例了，这些内容我们会在后面章节中讲解插槽时再次说明。</p> <p>如下是完整代码以及在线体验地址：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/2z7335kn5y" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/2z7335kn5y<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>在上面的讲解中，父组件自身状态变化之后，它渲染的子组件并没有变化，仍然是 <code>ChildComponent</code>，仅仅是传递给子组件的 <code>props</code> 数据发生了变化。但是，有时父组件自身状态的变化会导致父组件渲染不同的子组件，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token comment">// 父组件类</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  isTrue <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>isTrue <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 this.isTrue 的值为真，则渲染 ChildComponent1，否则渲染 ChildComponent2</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isTrue <span class="token operator">?</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent1<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent2<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>

<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>如上代码所示，观察 <code>ParentComponent</code> 组件的 <code>render</code> 函数，当 <code>ParentComponent</code> 组件的自身状态 <code>isTrue</code> 为真时会渲染子组件 <code>ChildComponent1</code>，否则会渲染子组件 <code>ChildComponent2</code>。同时我们在 <code>mounted</code> 钩子中设置了定时器，两秒钟后将 <code>isTrue</code> 的值变更为 <code>false</code>，并调用 <code>_update</code> 方法更新 <code>ParentComponent</code> 组件。在这种情况下就会出现因父组件自身状态的变化而导致其渲染不同的组件，在初次挂载时 <code>ParentComponent</code> 组件所产出的 <code>VNode</code> 为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> pervCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent1<span class="token punctuation">)</span>
</code></pre></div><p>更新之后 <code>ParentComponent</code> 组件所产出的 <code>VNode</code> 为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> nextCompVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ChildComponent2<span class="token punctuation">)</span>
</code></pre></div><p>虽然 <code>pervCompVNode</code> 和 <code>nextCompVNode</code> 的类型都是组件，但它们是不同的组件。拿上面的例子来说，<code>pervCompVNode</code> 描述的是组件 <code>ChildComponent1</code>，<code>nextCompVNode</code> 描述的是组件 <code>ChildComponent2</code>，也就是说新旧 <code>VNode</code> 所描述的不是同一个组件，这就引申出我们更新组件的一个原则：<strong>我们认为不同的组件渲染不同的内容</strong>，所以对于不同的组件，我们采用的方案是使用新组件的内容替换旧组件渲染的内容。根据这个思想，我们修改 <code>patchComponent</code> 函数的代码，如下：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// tag 属性的值是组件类，通过比较新旧组件类是否相等来判断是否是相同的组件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token comment">// 更新 props</span>
    instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
    <span class="token comment">// 更新组件</span>
    instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上 <code>patchComponent</code> 函数中的高亮代码所示，增加了一个判断条件，我们知道对于组件类型的 <code>VNode</code> 而言，它的 <code>tag</code> 属性值引用的就是组件类本身，我们通过对比前后组件类是否相同来确定新旧组件是否是相同的组件，如果不相同则直接调用 <code>replaceVNode</code> 函数使用新组件替换旧的组件。大家还记的 <code>replaceVNode</code> 函数的实现方式吗？如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是我们之前实现过的 <code>replaceVNode</code> 函数，它的原理就是将旧的 <code>VNode</code> 所渲染的内容从容器元素中移除，并将新的 <code>VNode</code> 挂载到容器元素中。这段代码同样适用于组件，但是对于组件来说我们不能仅仅将组件所渲染的内容移除就算大功告成，我们还有另外一件事需要做，即调用 <code>unmounted</code> 钩子，所以我们为 <code>replaceVNode</code> 函数添加如下代码：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">replaceVNode</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token comment">// 如果将要被移除的 VNode 类型是组件，则需要调用该组件实例的 unmounted 钩子函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类型为有状态组件的 VNode，其 children 属性被用来存储组件实例对象</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children
    instance<span class="token punctuation">.</span>unmounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">unmounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，如果将要被移除的 <code>prevVNode</code> 的类型是有状态组件，则需要调用该组件实例的 <code>unmounted</code> 钩子函数。这里是完整的代码以及在线体验地址：<a href="https://codesandbox.io/s/ll92yq0o2l" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/ll92yq0o2l<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="我们需要-shouldupdatecomponent"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81-shouldupdatecomponent" class="header-anchor">#</a> 我们需要 shouldUpdateComponent</h3> <p>【占位】</p> <h2 id="函数式组件的更新"><a href="http://interview.poetries.top/principle-docs/vue/09-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8Bpatch.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0" class="header-anchor">#</a> 函数式组件的更新</h2> <p>接下来我们要讨论的是函数式组件的更新，其实无论是有状态组件还是函数式组件，它们的更新原理都是一样的：用组件新产出的 <code>VNode</code> 与之前产出的旧 <code>VNode</code> 进行比对，从而完成更新。为了让讲解不至于太抽象，我们还是拿一个具体的例子来说，如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件 - 函数式组件</span>
<span class="token keyword">function</span> <span class="token function">MyFunctionalComp</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件的 render 函数中渲染了 MyFunctionalComp 子组件</span>
<span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
  localState <span class="token operator">=</span> <span class="token string">'one'</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>localState <span class="token operator">=</span> <span class="token string">'two'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有状态组件 VNode</span>
<span class="token keyword">const</span> compVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>ParentComponent<span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>观察上面的代码，我们定义了 <code>ParentComponent</code> 组件，它是一个有状态组件，在它的 <code>render</code> 函数中渲染了 <code>MyFunctionalComp</code> 子组件，这个子组件是一个函数式组件。观察 <code>MyFunctionalComp</code> 函数的参数，由于函数式组件没有组件实例，所以在函数式组件中我们不能通过 <code>this.$props.xxx</code> 访问 <code>props</code> 数据，<code>props</code> 数据是作为函数的参数传递进去的，如下是我们之前实现的 <code>mountFunctionalComponent</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 VNode</span>
  <span class="token keyword">const</span> $vnode <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 挂载</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// el 元素引用该组件的根元素</span>
  vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre></div><p>为了实现函数式组件的 <code>props</code> 传递，我们需要修对 <code>mountFunctionalComponent</code> 函数做一些修改，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted">&nbsp;</div><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 props</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token comment">// 获取 VNode</span>
  <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 挂载</span>
  <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
  <span class="token comment">// el 元素引用该组件的根元素</span>
  vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们在调用组件函数获取 <code>VNode</code> 之前，要先获取 <code>props</code>，这里我们同样直接将整个 <code>VNodeData</code> 作为 <code>props</code> 数据，前面我们已经解释了这么做的原因是出于简便。拿到 <code>props</code> 数据之后，在调用组件函数 <code>vnode.tag(props)</code> 时将 <code>props</code> 作为参数传递过去，这样子组件就可以通过参数访问由父组件传递过来的数据了。另外，我们将组件产出的 <code>VNode</code> 赋值给了 <code>vnode.children</code> 属性，这里需要做一些说明，通过之前的讲解可知，对于有状态组件类型的 <code>VNode</code> 来说，我们使用其 <code>children</code> 属性存储组件实例，并在将来会用 <code>slots</code> 属性存储插槽数据。同样的，在函数式组件中，由于函数式组件没有组件实例，所以对于函数式组件类型的 <code>VNode</code>，我们用其 <code>children</code> 属性存储组件产出的 <code>VNode</code>，将来也会使用 <code>slots</code> 属性存储插槽数据。这个是设计上的决定，并非一定要这么做，但为了与 <code>Vue3</code> 的设计保持一致，所以我们就沿用 <code>Vue3</code> 的设计。</p> <p>现在我们已经实现了函数式组件接收 <code>props</code> 数据的功能，我们再来观察一下上面的例子，在这个例子中我们为有状态组件 <code>ParentComponent</code> 提供了 <code>mounted</code> 钩子函数，两秒之后修改自身状态 <code>localState</code> 的值，并调用 <code>_update</code> 函数重渲染，在重渲染的过程中，<code>_update</code> 函数内部发生的事情等价于：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 旧的 VNode</span>
<span class="token keyword">const</span> prevVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'one'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 新的 VNode</span>
<span class="token keyword">const</span> nextVNode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span>MyFunctionalComp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'two'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 更新</span>
<span class="token function">patch</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span>
</code></pre></div><p>由于 <code>prevVNode</code> 和 <code>nextVNode</code> 的类型都是组件，所以在 <code>patch</code> 函数内部会调用 <code>patchComponent</code> 函数更新，我们来回顾一下 <code>patchComponent</code> 函数的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token comment">// 更新 props</span>
    instance<span class="token punctuation">.</span>$props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
    <span class="token comment">// 更新组件</span>
    instance<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这段代码中 <code>if</code> 语句块内的代码用于处理两个不同组件之间的更新，<code>else...if</code> 语句块内的代码用于处理有状态组件的更新，所以<code>patchComponent</code> 函数还不能完成函数式组件的更新。为了达到目的，我们需要为 <code>patchComponent</code> 函数添加一段代码，用来处理函数式组件类型的 <code>VNode</code> 的更新，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这里编写函数式组件的更新逻辑</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们只需要为其添加 <code>else</code> 语句块即可，我们将在这里编写函数式组件的更新逻辑。但问题是，应该如何更新呢？在本节的开头我们就说过了，无论是有状态组件还是函数式组件，它们的更新原理不变，所以我们可以效仿有状态组件的实现方式。</p> <p>挂载函数式组件的核心步骤只有两步：1、调用组件的定义函数，拿到组件产出的 <code>VNode</code>，2、将 <code>VNode</code> 挂载到容器元素。与挂载有状态组件类似，我们可以把这些步骤封装到一个函数中，当组件更新时再次调用这个函数即可。但是，与有状态组件不同，函数式组件没有组件实例，所以我们没办法封装类似 <code>instance._update</code> 这样的函数，那应该怎么办呢？很简单，我们把 <code>update</code> 函数定义在函数式组件的 <code>VNode</code> 上就可以了，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在函数式组件类型的 vnode 上添加 handle 属性，它是一个对象</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化 props</span>
      <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token comment">// 获取 VNode</span>
      <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// el 元素引用该组件的根元素</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是我们修改后的 <code>mountFunctionalComponent</code> 函数，可以看到我们给函数式组件类型的 <code>VNode</code> 添加了 <code>handle</code> 属性，它是一个拥有四个属性的对象：</p> <div class="language-js extra-class"><pre class="language-js"><code>vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
  prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
  container<span class="token punctuation">,</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们把之前用于挂载函数式组件的代码移动到了 <code>vnode.handle.update</code> 函数中，所以在 <code>mountFunctionalComponent</code> 函数的最后立即调用了 <code>vnode.handle.update</code> 函数，这样能够保证原始功能不变。<code>handle</code> 对象除了 <code>update</code> 方法之外还有其他三个属性，它们的作用分别是：</p> <ul><li><code>handle.prev</code>：存储旧的函数式组件 <code>VNode</code>，在初次挂载时，没有旧的 <code>VNode</code> 可言，所以初始值为 <code>null</code>。</li> <li><code>handle.next</code>：存储新的函数式组件 <code>VNode</code>，在初次挂载时，被赋值为当前正在挂载的函数式组件 <code>VNode</code>。</li> <li><code>handle.container</code>：存储的是挂载容器</li></ul> <p>现在已经有了 <code>handle.update</code> 函数，我们可以尝试在 <code>patchComponent</code> 函数内部通过调用 <code>handle.update</code> 函数完成函数式组件的更新，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span><span class="token parameter">prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> prevVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">replaceVNode</span><span class="token punctuation">(</span>prevVNode<span class="token punctuation">,</span> nextVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VNodeFlags<span class="token punctuation">.</span><span class="token constant">COMPONENT_STATEFUL_NORMAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新函数式组件</span>
    <span class="token comment">// 通过 prevVNode.handle 拿到 handle 对象</span>
    <span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>handle <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>handle<span class="token punctuation">)</span>
    <span class="token comment">// 更新 handle 对象</span>
    handle<span class="token punctuation">.</span>prev <span class="token operator">=</span> prevVNode
    handle<span class="token punctuation">.</span>next <span class="token operator">=</span> nextVNode
    handle<span class="token punctuation">.</span>container <span class="token operator">=</span> container

    <span class="token comment">// 调用 update 函数完成更新</span>
    handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，我们首先通过旧的 <code>VNode(prevVNode)</code> 拿到 <code>handle</code> 对象，接着我们更新了 <code>handle</code> 对象下各个属性的值：</p> <ul><li>1、将旧的函数式组件 <code>VNode(prevVNode)</code> 赋值给 <code>handle.prev</code>。</li> <li>2、将新的函数式组件 <code>VNode(nextVNode)</code> 赋值给 <code>handle.next</code>。</li> <li>3、更新 <code>container</code>（即使 <code>container</code> 未必会变，但仍要更新之）。</li></ul> <p>最后我们调用了 <code>handle.update</code> 函数完成更新操作。我们再详细地了解一下在这个过程中发生了什么，在函数式组件初次挂载完成后 <code>handle</code> 对象的值为：</p> <div class="language-js extra-class"><pre class="language-js"><code>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
  prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> prevVNode<span class="token punctuation">,</span>
  container<span class="token punctuation">,</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在经过 <code>patchComponent</code> 函数对 <code>handle</code> 对象进行更新之后，<code>handle</code> 对象的值将变为：</p> <div class="language-js extra-class"><pre class="language-js"><code>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
  prev<span class="token operator">:</span> prevVNode<span class="token punctuation">,</span>
  next<span class="token operator">:</span> nextVNode<span class="token punctuation">,</span>
  container<span class="token punctuation">,</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到此时的 <code>handle.prev</code> 属性已经非空了，<code>prev</code> 和 <code>next</code> 属性分别存储的是旧的和新的函数式组件类型的 <code>VNode</code>。这个更新的动作很关键。在更新完成之后，立即调用了 <code>handle.update</code> 函数进行重渲染，如下是目前我们所实现的 <code>handle.update</code> 函数：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在函数式组件类型的 vnode 上添加 handle 属性，它是一个对象</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化 props</span>
      <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
      <span class="token comment">// 获取 VNode</span>
      <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 挂载</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
      <span class="token comment">// el 元素引用该组件的根元素</span>
      vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，现在的 <code>update</code> 函数只能完成初次挂载的工作，当再次调用 <code>update</code> 函数进行更新时，我们是不能再次执行这段用于挂载的代码的，就像有状态组件的 <code>instance.update</code> 函数的实现一样，我们需要为 <code>handle.update</code> 函数添加更新逻辑，如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新的逻辑写在这里</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取 props</span>
        <span class="token keyword">const</span> props <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
        <span class="token comment">// 获取 VNode</span>
        <span class="token keyword">const</span> $vnode <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 挂载</span>
        <span class="token function">mount</span><span class="token punctuation">(</span>$vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG<span class="token punctuation">)</span>
        <span class="token comment">// el 元素引用该组件的根元素</span>
        vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> $vnode<span class="token punctuation">.</span>el
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的代码中，我们通过判断 <code>vnode.handle.prev</code> 是否存在来判断该函数式组件是初次挂载还是后续更新，由于在 <code>patchComponent</code> 函数内我们已经将 <code>vnode.handle.prev</code> 属性赋值为旧的组件 <code>VNode</code>，所以如果 <code>vnode.handle.prev</code> 存在则说明该函数式组件并非初次挂载，而是更新，所以我们会在 <code>if</code> 语句块内编写更新逻辑，而用于初次挂载的代码被我们放到了 <code>else</code> 语句块中。</p> <p>那么更新的思路是什么呢？前面说过了，只要想办法分别拿到组件产出的新旧 <code>VNode</code> 即可，这样我们就可以通过 <code>patch</code> 函数更新之。如下代码所示：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><div class="highlighted">&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountFunctionalComponent</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> isSVG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vnode<span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token punctuation">{</span>
    prev<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新</span>
        <span class="token comment">// prevVNode 是旧的组件VNode，nextVNode 是新的组件VNode</span>
        <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>prev
        <span class="token keyword">const</span> nextVNode <span class="token operator">=</span> vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>next
        <span class="token comment">// prevTree 是组件产出的旧的 VNode</span>
        <span class="token keyword">const</span> prevTree <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>children
        <span class="token comment">// 更新 props 数据</span>
        <span class="token keyword">const</span> props <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span>data
        <span class="token comment">// nextTree 是组件产出的新的 VNode</span>
        <span class="token keyword">const</span> nextTree <span class="token operator">=</span> <span class="token punctuation">(</span>nextVNode<span class="token punctuation">.</span>children <span class="token operator">=</span> nextVNode<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 调用 patch 函数更新</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>prevTree<span class="token punctuation">,</span> nextTree<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>container<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 立即调用 vnode.handle.update 完成初次挂载</span>
  vnode<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上高亮代码所示，由于我们在 <code>patchComponent</code> 函数内已经更新过了 <code>handle</code> 对象，所以此时我们可以通过 <code>vnode.handle.prev</code> 和 <code>vnode.handle.next</code> 分别拿到旧的组件 <code>VNode</code> 和新的组件 <code>VNode</code>，但大家不要搞混的是：<code>prevVNode</code> 和 <code>nextVNode</code> 是用来描述函数式组件的 <code>VNode</code>，并非函数式组件所产出的 <code>VNode</code>。因为函数式组件所产出的 <code>VNode</code> 存放在用来描述函数式组件的 <code>VNode</code> 的 <code>children</code> 属性中，所以在如上代码中我们通过 <code>prevVNode.children</code> 拿到了组件所产出的旧的 <code>VNode</code> 即 <code>prevTree</code>，接着使用新的 <code>props</code> 重新调用组件函数 <code>nextVNode.tag(props)</code> 得到新产出的 <code>VNode</code> 即 <code>nextTree</code>，有了 <code>prevTree</code> 和 <code>nextTree</code> 之后我们就可以调用 <code>patch</code> 函数执行更新操作了。</p> <p>以上就是函数式组件的更新过程。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>完整代码&amp;在线体验地址：<a href="https://codesandbox.io/s/5yz63qqx7p" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/5yz63qqx7p<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div>
<!-- vue响应式原理 -->
<div class="content__default"><h2 id="vue-初始化"><a href="http://interview.poetries.top/principle-docs/vue/10-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html#vue-%E5%88%9D%E5%A7%8B%E5%8C%96" class="header-anchor">#</a> Vue 初始化</h2> <p>先从最简单的一段 Vue 代码开始：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    {{ message }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      message<span class="token operator">:</span> <span class="token string">"hello world"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>这段代码很简单，最终会在页面上打印一个 hello world，它是如何实现的呢？</li> <li>我们从源头：new Vue 的地方开始分析。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 执行 new Vue 时会依次执行以下方法</span>
<span class="token comment">// 1. Vue.prototype._init(option)</span>
<span class="token comment">// 2. initState(vm)</span>
<span class="token comment">// 3. observe(vm._data)</span>
<span class="token comment">// 4. new Observer(data)</span>

<span class="token comment">// 5. 调用 walk 方法，遍历 data 中的每一个属性，监听数据的变化。</span>
<span class="token keyword">function</span> <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 6. 执行 defineProperty 监听数据读取和设置。</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 为每个属性创建 Dep（依赖搜集的容器，后文会讲）</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绑定 get、set</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> val<span class="token punctuation">;</span>
      <span class="token comment">// 如果有 target 标识，则进行依赖搜集</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
      <span class="token comment">// 修改数据时，通知页面重新渲染</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>数据描述符绑定完成后，我们就能得到以下的流程图：</p> <p><img src="./vue响应式_files/48.png" alt="" class="medium-zoom-image"></p> <ul><li>图中我们可以看到，Vue 初始化时，进行了数据的 get、set 绑定，并创建了一个 Dep 对象。</li> <li>对于数据的 get、set 绑定我们并不陌生，但是 Dep 对象什么呢？</li> <li>Dep 对象用于依赖收集，它实现了一个发布订阅模式，完成了数据 Data 和渲染视图 Watcher 的订阅，我们一起来剖析一下。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 ts 类型提示，我们可以得出 Dep.target 是一个 Watcher 类型。</span>
  <span class="token keyword">static</span> target<span class="token operator">:</span> <span class="token operator">?</span>Watcher<span class="token punctuation">;</span>
  <span class="token comment">// subs 存放搜集到的 Watcher 对象集合</span>
  subs<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Watcher<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">sub<span class="token operator">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 搜集所有使用到这个 data 的 Watcher 对象。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 搜集依赖，最终会调用上面的 addSub 方法</span>
      Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 调用对应的 Watcher，更新视图</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>根据对 <code>Dep</code> 的源码分析，我们得到了下面这张逻辑图：</p></blockquote> <p><img src="./vue响应式_files/49.png" alt="" class="medium-zoom-image"></p> <p>了解 Data 和 Dep 之后，我们来继续揭开 Watcher 的面纱。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span> expOrFn<span class="token operator">:</span> string <span class="token operator">|</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 vm._render 方法赋值给 getter。</span>
    <span class="token comment">// 这里的 expOrFn 其实就是 vm._render，后文会讲到。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 给 Dep.target 赋值为当前 Watcher 对象</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// this.getter 其实就是 vm._render</span>
    <span class="token comment">// vm._render 用来生成虚拟 dom、执行 dom-diff、更新真实 dom。</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">addDep</span><span class="token punctuation">(</span><span class="token parameter">dep<span class="token operator">:</span> Dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将当前的 Watcher 添加到 Dep 收集池中</span>
    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 开启异步队列，批量更新 Watcher</span>
    <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 和初始化一样，会调用 get 方法，更新视图</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>源码中我们看到，Watcher 实现了渲染方法 _render 和 Dep 的关联， 初始化 Watcher 的时候，打上 Dep.target 标识，然后调用 get 方法进行页面渲染。加上上文的 Data，目前 Data、Dep、Watcher 三者的关系如下：</p></blockquote> <p><img src="./vue响应式_files/50.png" alt="" class="medium-zoom-image"></p> <blockquote><p>我们再拉通串一下整个流程：Vue 通过 defineProperty 完成了 Data 中所有数据的代理，当数据触发 get 查询时，会将当前的 Watcher 对象加入到依赖收集池 Dep 中，当数据 Data 变化时，会触发 set 通知所有使用到这个 Data 的 Watcher 对象去 update 视图。</p></blockquote> <p><strong>目前的整体流程如下：</strong></p> <p><img src="./vue响应式_files/51.png" alt="" class="medium-zoom-image"></p> <p>上图的流程中 Data 和 Dep 都是 Vue 初始化时创建的，但现在我们并不知道 Wacher 是从哪里创建的，带着这个问题，我们接着往下探索。</p> <h2 id="模板渲染"><a href="http://interview.poetries.top/principle-docs/vue/10-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html#%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93" class="header-anchor">#</a> 模板渲染</h2> <p>上文中，我们分析了初始化 Vue 过程中处理数据的部分，接下来，我们分析一下数据渲染的部分。</p> <blockquote><p>其实 new Vue 执行到最后，会调用 mount 方法，将 Vue 实例渲染成 dom 。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// new Vue 执行流程。</span>
<span class="token comment">// 1. Vue.prototype._init(option)</span>
<span class="token comment">// 2. vm.$mount(vm.$options.el)</span>
<span class="token comment">// 3. render = compileToFunctions(template) ，编译 Vue 中的 template 模板，生成 render 方法。</span>
<span class="token comment">// 4. Vue.prototype.$mount 调用上面的 render 方法挂载 dom。</span>
<span class="token comment">// 5. mountComponent</span>

<span class="token comment">// 6. 创建 Watcher 实例</span>
<span class="token keyword">const</span> <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 结合上文，我们就能得出，updateComponent 就是传入 Watcher 内部的 getter 方法。</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 7. new Watcher 会执行 Watcher.get 方法</span>
<span class="token comment">// 8. Watcher.get 会执行 this.getter.call(vm, vm) ，也就是执行 updateComponent 方法</span>
<span class="token comment">// 9. updateComponent 会执行 vm._update(vm._render())</span>

<span class="token comment">// 10. 调用 vm._render 生成虚拟 dom</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">;</span>
  <span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> vnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 11. 调用 vm._update(vnode) 渲染虚拟 dom</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> VNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初次渲染</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 12. vm.__patch__ 方法就是做的 dom diff 比较，然后更新 dom，这里就不展开了。</span>
</code></pre></div><p>看完 Vue 模板渲染的过程，我们可以得到如下的流程图：</p> <p><img src="./vue响应式_files/52.png" alt="" class="medium-zoom-image"></p> <blockquote><p>到这里，我们就知道了 Watcher 其实是在 Vue 初始化的阶段创建的，属于生命周期中 beforeMount 的位置创建的，创建 Watcher 时会执行 render 方法，最终将 Vue 代码渲染成真实的 DOM。</p></blockquote> <p><strong>我们再将之前的流程整合一下，就能得到以下的流程：</strong></p> <p><img src="./vue响应式_files/55.png" alt="" class="medium-zoom-image"></p> <ul><li>上图分析了 Vue 初始化到渲染 DOM 的整个过程，最后我们再分析一下，当数据变化时，Vue 又是怎么进行更新的？</li> <li>其实，在上图也能看出，在 Data 变化时，会调用 Dep.notify 方法，随即调用 Watcher 内部的 update 方法，此方法会将所有使用到这个 Data 的 Watcher 加入一个队列，并开启一个异步队列进行更新，最终执行 _render 方法完成页面更新。</li></ul> <p><strong>整体的流程如下：</strong></p> <p><img src="./vue响应式_files/56.png" alt="" class="medium-zoom-image"></p> <p>好了，探索到这里，Vue 的响应式原理，已经被我们分析透彻了，如果你还没有明白，不妨再细品一下上图。</p> <h2 id="组件渲染"><a href="http://interview.poetries.top/principle-docs/vue/10-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93" class="header-anchor">#</a> 组件渲染</h2> <p>Vue 组件又是怎么渲染的呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 从模板编译开始，当发现一个自定义组件时，会执行以下函数</span>
<span class="token comment">// 1. compileToFunctions(template)</span>
<span class="token comment">// 2. compile(template, options);</span>
<span class="token comment">// 3. const ast = parse(template.trim(), options)</span>
<span class="token comment">// 4. const code = generate(ast, options)</span>
<span class="token comment">// 5. createElement</span>

<span class="token comment">// 6. createComponent</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>
  <span class="token parameter">Ctor<span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span> <span class="token operator">|</span> Function <span class="token operator">|</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token operator">?</span>VNodeData<span class="token punctuation">,</span>
  context<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  children<span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  tag<span class="token operator">?</span><span class="token operator">:</span> string</span>
<span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token operator">|</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// $options._base 其实就是全局 Vue 构造函数，在初始化时 initGlobalAPI 中定义的：Vue.options._base = Vue</span>
  <span class="token keyword">const</span> baseCtor <span class="token operator">=</span> context<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_base<span class="token punctuation">;</span>
  <span class="token comment">// Ctor 就是 Vue 组件中 &lt;script&gt; 标签下 export 出的对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将组件中 export 出的对象，继承自 Vue，得到一个构造函数</span>
    <span class="token comment">// 相当于 Vue.extend(YourComponent)</span>
    Ctor <span class="token operator">=</span> baseCtor<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-component-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Ctor<span class="token punctuation">.</span>cid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">xxx</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> vnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 7. 实现组件继承 Vue，并调用 Vue._init 方法，进行初始化</span>
Vue<span class="token punctuation">.</span><span class="token function-variable function">extend</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">extendOptions<span class="token operator">:</span> Object</span><span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
  <span class="token keyword">const</span> Super <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 Vue.prototype._init，之后的流程就和首次加载保持一致</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 原型继承，相当于：Component extends Vue</span>
  <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub<span class="token punctuation">;</span>
  <span class="token keyword">return</span> Sub<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>看完组件渲染的源码后，结合上文，重新整理了一张流程图，图中的蓝色部分就是渲染组件的过程。</p> <p><img src="./vue响应式_files/57.png" alt="" class="medium-zoom-image"></p> <p>好了，现在是真的结束了，最终的流程图就是上面的这一张图。</p> <p><img src="./vue响应式_files/58.png" alt="" class="medium-zoom-image"></p> <h2 id="总结"><a href="http://interview.poetries.top/principle-docs/vue/10-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html#%E6%80%BB%E7%BB%93" class="header-anchor">#</a> 总结</h2> <p>本文从源码的角度，介绍了 Vue 响应式原理，来简单回顾一下吧。</p> <ul><li>从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。</li> <li>编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。</li> <li>编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。</li> <li>数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。</li></ul></div> 
<!-- vue响应式原理 -->
<div class="content__default"><blockquote><p>本文主要分析 Vue 从 Data 更新，到通知 Watcher 异步更新视图的流程，也就是下图中的橙色部分。</p></blockquote> <p><img src="./vue异步更新_files/59.png" alt="" class="medium-zoom-image"></p> <p><strong>我们先来回顾一下图中的几个对象：</strong></p> <ul><li>Data 对象：Vue 中的 data 方法中返回的对象。</li> <li>Dep 对象：每一个 Data 属性都会创建一个 Dep，用来搜集所有使用到这个 Data 的 Watcher 对象。</li> <li>Watcher 对象：主要用于渲染 DOM。</li></ul> <p>接下来，我们就开始分析这个流程。</p> <h2 id="vue-异步更新-dom-原理"><a href="http://interview.poetries.top/principle-docs/vue/11-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0.html#vue-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0-dom-%E5%8E%9F%E7%90%86" class="header-anchor">#</a> Vue 异步更新 DOM 原理</h2> <blockquote><p>很多同学都知道，Vue 中的数据更新是异步的，意味着我们在修改完 Data 之后，并不能立刻获取修改后的 DOM 元素。</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{ message }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>changeData<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      changeData
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      message<span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> textContent <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>
      <span class="token comment">// 直接获取，不是最新的</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>textContent <span class="token operator">===</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
            <span class="token comment">// $nextTick 回调中，是最新的</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> textContent <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>textContent <span class="token operator">===</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>什么时候我们才能获取到真正的 DOM 元素？</strong></p> <blockquote><p>答：在 Vue 的 nextTick 回调中。</p></blockquote> <p>这一点在 Vue 官网有详细的介绍，但你是否有想过，为什么 Vue 需要通过 nextTick 方法才能获取最新的 DOM？</p> <p>带着这个疑问，我们直接看一下源码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当一个 Data 更新时，会依次执行以下代码</span>
<span class="token comment">// 1. 触发 Data.set</span>
<span class="token comment">// 2. 调用 dep.notify</span>
<span class="token comment">// 3. Dep 会遍历所有相关的 Watcher 执行 update 方法</span>
<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token comment">// 4. 执行更新操作</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token parameter">watcher<span class="token operator">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 5. 将当前 Watcher 添加到异步队列</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 6. 执行异步队列，并传入回调</span>
  <span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 更新视图的具体方法</span>
<span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> watcher<span class="token punctuation">,</span> id<span class="token punctuation">;</span>
  <span class="token comment">// 排序，先渲染父节点，再渲染子节点</span>
  <span class="token comment">// 这样可以避免不必要的子节点渲染，如：父节点中 v-if 为 false 的子节点，就不用渲染了</span>
  queue<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">-</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历所有 Watcher 进行批量更新。</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新 DOM</span>
    watcher<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据上面的代码，我们可以得出这样一个流程图：</p> <p><img src="./vue异步更新_files/60.png" alt="" class="medium-zoom-image"></p> <blockquote><p>图中可以看到，Vue 在调用 Watcher 更新视图时，并不会直接进行更新，而是把需要更新的 Watcher 加入到 Queue 队列里，然后把具体的更新方法 flushSchedulerQueue 传给 nextTick 进行调用。</p></blockquote> <p>接下来，我们分析一下 <code>nextTick</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> timerFunc<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb<span class="token operator">?</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> ctx<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _resolve<span class="token punctuation">;</span>
  <span class="token comment">// 1.将传入的 flushSchedulerQueue 方法添加到回调数组</span>
  callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 2.执行异步任务</span>
  <span class="token comment">// 此方法会根据浏览器兼容性，选用不同的异步策略</span>
  <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>可以看到，nextTick 函数非常简单，它只是将传入的 flushSchedulerQueue 添加到 callbacks 数组中，然后执行了 timerFunc 方法。</p></blockquote> <p>接下来，我们分析一下 timerFunc 方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> timerFunc<span class="token punctuation">;</span>
<span class="token comment">// 判断是否兼容 Promise</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断是否兼容 MutationObserver</span>
  <span class="token comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> MutationObserver <span class="token operator">!==</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    characterData<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>
    textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断是否兼容 setImmediate</span>
  <span class="token comment">// 该方法存在一些 IE 浏览器中</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这是一个宏任务，但相比 setTimeout 要更好</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果以上方法都不知道，使用 setTimeout 0</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 异步执行完后，执行所有的回调方法，也就是执行 flushSchedulerQueue</span>
<span class="token keyword">function</span> <span class="token function">flushCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    callbacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>可以看到，timerFunc 是根据浏览器兼容性创建的一个异步方法，它执行完成之后，会调用 flushSchedulerQueue 方法进行具体的 DOM 更新。</p></blockquote> <p>分析到这里，我们就可以得到一张整体的流程图了。</p> <p><img src="./vue异步更新_files/61.png" alt="" class="medium-zoom-image"></p> <p><strong>接下来，我们来完善一些判断逻辑。</strong></p> <ul><li>判断 has 标识，避免在一个 Queue 中添加相同的 Watcher。</li> <li>判断 waiting 标识，让所有的 Watcher 都在一个 tick 内进行更新。</li> <li>判断 flushing 标识，处理 Watcher 渲染时，可能产生的新 Watcher。</li> <li>如：触发了 v-if 的条件，新增的 Watcher 渲染。</li></ul> <p>结合以上判断，最终的流程图如下：</p> <p><img src="./vue异步更新_files/62.png" alt="" class="medium-zoom-image"></p> <blockquote><p>最后，我们分析一下，为什么 this.$nextTick 能够获取更新后的 DOM？</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 我们使用 this.$nextTick 其实就是调用 nextTick 方法</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$nextTick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">nextTick</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>可以看到，调用 <code>this.$nextTick</code> 其实就是调用了图中的 nextTick 方法，在异步队列中执行回调函数。根据先来后到原则，修改 Data 触发的更新异步队列会先得到执行，执行完成后就生成了新的 DOM ，接下来执行 <code>this.$nextTick</code> 的回调函数时，能获取到更新后的 DOM 元素了。</li> <li>由于 nextTick 只是单纯通过 Promise 、SetTimeout 等方法模拟的异步任务，所以也可以手动执行一个异步任务，来实现和 <code>this.$nextTick</code> 相同的效果。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
<span class="token comment">// 手动执行一个异步任务，也能获取最新的 DOM</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> textContent <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>textContent <span class="token operator">===</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> textContent <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>textContent <span class="token operator">===</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="总结"><a href="http://interview.poetries.top/principle-docs/vue/11-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0.html#%E6%80%BB%E7%BB%93" class="header-anchor">#</a> 总结</h2> <p>本文从源码的角度，介绍了 <code>Vue</code> 异步更新的原理，来简单回顾一下吧。</p> <ul><li>修改 Vue 中的 <code>Data</code> 时，就会触发所有和这个 Data 相关的 Watcher 进行更新。</li> <li>首先，会将所有的 <code>Watcher</code> 加入队列 Queue。</li> <li>然后，调用 <code>nextTick</code> 方法，执行异步任务。</li> <li>在异步任务的回调中，对 <code>Queue</code> 中的 <code>Watcher</code> 进行排序，然后执行对应的 DOM 更新。</li></ul></div> 
<!-- vuex -->
<div class="content__default"><blockquote><p>了解vuex核心概念请移步 https://vuex.vuejs.org/zh/</p></blockquote> <p><img src="./vuex_files/vuex.png" alt="img" class="medium-zoom-image"></p> <h2 id="一、初始vuex"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8Bvuex" class="header-anchor">#</a> 一、初始vuex</h2> <h3 id="_1-1-vuex是什么"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#_1-1-vuex%E6%98%AF%E4%BB%80%E4%B9%88" class="header-anchor">#</a> 1.1 vuex是什么</h3> <blockquote><ul><li><div class="language- extra-class"><pre class="language-text"><code>vuex
</code></pre></div><p>就是把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中供其他组件使用</p> <ul><li>父子组件通信时，我们通常会采用 <code>props + emit</code> 这种方式。但当通信双方不是父子组件甚至压根不存在相关联系，或者一个状态需要共享给多个组件时，就会非常麻烦，数据也会相当难维护</li></ul></li></ul></blockquote> <h3 id="_1-2-vuex中有什么"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#_1-2-vuex%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88" class="header-anchor">#</a> 1.2 vuex中有什么</h3> <div class="language- extra-class"><pre class="language-text"><code>const store = new Vuex.Store({
    state: {
        name: 'weish',
        age: 22
    },
    getters: {
        personInfo(state) {
            return `My name is ${state.name}, I am ${state.age}`;
        }
    }
    mutations: {
        SET_AGE(state, age) {
            commit(age, age);
        }
    },
    actions: {
        nameAsyn({commit}) {
            setTimeout(() =&gt; {
                commit('SET_AGE', 18);
            }, 1000);
        }
    },
    modules: {
        a: modulesA
    }
}
</code></pre></div><blockquote><p>个就是最基本也是完整的<code>vuex</code>代码；<code>vuex</code> 包含有五个基本的对象</p></blockquote> <ul><li><code>state</code>：存储状态。也就是变量；</li> <li><code>getters</code>：派生状态。也就是<code>set</code>、<code>get</code>中的<code>get</code>，有两个可选参数：<code>state</code>、<code>getters</code>分别可以获取<code>state</code>中的变量和其他的<code>getters</code>。外部调用方式：<code>store.getters.personInfo()</code>。就和<code>vue</code>的<code>computed</code>差不多；</li> <li><code>mutations</code>：提交状态修改。也就是<code>set</code>、<code>get</code>中的<code>set</code>，这是<code>vuex</code>中唯一修改<code>state</code>的方式，但不支持异步操作。第一个参数默认是<code>state</code>。外部调用方式：<code>store.commit('SET_AGE', 18)</code>。和<code>vue</code>中的<code>methods</code>类似。</li> <li><code>actions</code>：和<code>mutations</code>类似。不过<code>actions</code>支持异步操作。第一个参数默认是和<code>store</code>具有相同参数属性的对象。外部调用方式：<code>store.dispatch('nameAsyn')</code>。</li> <li><code>modules</code>：<code>store</code>的子模块，内容就相当于是<code>store</code>的一个实例。调用方式和前面介绍的相似，只是要加上当前子模块名，如：<code>store.a.getters.xxx()</code></li></ul> <h3 id="_1-3-vue-cli中使用vuex的方式"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#_1-3-vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8vuex%E7%9A%84%E6%96%B9%E5%BC%8F" class="header-anchor">#</a> 1.3 vue-cli中使用vuex的方式</h3> <p><strong>目录结构</strong></p> <div class="language- extra-class"><pre class="language-text"><code>├── index.html
├── main.js
├── components
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── state.js          # 跟级别的 state
    ├── getters.js        # 跟级别的 getter
    ├── mutation-types.js # 根级别的mutations名称（官方推荐mutions方法名使用大写）
    ├── mutations.js      # 根级别的 mutation
    ├── actions.js        # 根级别的 action
    └── modules
        ├── m1.js         # 模块1
        └── m2.js         # 模块2
</code></pre></div><p><strong>state示例</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const state = {
    name: 'weish',
    age: 22
};

export default state;
</code></pre></div><p><strong>getter示例</strong></p> <blockquote><p><code>getters.js</code>示例（我们一般使用<code>getters</code>来获取<code>state</code>的状态，而不是直接使用<code>state</code>）</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export const name = (state) =&gt; {
    return state.name;
}

export const age = (state) =&gt; {
    return state.age
}

export const other = (state) =&gt; {
    return `My name is ${state.name}, I am ${state.age}.`;
}
</code></pre></div><p><strong>mutation-type示例</strong></p> <blockquote><p>将所有<code>mutations</code>的函数名放在这个文件里</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export const SET_NAME = 'SET_NAME';
export const SET_AGE = 'SET_AGE';
</code></pre></div><p><strong>mutations示例</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import * as types from './mutation-type.js';

export default {
    [types.SET_NAME](state, name) {
        state.name = name;
    },
    [types.SET_AGE](state, age) {
        state.age = age;
    }
};
</code></pre></div><p><strong>actions示例</strong></p> <blockquote><p>异步操作、多个<code>commit</code>时</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import * as types from './mutation-type.js';

export default {
    nameAsyn({commit}, {age, name}) {
        commit(types.SET_NAME, name);
        commit(types.SET_AGE, age);
    }
}
</code></pre></div><p><strong>modules–m1.js示例</strong></p> <blockquote><p>如果不是很复杂的应用，一般来讲是不会分模块的</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export default {
    state: {},
    getters: {},
    mutations: {},
    actions: {}
}
</code></pre></div><p><strong>index.js示例（组装vuex)</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import vue from 'vue';
import vuex from 'vuex';
import state from './state.js';
import * as getters from './getters.js';
import mutations from './mutations.js';
import actions from './actions.js';
import m1 from './modules/m1.js';
import m2 from './modules/m2.js';
import createLogger from 'vuex/dist/logger'; // 修改日志

vue.use(vuex);

const debug = process.env.NODE_ENV !== 'production'; // 开发环境中为true，否则为false

export default new vuex.Store({
    state,
    getters,
    mutations,
    actions,
    modules: {
        m1,
        m2
    },
    plugins: debug ? [createLogger()] : [] // 开发环境下显示vuex的状态修改
});
</code></pre></div><blockquote><p>最后将<code>store</code>实例挂载到<code>main.js</code>里面的<code>vue</code>上去就行了</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import store from './store/index.js';

new Vue({
  el: '#app',
  store,
  render: h =&gt; h(App)
});
</code></pre></div><blockquote><p>在<code>vue</code>组件中使用时，我们通常会使用<code>mapGetters</code>、<code>mapActions</code>、<code>mapMutations</code>，然后就可以按照<code>vue</code>调用<code>methods</code>和<code>computed</code>的方式去调用这些变量或函数，示例如</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import {mapGetters, mapMutations, mapActions} from 'vuex';

/* 只写组件中的script部分 */
export default {
    computed: {
        ...mapGetters([
            name,
            age
        ])
    },
    methods: {
        ...mapMutations({
            setName: 'SET_NAME',
            setAge: 'SET_AGE'
        }),
        ...mapActions([
            nameAsyn
        ])
    }
};
</code></pre></div><h2 id="二、modules"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#%E4%BA%8C%E3%80%81modules" class="header-anchor">#</a> 二、modules</h2> <blockquote><p>在 src 目录下 , 新建一个 store 文件夹 , 然后在里面新建一个 index.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'
import vuex from 'vuex'
Vue.use(vuex);

export default new vuex.Store({
    state:{
        show:false
    }
})
</code></pre></div><blockquote><p>在 <code>main.js</code> 里的代码应该改成,在实例化 <code>Vue</code>对象时加入 <code>store</code> 对象</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//vuex
import store from './store'

new Vue({
  el: '#app',
  router,
  store,//使用store
  template: '&lt;App/&gt;',
  components: { App }
})
</code></pre></div><blockquote><p>这样就把 <code>store</code> 分离出去了 , 那么还有一个问题是 : 这里 <code>$store.state.show</code> 无论哪个组件都可以使用 , 那组件多了之后 , 状态也多了 , 这么多状态都堆在 store 文件夹下的 <code>index.js</code> 不好维护怎么办 ?</p></blockquote> <ul><li>我们可以使用 <code>vuex</code> 的 <code>modules</code> , 把 <code>store</code> 文件夹下的 <code>index.js</code> 改成</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'
import vuex from 'vuex'
Vue.use(vuex);

import dialog_store from '../components/dialog_store.js';//引入某个store对象

export default new vuex.Store({
    modules: {
        dialog: dialog_store
    }
})
</code></pre></div><blockquote><p>这里我们引用了一个 <code>dialog_store.js</code> , 在这个 <code>js</code>文件里我们就可以单独写 <code>dialog</code> 组件的状态了</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export default {
    state:{
        show:false
    }
}
</code></pre></div><blockquote><p>做出这样的修改之后 , 我们将之前我们使用的 <code>$store.state.show</code> 统统改为 <code>$store.state.dialog.show</code> 即可</p></blockquote> <ul><li>如果还有其他的组件需要使用 <code>vuex</code> , 就新建一个对应的状态文件 , 然后将他们加入 <code>store</code>文件夹下的 <code>index.js</code>文件中的 <code>modules</code> 中</li></ul> <div class="language- extra-class"><pre class="language-text"><code>modules: {
    dialog: dialog_store,
    other: other,//其他组件
}
</code></pre></div><h2 id="三、mutations"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#%E4%B8%89%E3%80%81mutations" class="header-anchor">#</a> 三、mutations</h2> <blockquote><p>对<code>vuex</code> 的依赖仅仅只有一个 <code>$store.state.dialog.show</code> 一个状态 , 但是如果我们要进行一个操作 , 需要依赖很多很多个状态 , 那管理起来又麻烦了</p></blockquote> <ul><li><code>mutations</code>里的操作必须是同步的</li></ul> <div class="language- extra-class"><pre class="language-text"><code>export default {
    state:{//state
        show:false
    },
    mutations:{
        switch_dialog(state){//这里的state对应着上面这个state
            state.show = state.show?false:true;
            //你还可以在这里执行其他的操作改变state
        }
    }
}
</code></pre></div><blockquote><p>使用 <code>mutations</code> 后 , 原先我们的父组件可以改为</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;a href="javascript:;" @click="$store.commit('switch_dialog')"&gt;点击&lt;/a&gt;
    &lt;t-dialog&gt;&lt;/t-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import dialog from './components/dialog.vue'
export default {
  components:{
    "t-dialog":dialog
  }
}
&lt;/script&gt;
</code></pre></div><blockquote><p>使用 <code>$store.commit('switch_dialog')</code> 来触发 <code>mutations</code> 中的 <code>switch_dialog</code> 方法</p></blockquote> <h2 id="四、actions"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#%E5%9B%9B%E3%80%81actions" class="header-anchor">#</a> 四、actions</h2> <blockquote><p>多个 <code>state</code> 的操作 , 使用 <code>mutations</code>会来触发会比较好维护 , 那么需要执行多个 <code>mutations</code> 就需要用 <code>action</code> 了</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export default {
    state:{//state
        show:false
    },
    mutations:{
        switch_dialog(state){//这里的state对应着上面这个state
            state.show = state.show?false:true;
            //你还可以在这里执行其他的操作改变state
        }
    },
    actions:{
        switch_dialog(context){//这里的context和我们使用的$store拥有相同的对象和方法
            context.commit('switch_dialog');
            //你还可以在这里触发其他的mutations方法
        },
    }
}
</code></pre></div><blockquote><p>那么 , 在之前的父组件中 , 我们需要做修改 , 来触发 <code>action</code> 里的 <code>switch_dialog</code> 方法</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;a href="javascript:;" @click="$store.dispatch('switch_dialog')"&gt;点击&lt;/a&gt;
    &lt;t-dialog&gt;&lt;/t-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import dialog from './components/dialog.vue'
export default {
  components:{
    "t-dialog":dialog
  }
}
&lt;/script&gt;
</code></pre></div><ul><li>使用 <code>$store.dispatch('switch_dialog')</code> 来触发 <code>action</code> 中的 <code>switch_dialog</code> 方法。</li> <li>官方推荐 , 将异步操作放在 <code>action</code>中</li></ul> <h2 id="五、getters"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#%E4%BA%94%E3%80%81getters" class="header-anchor">#</a> 五、getters</h2> <blockquote><p><code>getters</code>和 <code>vue</code> 中的<code>computed</code> 类似 , 都是用来计算 <code>state</code> 然后生成新的数据 ( 状态 ) 的</p></blockquote> <ul><li>假如我们需要一个与状态 <code>show</code> 刚好相反的状态 , 使用 <code>vue</code> 中的 <code>computed</code> 可以这样算出来</li></ul> <div class="language- extra-class"><pre class="language-text"><code>computed(){
    not_show(){
        return !this.$store.state.dialog.show;
    }
}
</code></pre></div><blockquote><p>那么 , 如果很多很多个组件中都需要用到这个与 <code>show</code>刚好相反的状态 , 那么我们需要写很多很多个 <code>not_show</code>, 使用 <code>getters</code>就可以解决这种问题</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export default {
    state:{//state
        show:false
    },
    getters:{
        not_show(state){//这里的state对应着上面这个state
            return !state.show;
        }
    },
    mutations:{
        switch_dialog(state){//这里的state对应着上面这个state
            state.show = state.show?false:true;
            //你还可以在这里执行其他的操作改变state
        }
    },
    actions:{
        switch_dialog(context){//这里的context和我们使用的$store拥有相同的对象和方法
            context.commit('switch_dialog');
            //你还可以在这里触发其他的mutations方法
        },
    }
}
</code></pre></div><blockquote><p>我们在组件中使用 <code>$store.state.dialog.show</code> 来获得状态 <code>show</code> , 类似的 , 我们可以使用 <code>$store.getters.not_show</code> 来获得状态 <code>not_show</code></p></blockquote> <ul><li>注意 : <code>$store.getters.not_show</code> 的值是不能直接修改的 , 需要对应的 <code>state</code> 发生变化才能修改</li></ul> <h2 id="六、mapstate、mapgetters、mapactions"><a href="http://interview.poetries.top/principle-docs/vue/14-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html#%E5%85%AD%E3%80%81mapstate%E3%80%81mapgetters%E3%80%81mapactions" class="header-anchor">#</a> 六、mapState、mapGetters、mapActions</h2> <blockquote><p>很多时候 , <code>$store.state.dialog.show</code> 、<code>$store.dispatch('switch_dialog')</code> 这种写法很不方便</p></blockquote> <ul><li>使用 <code>mapState</code>、<code>mapGetters</code>、<code>mapActions</code> 就不会这么复杂了</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;
&lt;/template&gt;

&lt;script&gt;
import {mapState} from 'vuex';
export default {
  computed:{

    //这里的三点叫做 : 扩展运算符
    ...mapState({
      show:state=&gt;state.dialog.show
    }),
  }
}
&lt;/script&gt;
</code></pre></div><p>相当于</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;
&lt;/template&gt;

&lt;script&gt;
import {mapState} from 'vuex';
export default {
  computed:{
    show(){
        return this.$store.state.dialog.show;
    }
  }
}
&lt;/script&gt;
</code></pre></div><blockquote><p><code>mapGetters</code>、<code>mapActions</code> 和 <code>mapState</code> 类似 , <code>mapGetters</code> 一般也写在 <code>computed</code> 中 , <code>mapActions</code> 一般写在 <code>methods</code> 中</p></blockquote></div> 


<!-- 虚拟dom -->
<div class="content__default"><h2 id="什么是-virtual-dom"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom" class="header-anchor">#</a> 什么是 Virtual DOM</h2> <ol><li><code>Virtual DOM</code>(虚拟 DOM)，是由普通的 <code>JS</code> 对象来描述 <code>DOM</code> 对象，因为不是真实的 <code>DOM</code> 对象，所以叫 <code>Virtual DOM</code></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span> 
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  s <span class="token operator">+=</span> key <span class="token operator">+</span> <span class="token string">','</span> 
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">
  (</span>s<span class="token punctuation">)</span>

<span class="token comment">// 打印结果 align,title,lang,translate,dir,hidden,accessKey,draggable,spellcheck,aut ocapitalize,contentEditable,isContentEditable,inputMode,offsetParent,off setTop,offsetLeft,offsetWidth,offsetHeight,style,innerText,outerText,onc opy,oncut,onpaste,onabort,onblur,oncancel,oncanplay,oncanplaythrough,onc hange,onclick,onclose,oncontextmenu,oncuechange,ondblclick,ondrag,ondrag end,ondragenter,ondragleave,ondragover,ondragstart,ondrop,ondurationchan ge,onemptied,onended,onerror,onfocus,oninput,oninvalid,onkeydown,onkeypr ess,onkeyup,onload,onloadeddata,onloadedmetadata,onloadstart,onmousedown ,onmouseenter,onmouseleave,onmousemove,onmouseout,onmouseover,onmouseup, onmousewheel,onpause,onplay,onplaying,onprogress,onratechange,onreset,on resize,onscroll,onseeked,onseeking,onselect,onstalled,onsubmit,onsuspend ,ontimeupdate,ontoggle,onvolumechange,onwaiting,onwheel,onauxclick,ongot pointercapture,onlostpointercapture,onpointerdown,onpointermove,onpointe rup,onpointercancel,onpointerover,onpointerout,onpointerenter,onpointerl eave,onselectstart,onselectionchange,onanimationend,onanimationiteration ,onanimationstart,ontransitionend,dataset,nonce,autofocus,tabIndex,click ,focus,blur,enterKeyHint,onformdata,onpointerrawupdate,attachInternals,n amespaceURI,prefix,localName,tagName,id,className,classList,slot,part,at tributes,shadowRoot,assignedSlot,innerHTML,outerHTML,scrollTop,scrollLef t,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight ,attributeStyleMap,onbeforecopy,onbeforecut,onbeforepaste,onsearch,eleme ntTiming,previousElementSibling,nextElementSibling,children,firstElement Child,lastElementChild,childElementCount,onfullscreenchange,onfullscreen error,onwebkitfullscreenchange,onwebkitfullscreenerror,setPointerCapture ,releasePointerCapture,hasPointerCapture,hasAttributes,getAttributeNames ,getAttribute,getAttributeNS,setAttribute,setAttributeNS,removeAttribute ,removeAttributeNS,hasAttribute,hasAttributeNS,toggleAttribute,getAttrib uteNode,getAttributeNodeNS,setAttributeNode,setAttributeNodeNS,removeAtt ributeNode,closest,matches,webkitMatchesSelector,attachShadow,getElement sByTagName,getElementsByTagNameNS,getElementsByClassName,insertAdjacentE lement,insertAdjacentText,insertAdjacentHTML,requestPointerLock,getClien tRects,getBoundingClientRect,scrollIntoView,scroll,scrollTo,scrollBy,scr ollIntoViewIfNeeded,animate,computedStyleMap,before,after,replaceWith,re move,prepend,append,querySelector,querySelectorAll,requestFullscreen,web kitRequestFullScreen,webkitRequestFullscreen,createShadowRoot,getDestina tionInsertionPoints,ELEMENT_NODE,ATTRIBUTE_NODE,TEXT_NODE,CDATA_SECTION_ NODE,ENTITY_REFERENCE_NODE,ENTITY_NODE,PROCESSING_INSTRUCTION_NODE,COMME NT_NODE,DOCUMENT_NODE,DOCUMENT_TYPE_NODE,DOCUMENT_FRAGMENT_NODE,NOTATION _NODE,DOCUMENT_POSITION_DISCONNECTED,DOCUMENT_POSITION_PRECEDING,DOCUMEN T_POSITION_FOLLOWING,DOCUMENT_POSITION_CONTAINS,DOCUMENT_POSITION_CONTAI NED_BY,DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC,nodeType,nodeName,baseU RI,isConnected,ownerDocument,parentNode,parentElement,childNodes,firstCh ild,lastChild,previousSibling,nextSibling,nodeValue,textContent,hasChild Nodes,getRootNode,normalize,cloneNode,isEqualNode,isSameNode,compareDocu mentPosition,contains,lookupPrefix,lookupNamespaceURI,isDefaultNamespace ,insertBefore,appendChild,replaceChild,removeChild,addEventListener,remo veEventListener,dispatchEvent</span>
</code></pre></div><ol start="2"><li>可以使用 <code>Virtual DOM</code> 来描述真实 <code>DOM</code></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  sel<span class="token operator">:</span> <span class="token string">"div"</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  children<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  text<span class="token operator">:</span> <span class="token string">"Hello Virtual DOM"</span><span class="token punctuation">,</span>
  elm<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token keyword">undefined</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为什么使用-virtual-dom"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-virtual-dom" class="header-anchor">#</a> 为什么使用 Virtual DOM</h2> <ul><li>手动操作 <code>DOM</code> 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 <code>jQuery</code> 等库简化 <code>DOM</code> 操作，但是随着项目的复杂 DOM 操作复杂提升</li> <li>为了简化 <code>DOM</code> 的复杂操作于是出现了各种 <code>MVVM</code> 框架，<code>MVVM</code> 框架解决了视图和状态的同步问题</li> <li>为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是<code>Virtual DOM</code> 出现了</li> <li><code>Virtual DOM</code> 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述<code>DOM</code>，<code>Virtual DOM</code> 内部将弄清楚如何有效(<code>diff</code>)的更新 <code>DOM</code></li> <li>虚拟 <code>DOM</code> 可以维护程序的状态，跟踪上一次的状态</li> <li>通过比较前后两次状态的差异更新真实 <code>DOM</code></li></ul> <h2 id="虚拟-dom-的作用"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#%E8%99%9A%E6%8B%9F-dom-%E7%9A%84%E4%BD%9C%E7%94%A8" class="header-anchor">#</a> 虚拟 DOM 的作用</h2> <ul><li>维护视图和状态的关系</li> <li>复杂视图情况下提升渲染性能</li> <li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li></ul> <p><img src="./原理_files/20210328112610.png" alt="" class="medium-zoom-image"></p> <h2 id="virtual-dom-库"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#virtual-dom-%E5%BA%93" class="header-anchor">#</a> Virtual DOM 库</h2> <ul><li><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">Snabbdom<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li><code>Vue 2.x</code> 内部使用的 <code>Virtual DOM</code> 就是改造的 <code>Snabbdom</code></li> <li>通过模块可扩展</li> <li>源码使用 <code>TypeScript</code> 开发</li> <li>最快的 <code>Virtual DOM</code> 之一</li></ul></li> <li><a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener noreferrer">virtual-dom<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="snabbdom-基本使用"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#snabbdom-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="header-anchor">#</a> Snabbdom 基本使用</h2> <h3 id="创建项目"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE" class="header-anchor">#</a> 创建项目</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 创建项目目录</span>
md snabbdom-demo
<span class="token comment"># 进入项目目录</span>
<span class="token builtin class-name">cd</span> snabbdom-demo
<span class="token comment"># 创建 package.json yarn init -y</span>
<span class="token comment"># 本地安装 parcel</span>
<span class="token function">yarn</span> <span class="token function">add</span> parcel-bundler
</code></pre></div><p>配置 <code>package.json</code> 的 <code>scripts</code></p> <div class="language- extra-class"><pre class="language-text"><code>"scripts": {
"dev": "parcel index.html --open", "build": "parcel build index.html"
}
</code></pre></div><p>创建目录结构</p> <p><img src="./原理_files/20210328123653.png" alt="" class="medium-zoom-image"></p> <div class="language- extra-class"><pre class="language-text"><code>yarn add snabbdom
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import{init,h,thunk}from'snabbdom'
</code></pre></div><blockquote><p><code>snabbdom</code> 的核心仅提供最基本的功能，只导出了三个函数 <code>init()</code>、<code>h()</code>、<code>thunk()</code></p></blockquote> <ul><li><code>init()</code> 是一个高阶函数，返回 <code>patch()</code></li> <li><code>h()</code> 返回虚拟节点 <code>VNode</code>，这个函数我们在使用 <code>Vue.js</code> 的时候见过</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  router<span class="token punctuation">,</span>
  store<span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>thunk()</code> 是一种优化策略，可以在处理不可变数据时使用</li></ul> <blockquote><p>注意:导入时候不能使用 <code>import snabbdom from 'snabbdom'</code>。原因:<code>node_modules/src/snabbdom.ts</code> 末尾导出使用的语法是 <code>export</code> 导出 <code>API</code>，没有使用 <code>export default</code> 导出默认输出</p></blockquote> <p><img src="./原理_files/20210328124133.png" alt="" class="medium-zoom-image"></p> <h3 id="基本使用"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="header-anchor">#</a> 基本使用</h3> <p><strong>例子1</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> init <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>

<span class="token comment">// 1. hello world</span>
<span class="token comment">// 参数：数组，模块</span>
<span class="token comment">// 返回值：patch函数，作用对比两个vnode的差异更新到真实DOM</span>
<span class="token keyword">let</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 第一个参数：标签+选择器</span>
<span class="token comment">// 第二个参数：如果是字符串的话就是标签中的内容</span>
<span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div#container.cls'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> 
  hook<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">init</span> <span class="token punctuation">(</span><span class="token parameter">vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">create</span> <span class="token punctuation">(</span><span class="token parameter">emptyVnode<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'Hello World'</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token comment">// 第一个参数：可以是DOM元素，内部会把DOM元素转换成VNode</span>
<span class="token comment">// 第二个参数：VNode</span>
<span class="token comment">// 返回值：VNde</span>
<span class="token keyword">let</span> oldVnode <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

<span class="token comment">// 假设的时刻</span>
vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token string">'Hello Snabbdom'</span><span class="token punctuation">)</span>

<span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><p><strong>例子2</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2. div中放置子元素 h1,p</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> init <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>

<span class="token keyword">let</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div#container'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token string">'Hello Snabbdom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'这是一个p标签'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> oldVnode <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div#container'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'Hello P'</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

  <span class="token comment">// 清空页面元素 -- 错误</span>
  <span class="token comment">// patch(oldVnode, null)</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>例子3 debug-patchVnode</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> init <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>

<span class="token keyword">let</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 首次渲染</span>
<span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token string">'Hello World'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> oldVnode <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

<span class="token comment">// patchVnode 的执行过程</span>
vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token string">'Hello Snabbdom'</span><span class="token punctuation">)</span>
<span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><p><strong>例子4 debug-updateChildren</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> init <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>

<span class="token keyword">let</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 首次渲染</span>
<span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token string">'首页'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token string">'视频'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token string">'微博'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> oldVnode <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

<span class="token comment">// updateChildren 的执行过程</span>
vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token string">'首页'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token string">'微博'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token string">'视频'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><p><strong>例子5 debug-updateChildren-key</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> init <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>

<span class="token keyword">let</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 首次渲染</span>
<span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'首页'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'视频'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'微博'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> oldVnode <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

<span class="token comment">// updateChildren 的执行过程</span>
vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'首页'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'微博'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'视频'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><h3 id="模块"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#%E6%A8%A1%E5%9D%97" class="header-anchor">#</a> 模块</h3> <blockquote><p><code>Snabbdom</code> 的核心库并不能处理元素的<code>属性/样式/事件</code>等，如果需要处理的话，可以使用模块</p></blockquote> <p><strong>常用模块</strong></p> <p>官方提供了 6 个模块</p> <ul><li><code>attributes</code> <ul><li>设置 <code>DOM</code> 元素的属性，使用 <code>setAttribute ()</code></li> <li>处理布尔类型的属性</li></ul></li> <li><code>props</code> <ul><li>和 <code>attributes</code> 模块相似，设置 <code>DOM</code> 元素的属性 <code>element[attr] = value</code></li> <li>不处理布尔类型的属性</li></ul></li> <li><code>class</code> <ul><li>切换类样式</li> <li>注意:给元素设置类样式是通过 <code>sel</code> 选择器</li></ul></li> <li><code>dataset</code> <ul><li>设置 <code>data-*</code> 的自定义属性 <code>eventlisteners</code></li> <li>注册和移除事件</li></ul></li> <li><code>style</code> <ul><li>设置行内样式，支持动画</li> <li><code>delayed/remove/destroy</code></li></ul></li></ul> <p><strong>模块使用</strong></p> <blockquote><p>模块使用步骤:</p></blockquote> <ul><li>导入需要的模块</li> <li><code>init()</code> 中注册模块</li> <li>使用 <code>h()</code> 函数创建 <code>VNode</code> 的时候，可以把第二个参数设置为对象，其他参数往后移</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> init<span class="token punctuation">,</span> h <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'snabbdom'</span>
<span class="token comment">// 1. 导入模块</span>
<span class="token keyword">import</span> style <span class="token keyword">from</span> <span class="token string">'snabbdom/modules/style'</span>
<span class="token keyword">import</span> eventlisteners <span class="token keyword">from</span> <span class="token string">'snabbdom/modules/eventlisteners'</span>
<span class="token comment">// 2. 注册模块</span>
<span class="token keyword">let</span> patch <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  style<span class="token punctuation">,</span>
  eventlisteners
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 3. 使用 h() 函数的第二个参数传入模块需要的数据（对象）</span>
<span class="token keyword">let</span> vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  style<span class="token operator">:</span> <span class="token punctuation">{</span>
    backgroundColor<span class="token operator">:</span> <span class="token string">'red'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  on<span class="token operator">:</span> <span class="token punctuation">{</span>
    click<span class="token operator">:</span> eventHandler
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token string">'Hello Snabbdom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'这是p标签'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">eventHandler</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'点击我了'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> oldVnode <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>


vnode <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><h2 id="snabbdom-源码解析"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#snabbdom-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" class="header-anchor">#</a> Snabbdom 源码解析</h2> <h3 id="snabbdom-的核心"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#snabbdom-%E7%9A%84%E6%A0%B8%E5%BF%83" class="header-anchor">#</a> Snabbdom 的核心</h3> <ul><li>使用 <code>h()</code> 函数创建 JavaScript 对象(<code>VNode</code>)描述真实 DOM</li> <li><code>init()</code> 设置模块，创建 <code>patch()</code></li> <li><code>patch()</code> 比较新旧两个 <code>VNode</code></li> <li>把变化的内容更新到真实 <code>DOM</code> 树上</li></ul> <p><strong>Snabbdom 源码</strong></p> <blockquote><p>源码地址: https://github.com/snabbdom/snabbdom</p></blockquote> <p>src 目录结构</p> <p><img src="./原理_files/20210328125857.png" alt="" class="medium-zoom-image"></p> <h3 id="h-函数"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#h-%E5%87%BD%E6%95%B0" class="header-anchor">#</a> h 函数</h3> <ul><li><code>h()</code> 函数介绍: 在使用 <code>Vue</code> 的时候见过 <code>h()</code> 函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  router<span class="token punctuation">,</span>
  store<span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>h()</code> 函数最早见于 <code>hyperscript</code>，使用 JavaScript 创建超文本</li> <li>Snabbdom 中的 <code>h()</code> 函数不是用来创建超文本，而是创建 <code>VNode</code></li></ul> <p><strong>函数重载</strong></p> <ul><li>概念</li> <li>参数个数或类型不同的函数</li> <li><code>JavaScript</code> 中没有重载的概念</li> <li><code>TypeScript</code> 中有重载，不过重载的实现还是通过代码调整参数</li> <li>重载的示意</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>源码位置:<code>src/h.ts</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// h函数的重载</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token parameter">sel<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token parameter">sel<span class="token operator">:</span> string<span class="token punctuation">,</span> data<span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> VNode
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token parameter">sel<span class="token operator">:</span> string<span class="token punctuation">,</span> children<span class="token operator">:</span> VNodeChildren</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token parameter">sel<span class="token operator">:</span> string<span class="token punctuation">,</span> data<span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> children<span class="token operator">:</span> VNodeChildren</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token parameter">sel<span class="token operator">:</span> any<span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">,</span> c<span class="token operator">?</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
  <span class="token keyword">let</span> data<span class="token operator">:</span> VNodeData <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">let</span> children<span class="token operator">:</span> any
  <span class="token keyword">let</span> text<span class="token operator">:</span> any
  <span class="token keyword">let</span> i<span class="token operator">:</span> number
  <span class="token comment">// 处理参数，实现重载的机制</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理三个参数的情况</span>
    <span class="token comment">// sel、data、children/text</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      data <span class="token operator">=</span> b
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> c
      <span class="token comment">// 如果 c 是字符串或者数字</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">primitive</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      text <span class="token operator">=</span> c
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>sel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> b <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理两个参数的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> b
      <span class="token comment">// 如果 b 是字符串或者数字</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">primitive</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      text <span class="token operator">=</span> b
      <span class="token comment">// 如果 b 是 VNode</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>sel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> data <span class="token operator">=</span> b <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理 children 中的原始值(string/number)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 child 是 string/number，创建文本节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">primitive</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">vnode</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    sel<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'s'</span> <span class="token operator">&amp;&amp;</span> sel<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'v'</span> <span class="token operator">&amp;&amp;</span> sel<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'g'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>sel<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">||</span> sel<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'.'</span> <span class="token operator">||</span> sel<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'#'</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是 svg，添加命名空间</span>
    <span class="token function">addNS</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> children<span class="token punctuation">,</span> sel<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回 VNode</span>
  <span class="token keyword">return</span> <span class="token function">vnode</span><span class="token punctuation">(</span>sel<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span> text<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 导出模块</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> h<span class="token punctuation">;</span>
</code></pre></div><h3 id="vnode"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#vnode" class="header-anchor">#</a> VNode</h3> <blockquote><p>一个 <code>VNode</code> 就是一个虚拟节点用来描述一个 <code>DOM</code> 元素，如果这个 <code>VNode</code> 有 <code>children</code> 就是 <code>Virtual DOM</code></p></blockquote> <p>源码位置: <code>src/vnode.ts</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">VNodeData</span> <span class="token punctuation">{</span>
  props<span class="token operator">?</span><span class="token operator">:</span> Props
  attrs<span class="token operator">?</span><span class="token operator">:</span> Attrs
  <span class="token keyword">class</span><span class="token operator">?</span><span class="token operator">:</span> Classes
  style<span class="token operator">?</span><span class="token operator">:</span> VNodeStyle
  dataset<span class="token operator">?</span><span class="token operator">:</span> Dataset
  on<span class="token operator">?</span><span class="token operator">:</span> On
  hero<span class="token operator">?</span><span class="token operator">:</span> Hero
  attachData<span class="token operator">?</span><span class="token operator">:</span> AttachData
  hook<span class="token operator">?</span><span class="token operator">:</span> Hooks
  key<span class="token operator">?</span><span class="token operator">:</span> Key
  ns<span class="token operator">?</span><span class="token operator">:</span> string <span class="token comment">// for SVGs</span>
  fn<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> VNode <span class="token comment">// for thunks</span>
  args<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// for thunks</span>
  is<span class="token operator">?</span><span class="token operator">:</span> string <span class="token comment">// for custom elements v1</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> string<span class="token punctuation">]</span><span class="token operator">:</span> any <span class="token comment">// for any other 3rd party module</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// 选择器</span>
  sel<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 节点数据:属性/样式/事件等</span>
  data<span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 子节点，和 text 只能互斥</span>
  children<span class="token operator">:</span> Array<span class="token operator">&lt;</span>VNode <span class="token operator">|</span> string<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 记录 vnode 对应的真实 DOM</span>
  elm<span class="token operator">:</span> Node <span class="token operator">|</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 节点中的内容，和 children 只能互斥</span>
  text<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 优化用</span>
  key<span class="token operator">:</span> Key <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">vnode</span> <span class="token punctuation">(</span><span class="token parameter">sel<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> any <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  children<span class="token operator">:</span> Array<span class="token operator">&lt;</span>VNode <span class="token operator">|</span> string<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  text<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  elm<span class="token operator">:</span> Element <span class="token operator">|</span> Text <span class="token operator">|</span> <span class="token keyword">undefined</span></span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> data <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> data<span class="token punctuation">.</span>key
  <span class="token keyword">return</span> <span class="token punctuation">{</span> sel<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span> text<span class="token punctuation">,</span> elm<span class="token punctuation">,</span> key <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="snabbdom"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#snabbdom" class="header-anchor">#</a> snabbdom</h3> <ul><li><code>patch(oldVnode, newVnode)</code></li> <li>打补丁，把新节点中变化的内容渲染到真实 <code>DOM</code>，最后返回新节点作为下一次处理的旧节点</li> <li>对比新旧 <code>VNode</code> 是否相同节点(节点的 <code>key</code> 和 <code>sel</code> 相同)</li> <li>如果不是相同节点，删除之前的内容，重新渲染</li> <li>如果是相同节点，再判断新的 <code>VNode</code> 是否有 <code>text</code>，如果有并且和 <code>oldVnode</code> 的 <code>text</code> 不同，直接更 新文本内容</li> <li>如果新的 <code>VNode</code> 有 <code>children</code>，判断子节点是否有变化，判断子节点的过程使用的就是 <code>diff</code> 算法</li> <li><code>diff</code> 过程只进行同层级比较</li></ul> <p><img src="./原理_files/20210329091820.png" alt="" class="medium-zoom-image"></p> <h3 id="init"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#init" class="header-anchor">#</a> init</h3> <ul><li>功能: <code>init(modules, domApi)</code>，返回 <code>patch()</code>函数(高阶函数)</li> <li>为什么要使用高阶函数?
<ul><li>因为 <code>patch()</code> 函数再外部会调用多次，每次调用依赖一些参数，比如: <code>modules/domApi/cbs</code></li> <li>通过高阶函数让 <code>init()</code> 内部形成闭包，返回的 <code>patch()</code> 可以访问到 <code>modules/domApi/cbs</code>，而 不需要重新创建</li></ul></li> <li><code>init()</code> 在返回 <code>patch()</code> 之前，首先收集了所有模块中的钩子函数存储到 <code>cbs</code> 对象中</li></ul> <blockquote><p>源码位置:<code>src/init.ts</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">init</span> <span class="token punctuation">(</span><span class="token parameter">modules<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>Module<span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> domApi<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">DOMAPI</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token operator">:</span> number
  <span class="token keyword">let</span> j<span class="token operator">:</span> number
  <span class="token keyword">const</span> cbs<span class="token operator">:</span> ModuleHooks <span class="token operator">=</span> <span class="token punctuation">{</span>
    create<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    update<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    remove<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    destroy<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    pre<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    post<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> api<span class="token operator">:</span> <span class="token constant">DOMAPI</span> <span class="token operator">=</span> domApi <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> domApi <span class="token operator">:</span> htmlDomApi

  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hooks<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cbs<span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> modules<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> hook <span class="token operator">=</span> modules<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>hook <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span>cbs<span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">as</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>hook<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">patch</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token operator">:</span> VNode <span class="token operator">|</span> Element<span class="token punctuation">,</span> vnode<span class="token operator">:</span> VNode</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i<span class="token operator">:</span> number<span class="token punctuation">,</span> elm<span class="token operator">:</span> Node<span class="token punctuation">,</span> parent<span class="token operator">:</span> Node
    <span class="token keyword">const</span> insertedVnodeQueue<span class="token operator">:</span> VNodeQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldVnode <span class="token operator">=</span> <span class="token function">emptyNodeAt</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span>
      parent <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token keyword">as</span> Node

      <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token punctuation">[</span>oldVnode<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> insertedVnodeQueue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      insertedVnodeQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">!</span><span class="token punctuation">.</span>hook<span class="token operator">!</span><span class="token punctuation">.</span>insert<span class="token operator">!</span><span class="token punctuation">(</span>insertedVnodeQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>post<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>post<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> vnode
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="patch"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#patch" class="header-anchor">#</a> patch</h3> <ul><li>功能:
<ul><li>传入新旧 <code>VNode</code>，对比差异，把差异渲染到 <code>DOM</code></li> <li>返回新的 <code>VNode</code>，作为下一次 <code>patch()</code> 的 <code>oldVnode</code></li></ul></li> <li>执行过程:
<ul><li>首先执行模块中的钩子函数 <code>pre</code></li> <li>如果 <code>oldVnode</code> 和 <code>vnode</code> 相同(<code>key</code> 和 <code>sel</code> 相同)
<ul><li>调用 <code>patchVnode()</code>，找节点的差异并更新 <code>DOM</code></li></ul></li> <li>如果 <code>oldVnode</code> 是 <code>DOM</code> 元素
<ul><li>把 <code>DOM</code> 元素转换成 <code>oldVnode</code></li> <li>调用 <code>createElm()</code> 把 <code>vnode</code> 转换为真实 <code>DOM</code>，记录到 <code>vnode.elm</code></li> <li>把刚创建的 <code>DOM</code> 元素插入到 <code>parent</code> 中</li> <li>移除老节点</li> <li>触发用户设置的 <code>create</code> 钩子函数</li></ul></li></ul></li></ul> <p>源码位置:<code>src/snabbdom.ts</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">patch</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token operator">:</span> VNode <span class="token operator">|</span> Element<span class="token punctuation">,</span> vnode<span class="token operator">:</span> VNode</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token operator">:</span> number<span class="token punctuation">,</span> elm<span class="token operator">:</span> Node<span class="token punctuation">,</span> parent<span class="token operator">:</span> Node
  <span class="token comment">// 保存新插入节点的队列，为了触发钩子函数</span>
  <span class="token keyword">const</span> insertedVnodeQueue<span class="token operator">:</span> VNodeQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行模块的 pre 钩子函数</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 如果 oldVnode 不是 VNode，创建 VNode 并设置 elm</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 把 DOM 元素转换成空的 VNode</span>
    oldVnode <span class="token operator">=</span> <span class="token function">emptyNodeAt</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果新旧节点是相同节点(key 和 sel 相同)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 找节点的差异并更新 DOM</span>
    <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果新旧节点不同，vnode 创建对应的 DOM</span>
    <span class="token comment">// 获取当前的 DOM 元素</span>
    elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span>
    parent <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token keyword">as</span> Node
    <span class="token comment">// 触发 init/create 钩子函数,创建 DOM</span>
    <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果父节点不为空，把 vnode 对应的 DOM 插入到文档中</span>
      api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>elm<span class="token operator">!</span><span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 移除老节点</span>
      <span class="token function">removeVnodes</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token punctuation">[</span>oldVnode<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 执行用户设置的 insert 钩子函数 </span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> insertedVnodeQueue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    insertedVnodeQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">!</span><span class="token punctuation">.</span>hook<span class="token operator">!</span><span class="token punctuation">.</span>insert<span class="token operator">!</span><span class="token punctuation">(</span>insertedVnodeQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 执行模块的 post 钩子函数</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>post<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>post<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 返回 vnode</span>
  <span class="token keyword">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><h3 id="createelm"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#createelm" class="header-anchor">#</a> createElm</h3> <ul><li><p>功能:</p> <ul><li><code>createElm(vnode, insertedVnodeQueue)</code>，返回创建的 <code>DOM</code> 元素</li> <li>创建 <code>vnode</code> 对应的 <code>DOM</code> 元素</li></ul></li> <li><p>执行过程:</p></li> <li><p>首先触发用户设置的 <code>init</code> 钩子函数</p></li> <li><p>如果选择器是<code>!</code>，创建评论节点</p></li> <li><p>如果选择器为空，创建文本节点</p></li> <li><p>如果选择器不为空</p> <ul><li>解析选择器，设置标签的 <code>id</code> 和 <code>class</code> 属性</li> <li>执行模块的 <code>create</code> 钩子函数</li> <li>如果 <code>vnode</code> 有 <code>children</code>，创建子 <code>vnode</code> 对应的 <code>DOM</code>，追加到 <code>DOM</code> 树</li> <li>如果 <code>vnode</code> 的 <code>text</code> 值是 <code>string/number</code>，创建文本节点并追击到 <code>DOM</code> 树</li> <li>执行用户设置的 <code>create</code> 钩子函数</li> <li>如果有用户设置的 <code>insert</code> 钩子函数，把 <code>vnode</code> 添加到队列中</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createElm</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token operator">:</span> VNodeQueue</span><span class="token punctuation">)</span><span class="token operator">:</span> Node <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token operator">:</span> any
  <span class="token keyword">let</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行用户设置的 init 钩子函数</span>
    <span class="token keyword">const</span> init <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token operator">?.</span>init
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>init<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">init</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
      data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children
  <span class="token keyword">const</span> sel <span class="token operator">=</span> vnode<span class="token punctuation">.</span>sel
  <span class="token keyword">if</span> <span class="token punctuation">(</span>sel <span class="token operator">===</span> <span class="token string">'!'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果选择器是!，创建评论节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vnode<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token punctuation">}</span>
    vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">createComment</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token operator">!</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sel <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Parse selector</span>
    <span class="token comment">// 如果选择器不为空</span>
    <span class="token comment">// 解析选择器</span>
    <span class="token comment">// Parse selector</span>
    <span class="token keyword">const</span> hashIdx <span class="token operator">=</span> sel<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> dotIdx <span class="token operator">=</span> sel<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> hashIdx<span class="token punctuation">)</span>
    <span class="token keyword">const</span> hash <span class="token operator">=</span> hashIdx <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> hashIdx <span class="token operator">:</span> sel<span class="token punctuation">.</span>length
    <span class="token keyword">const</span> dot <span class="token operator">=</span> dotIdx <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> dotIdx <span class="token operator">:</span> sel<span class="token punctuation">.</span>length
    <span class="token keyword">const</span> tag <span class="token operator">=</span> hashIdx <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> dotIdx <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> sel<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> dot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> sel
    <span class="token keyword">const</span> elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>ns<span class="token punctuation">)</span>
      <span class="token operator">?</span> api<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
      <span class="token operator">:</span> api<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">&lt;</span> dot<span class="token punctuation">)</span> elm<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> sel<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>hash <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dot<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dotIdx <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> elm<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span> sel<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>dot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 执行模块的 create 钩子函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>create<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>create<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>emptyNode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
    <span class="token comment">// 如果 vnode 中有子节点，创建子 vnode 对应的 DOM 元素并追加到 DOM 树上</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> ch <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          api<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token function">createElm</span><span class="token punctuation">(</span>ch <span class="token keyword">as</span> VNode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">primitive</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 vnode 的 text 值是 string/number，创建文本节点并追加到 DOM 树</span>
      api<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> hook <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token operator">!</span><span class="token punctuation">.</span>hook
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>hook<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 执行用户传入的钩子 create</span>
      hook<span class="token punctuation">.</span>create<span class="token operator">?.</span><span class="token punctuation">(</span>emptyNode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>insert<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把 vnode 添加到队列中，为后续执行 insert 钩子做准备</span>
        insertedVnodeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果选择器为空，创建文本节点</span>
    vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token operator">!</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回新创建的 DOM</span>
  <span class="token keyword">return</span> vnode<span class="token punctuation">.</span>elm
<span class="token punctuation">}</span>
</code></pre></div><h3 id="patchvnode"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#patchvnode" class="header-anchor">#</a> patchVnode</h3> <ul><li>功能:
<ul><li><code>patchVnode(oldVnode, vnode, insertedVnodeQueue)</code></li> <li>对比 <code>oldVnode</code> 和 <code>vnode</code> 的差异，把差异渲染到 <code>DOM</code></li></ul></li> <li>执行过程:
<ul><li>首先执行用户设置的 <code>prepatch</code> 钩子函数</li> <li>执行 <code>create</code> 钩子函数
<ul><li>首先执行模块的 <code>create</code>钩子函数</li> <li>然后执行用户设置的 <code>create</code> 钩子函数</li></ul></li> <li>如果 <code>vnode.text</code> 未定义
<ul><li>如果 <code>oldVnode.children</code> 和 <code>vnode.children</code> 都有值
<ul><li>调用 <code>updateChildren()</code></li> <li>使用 <code>diff</code> 算法对比子节点，更新子节点</li></ul></li> <li>如果 <code>vnode.children</code> 有值， <code>oldVnode.children</code> 无值
<ul><li>清空 <code>DOM</code> 元素</li> <li>调用 <code>addVnodes()</code> ，批量添加子节点</li></ul></li> <li>如果 <code>oldVnode.children</code> 有值， <code>vnode.children</code> 无值
<ul><li>调用 <code>removeVnodes()</code> ，批量移除子节点</li></ul></li> <li>如果 <code>oldVnode.text</code> 有值
<ul><li>清空 <code>DOM</code> 元素的内容</li></ul></li></ul></li> <li>如果设置了 <code>vnode.text</code> 并且和和 <code>oldVnode.text</code> 不等
<ul><li>如果老节点有子节点，全部移除</li> <li>设置 <code>DOM</code> 元素的 <code>textContent</code> 为 <code>vnode.text</code></li></ul></li> <li>最后执行用户设置的 <code>postpatch</code> 钩子函数</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchVnode</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> vnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token operator">:</span> VNodeQueue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token operator">?.</span>hook
  <span class="token comment">// 首先执行用户设置的 prepatch 钩子函数</span>
  hook<span class="token operator">?.</span>prepatch<span class="token operator">?.</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token keyword">const</span> elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm<span class="token operator">!</span>
  <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children <span class="token keyword">as</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> ch <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token keyword">as</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 如果新老 vnode 相同返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> vnode<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行模块的 update 钩子函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
    <span class="token comment">// 执行用户设置的 update 钩子函数</span>
    vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>hook<span class="token operator">?.</span>update<span class="token operator">?.</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果 vnode.text 未定义</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果新老节点都有 children</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 使用 diff 算法对比子节点，更新子节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果新节点有 children，老节点没有 children</span>
      <span class="token comment">// 如果老节点有text，清空dom 元素的内容</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
      <span class="token comment">// 批量添加子节点</span>
      <span class="token function">addVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ch<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果老节点有children，新节点没有children</span>
      <span class="token comment">// 批量移除子节点</span>
      <span class="token function">removeVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果老节点有 text，清空 DOM 元素</span>
      api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有设置 vnode.text</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果老节点有 children，移除</span>
      <span class="token function">removeVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 设置 DOM 元素的 textContent 为 vnode.text</span>
    api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>text<span class="token operator">!</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后执行用户设置的 postpatch 钩子函数</span>
  hook<span class="token operator">?.</span>postpatch<span class="token operator">?.</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="updatechildren"><a href="http://interview.poetries.top/principle-docs/comprehensive/01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html#updatechildren" class="header-anchor">#</a> updateChildren</h3> <ul><li>功能:
<ul><li><code>diff</code> 算法的核心，对比新旧节点的 <code>children</code>，更新 <code>DOM</code></li></ul></li> <li>执行过程:</li> <li>要对比两棵树的差异，我们可以取第一棵树的每一个节点依次和第二课树的每一个节点比 较，但是这样的时间复杂度为 <code>O(n^3)</code></li> <li>在 <code>DOM</code> 操作的时候我们很少很少会把一个父节点移动/更新到某一个子节点</li> <li>因此只需要找同级别的子节点依次比较，然后再找下一级别的节点比较，这样算法的时间复 杂度为 <code>O(n)</code></li></ul> <p><img src="./原理_files/20210329092027.png" alt="" class="medium-zoom-image"></p> <ul><li>在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍 历的过程中移动索引</li> <li>在对开始和结束节点比较的时候，总共有四种情况
<ul><li><code>oldStartVnode / newStartVnode</code> (旧开始节点 / 新开始节点)</li> <li><code>oldEndVnode / newEndVnode</code> (旧结束节点 / 新结束节点)</li> <li><code>oldStartVnode / oldEndVnode</code> (旧开始节点 / 新结束节点)</li> <li><code>oldEndVnode / newStartVnode</code> (旧结束节点 / 新开始节点)</li></ul></li></ul> <p><img src="./原理_files/20210329092301.png" alt="" class="medium-zoom-image"></p> <ul><li>开始节点和结束节点比较，这两种情况类似
<ul><li><code>oldStartVnode / newStartVnode</code> (旧开始节点 / 新开始节点)</li> <li><code>oldEndVnode / newEndVnode</code> (旧结束节点 / 新结束节点)</li></ul></li> <li>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是 <code>sameVnode</code> (<code>key</code> 和 <code>sel</code> 相同)
<ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li> <li>把旧开始和新开始索引往后移动 <code>oldStartIdx++ / oldEndIdx++</code></li></ul></li></ul> <p><img src="./原理_files/20210329092430.png" alt="" class="medium-zoom-image"></p> <ul><li><code>oldStartVnode / newEndVnode</code> (旧开始节点 / 新结束节点) 相同
<ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li> <li>把 <code>oldStartVnode</code> 对应的 <code>DOM</code> 元素，移动到右边
<ul><li>更新索引</li></ul></li></ul></li></ul> <p><img src="./原理_files/20210329092820.png" alt="" class="medium-zoom-image"></p> <ul><li><code>oldEndVnode / newStartVnode</code> (旧结束节点 / 新开始节点) 相同
<ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li> <li>把 <code>oldEndVnode</code> 对应的 <code>DOM</code> 元素，移动到左边</li> <li>更新索引</li></ul></li></ul> <p><img src="./原理_files/20210329093025.png" alt="" class="medium-zoom-image"></p> <ul><li>如果不是以上四种情况
<ul><li>遍历新节点，使用 <code>newStartNode</code> 的 <code>key</code> 在老节点数组中找相同节点</li> <li>如果没有找到，说明 <code>newStartNode</code> 是新节点
<ul><li>创建新节点对应的 DOM 元素，插入到 DOM 树中</li></ul></li> <li>如果找到了
<ul><li>判断新节点和找到的老节点的 <code>sel</code> 选择器是否相同</li> <li>如果不相同，说明节点被修改了
<ul><li>重新创建对应的 <code>DOM</code> 元素，插入到 DOM 树中</li></ul></li> <li>如果相同，把 <code>elmToMove</code> 对应的 DOM 元素，移动到左边</li></ul></li></ul></li></ul> <p><img src="./原理_files/20210329093137.png" alt="" class="medium-zoom-image"></p> <ul><li>循环结束
<ul><li>当老节点的所有子节点先遍历完 (<code>oldStartIdx &gt; oldEndIdx</code>)，循环结束</li> <li>新节点的所有子节点先遍历完 (<code>newStartIdx &gt; newEndIdx</code>)，循环结束</li></ul></li> <li>如果老节点的数组先遍历完(<code>oldStartIdx &gt; oldEndIdx</code>)，说明新节点有剩余，把剩余节点批量插入到右边</li></ul> <p><img src="./原理_files/20210329093302.png" alt="" class="medium-zoom-image"></p> <ul><li>如果新节点的数组先遍历完(<code>newStartIdx &gt; newEndIdx</code>)，说明老节点有剩余，把剩余节点批 量删除</li></ul> <p><img src="./原理_files/20210329093414.png" alt="" class="medium-zoom-image"></p></div> </body></html>